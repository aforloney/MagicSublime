<macrodb>
  <macro>
    <name>.appl</name>
    <act>Y</act>
    <stx/>
    <dsc>Current MagicCS Application.</dsc>
    <code>/(.S).APPL</code>
    <cmt/>
  </macro>
  <macro>
    <name>.at.meditech</name>
    <act>Y</act>
    <stx/>
    <dsc>Indicates if the current ring is located at MEDITECH or not.</dsc>
    <code>/(.S).AT.MT</code>
    <cmt>Set to the value of the parameter &apos;Located at MEDITECH?&apos;. This information is used by the clinical dictionary routines to determine whether HUB identifiers can be entered for a dictionary entry.  This should only be done for standard dictionary entries at MEDITECH.
This variable was created to allow reference to this information in slash instead of requiring routines to make a server request to access this data. This variable is set when a user initially signs onto a ring.

**NOTE: This value is updated only during initial signon to a ring. If the parameter is changed for some reason, only new MagicCS sessions in this ring will be updated with the new value for the @.at.meditech flag.
</cmt>
  </macro>
  <macro>
    <name>.copy</name>
    <act>Y</act>
    <stx/>
    <dsc>Flag indicating if record has been copied to a temporary file.</dsc>
    <code>/copy</code>
    <cmt>Used primarily in screen translator-generated code.</cmt>
  </macro>
  <macro>
    <name>.country</name>
    <act>Y</act>
    <stx/>
    <dsc>Current country of HCIS (US, CANADA, or OTHER).</dsc>
    <code>/(.S).CNTRY</code>
    <cmt/>
  </macro>
  <macro>
    <name>.db</name>
    <act>Y</act>
    <stx/>
    <dsc>Current application database.</dsc>
    <code>/(.S).DB</code>
    <cmt/>
  </macro>
  <macro>
    <name>.device</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the name of the machine to which the # prefix is pointed</dsc>
    <code>#NN</code>
    <cmt>Same as @.machine.

Similar to @.machine.int (@NN) which points to where the code is currently executing.  For a 2-tier client this would be the same machine.  For a 3-tier client, the machine pointed to by # would be the client, while the machine returned by @NN would be the application server.
</cmt>
  </macro>
  <macro>
    <name>.display.db</name>
    <act>Y</act>
    <stx/>
    <dsc>Flag to always display application database in window titles</dsc>
    <code>/(.S).ALWAYS.DISPLAY.DB</code>
    <cmt>This flag, when set to &quot;Y&quot;, will cause the application database mnemonic to display in all application window title bars if @.db is correctly set. Clear the flag back to nil when functionality is no longer desired in the session. Setting or clearing the flag during runtime will not update the current window&apos;s title by itself, it will only affect subsequent window creations.

NOTE:  This functionality is NOT in accordance with standard Meditech conventions for window title bars in the 5.6 UI.  This ability was added by request from LSS, and is not recommended.</cmt>
  </macro>
  <macro>
    <name>.ds.pl</name>
    <act>Y</act>
    <stx/>
    <dsc>Plural name of the Digit Separator Character</dsc>
    <code>IF{/(.U)DIGIT.SEP.NAME.PL;&quot;_D(34)_&quot;commas&quot;_D(34)_&quot;}</code>
    <cmt/>
  </macro>
  <macro>
    <name>.exit.nks</name>
    <act>Y</act>
    <stx>1^@.exit.nks</stx>
    <dsc>Variable used to indicate that values in / should not be killed when exiting</dsc>
    <code>/exit.nks</code>
    <cmt>When exiting (after &lt;Esc&gt; has been pressed, not &lt;OK&gt;) a screen, values in / (with the exception of those beginning with lower case letters) are normally nilled out. If you do not want this to occur, set @.exit.nks to non-nil.</cmt>
  </macro>
  <macro>
    <name>.exit.nrs</name>
    <act>Y</act>
    <stx>1^@.exit.nrs</stx>
    <dsc>Variable used to indicate that / should not be restored when exiting a fragment</dsc>
    <code>/exit.nrs</code>
    <cmt>When exiting a screen fragment, / is normally restored from a copy in /(.FRG), built before the fragment was entered.  If you do not want / to be restored, set @.exit.nrs to non-nil.</cmt>
  </macro>
  <macro>
    <name>.facility</name>
    <act>Y</act>
    <stx/>
    <dsc>Current facility in a multi-facility system within the HCIS.</dsc>
    <code>/(.D).FAC</code>
    <cmt/>
  </macro>
  <macro>
    <name>.field.edit</name>
    <act>Y</act>
    <stx/>
    <dsc>Set by screen code if a field was editted.</dsc>
    <code>/FIELD.EDIT</code>
    <cmt>This is only set if a Screen is set to conditional show the exit prompt.</cmt>
  </macro>
  <macro>
    <name>.field.edit.suppress</name>
    <act>Y</act>
    <stx/>
    <dsc>Set by screen code to suppress &quot;Changes will not be saved.  Cancel Anyway?&quot;</dsc>
    <code>/FIELD.EDIT.SUPPRESS</code>
    <cmt>This is set when the screen element &apos;Suppress Changes will not be saved message?&apos; equals
&quot;Y&quot;.   For type 2 screens,  this is the default behavior.

.SI -   sets @.field.edit.suppress
.SX -   clears @.field.edit.suppress</cmt>
  </macro>
  <macro>
    <name>.guid</name>
    <act>Y</act>
    <stx/>
    <dsc>Generates a Windows globaly unique identifier.</dsc>
    <code>#G</code>
    <cmt>Returns a 36-character unique value.</cmt>
  </macro>
  <macro>
    <name>.hcis</name>
    <act>Y</act>
    <stx/>
    <dsc>Translates to variable containing the current HCIS.</dsc>
    <code>/(.S).HCIS</code>
    <cmt/>
  </macro>
  <macro>
    <name>.ip.machine</name>
    <act>Y</act>
    <stx>IP@.ip.machine</stx>
    <dsc>Returns machine name for a given IP address.</dsc>
    <code>@Nn</code>
    <cmt>Example: IP@.ip.machine^MACHINE.NAME </cmt>
  </macro>
  <macro>
    <name>.ipc.group</name>
    <act>Y</act>
    <stx/>
    <dsc>Group name for a session</dsc>
    <code>/(.U).IPC|0</code>
    <cmt>Note:

Currently being implemented for UI launch.  See Dave Coburn before using.</cmt>
  </macro>
  <macro>
    <name>.ipc.name</name>
    <act>Y</act>
    <stx/>
    <dsc>IPC session name</dsc>
    <code>/(.U).IPC|1</code>
    <cmt>Note:

Currently being implemented for UI launch.

See Dave Coburn before using.
</cmt>
  </macro>
  <macro>
    <name>.itn</name>
    <act>Y</act>
    <stx/>
    <dsc>Screen multiple current row</dsc>
    <code>itn</code>
    <cmt>Translates to local variable &apos;itn&apos; which is used in screen translator-generated code to store the row number of the entry in a multiple on which the cursor is currently pointing.

The top visible row of the multiple corresponds to itn=1.</cmt>
  </macro>
  <macro>
    <name>.job</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the unique job number for the current client MagicCS session.</dsc>
    <code>S(&quot;_D(34)_&quot;J&quot;_D(34)_&quot;)</code>
    <cmt/>
  </macro>
  <macro>
    <name>.line</name>
    <act>Y</act>
    <stx/>
    <dsc>Generate new report line</dsc>
    <code>IF{/R.LL-1^/R.LL&lt;1 [/R.NEW.PAGE.PGM](0)}</code>
    <cmt>Translates to code which decrements the number of lines left on a report page, and if zero, calls the program which creates a new page.</cmt>
  </macro>
  <macro>
    <name>.lines.left</name>
    <act>Y</act>
    <stx/>
    <dsc>Report&apos;s number of lines left</dsc>
    <code>/R.LL</code>
    <cmt>Translates to variable which contains the number of lines left on the current page of a report.</cmt>
  </macro>
  <macro>
    <name>.lis.access</name>
    <act>Y</act>
    <stx/>
    <dsc>Translates to variable containing LIS access group.</dsc>
    <code>/(.D)LIS.ACCESS</code>
    <cmt/>
  </macro>
  <macro>
    <name>.lis.site</name>
    <act>Y</act>
    <stx/>
    <dsc>Translates to variable containing LIS site.</dsc>
    <code>/(.D)LIS.SITE</code>
    <cmt/>
  </macro>
  <macro>
    <name>.lookup</name>
    <act>Y</act>
    <stx/>
    <dsc>Number of lookup entries</dsc>
    <code>/(.S).LK</code>
    <cmt/>
  </macro>
  <macro>
    <name>.machine</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the name of the machine to which the # prefix is pointed</dsc>
    <code>#NN</code>
    <cmt>Same as @.device.

Similar to @.machine.int (@NN) which points to where the code is currently executing.  For a 2-tier client this would be the same machine.  For a 3-tier client, the machine pointed to by # would be the client, while the machine returned by @NN would be the application server.
</cmt>
  </macro>
  <macro>
    <name>.machine.int</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the name of the machine on which the application code is executing.</dsc>
    <code>@NN</code>
    <cmt>Similar to @.machine and @.device (#NN) which point to where the user interface is currently executing.  For a 2-tier client this would be the same machine.  For a 3-tier client, the machine pointed to by # would be the client, while the machine returned by @.machine.int (@NN) would be the application server.</cmt>
  </macro>
  <macro>
    <name>.machine.ip</name>
    <act>Y</act>
    <stx>machineName@.machine.ip</stx>
    <dsc>Returns IP address of &apos;machineName&apos;.</dsc>
    <code>@Ni</code>
    <cmt/>
  </macro>
  <macro>
    <name>.menu.arg</name>
    <act>Y</act>
    <stx/>
    <dsc>Old menu argument macro</dsc>
    <code>/.MNU.ARG|0</code>
    <cmt/>
  </macro>
  <macro>
    <name>.menu.tm</name>
    <act>Y</act>
    <stx/>
    <dsc>Translates to variable containing the menu timeout parameter in seconds.</dsc>
    <code>/(.S).MENU.TM</code>
    <cmt/>
  </macro>
  <macro>
    <name>.mri.pfx</name>
    <act>Y</act>
    <stx/>
    <dsc>Translates to variable containing the current MRI prefix.</dsc>
    <code>/(.D).MPX</code>
    <cmt/>
  </macro>
  <macro>
    <name>.new</name>
    <act>Y</act>
    <stx/>
    <dsc>Screen new-internal value of a field</dsc>
    <code>B</code>
    <cmt>Translates to local variable used in screen translator-generated code to contain the &quot;new internal&quot; value of a field.</cmt>
  </macro>
  <macro>
    <name>.new.ext</name>
    <act>Y</act>
    <stx/>
    <dsc>Screen new-external value of a field</dsc>
    <code>A</code>
    <cmt>Translates to local variable used in screen translator-generated code to contain the &quot;new external&quot; value of a field.</cmt>
  </macro>
  <macro>
    <name>.new.page.pgm</name>
    <act>Y</act>
    <stx/>
    <dsc>Report new page program</dsc>
    <code>/R.NEW.PAGE.PGM</code>
    <cmt>Translates to variable which contains the name of the program which produces a new page for the report.</cmt>
  </macro>
  <macro>
    <name>.no.exit.prompt</name>
    <act>Y</act>
    <stx/>
    <dsc>Holds the state of the DB&apos;s showing of the exit prompt when exiting screens.</dsc>
    <code>/(.D)NO.EXIT.PROMPT</code>
    <cmt>Used by the exit logic of a screen to determine if the exit prompt should be shown.

No value means to show the exit box/Use the HCIS parameters
Value Y means to allow for coded exit box control in the screens.
Value N means override the HCSI Parameter setting.</cmt>
  </macro>
  <macro>
    <name>.no.page.save</name>
    <act>Y</act>
    <stx/>
    <dsc>Multi-page screen flag to skip saving page in memory when leaving</dsc>
    <code>/no.page.save</code>
    <cmt>Translates to variable used in screen translator-generated multi-page screens to flag if page should not be saved in memory when leaving.</cmt>
  </macro>
  <macro>
    <name>.now</name>
    <act>Y</act>
    <stx/>
    <dsc>Translates to code which returns the current time in external format.</dsc>
    <code>%(Z)time.out(S(0)+/(.D).TZO)</code>
    <cmt/>
  </macro>
  <macro>
    <name>.ok</name>
    <act>Y</act>
    <stx/>
    <dsc>Variable in screen xlated code that it&apos;s logically valid to execute &quot;OK logic&quot;.</dsc>
    <code>ok</code>
    <cmt/>
  </macro>
  <macro>
    <name>.old</name>
    <act>Y</act>
    <stx/>
    <dsc>Screen old-internal value of a field</dsc>
    <code>D</code>
    <cmt>Translates to local variable used in screen translator-generated code to contain the &quot;old internal&quot; value of a field.</cmt>
  </macro>
  <macro>
    <name>.old.ext</name>
    <act>Y</act>
    <stx/>
    <dsc>Screen new-external value of a field</dsc>
    <code>C</code>
    <cmt>Translates to local variable used in screen translator-generated code to contain the &quot;old external&quot; value of a field.</cmt>
  </macro>
  <macro>
    <name>.on.device</name>
    <act>Y</act>
    <stx/>
    <dsc>Translates to variable containing the name of the &quot;print on&quot; device.</dsc>
    <code>/.PRT</code>
    <cmt/>
  </macro>
  <macro>
    <name>.program.files</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns interpeters pointer to the blessed program files</dsc>
    <code>@DP</code>
    <cmt/>
  </macro>
  <macro>
    <name>.recall</name>
    <act>Y</act>
    <stx/>
    <dsc>Screen recall value</dsc>
    <code>G</code>
    <cmt>Translates to the variable used in screen translator-generated code to recall the last value as entered by the user (before any conversions, lookups, etc.).
</cmt>
  </macro>
  <macro>
    <name>.redundant.dict.job</name>
    <act>Y</act>
    <stx/>
    <dsc>Flag used in dictionary filers to know if dictionary xfer program calling filer</dsc>
    <code>/(.S).RDJ</code>
    <cmt>Translates to flag used in dictionary filers to know when the background dictionary transfer program is calling rather than a user.  At this time, dictionaries are not being kept redundantly, hence no such background job currently exists.  Code has been incorporated in filers for possible future use.</cmt>
  </macro>
  <macro>
    <name>.response</name>
    <act>Y</act>
    <stx/>
    <dsc>User response -- CDS only</dsc>
    <code>/S.A</code>
    <cmt/>
  </macro>
  <macro>
    <name>.response.old</name>
    <act>Y</act>
    <stx/>
    <dsc>Previous value -- CDS only</dsc>
    <code>/S.C</code>
    <cmt/>
  </macro>
  <macro>
    <name>.ring</name>
    <act>Y</act>
    <stx/>
    <dsc>The variable containing the NPR ring to which the user is signed on.</dsc>
    <code>/(.S).RING</code>
    <cmt/>
  </macro>
  <macro>
    <name>.save.enable.suppress</name>
    <act>Y</act>
    <stx/>
    <dsc>Suppress the automatic enabling of the Save/OK button.</dsc>
    <code>/SAVE.ENABLE.SUPPRESS</code>
    <cmt>If this flag is valued (TRUE), the UI system will not automatically enable the Save/OK button upon detecing an edit.  Applications will need to manage the setting/clearing of this flag to ensure the desire results.</cmt>
  </macro>
  <macro>
    <name>.scrn.rfrsh</name>
    <act>Y</act>
    <stx/>
    <dsc>Translates to variable containing the screen refresh time in seconds.</dsc>
    <code>/(.S).SCRN.RFRSH</code>
    <cmt/>
  </macro>
  <macro>
    <name>.scrn.tm</name>
    <act>Y</act>
    <stx/>
    <dsc>Translates to variable containing the field timeout in seconds for the screen.</dsc>
    <code>/(.S).SCRN.TM</code>
    <cmt/>
  </macro>
  <macro>
    <name>.sd</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the time zone-adjusted database time.</dsc>
    <code>(S(0)+/(.D).TZO)</code>
    <cmt>&quot;sd&quot; = S(0) adjusted by time zone offset for the database</cmt>
  </macro>
  <macro>
    <name>.skip.exit</name>
    <act>Y</act>
    <stx/>
    <dsc>Flag in screen translated code to skip exit confirmation box</dsc>
    <code>/(.S).SKIP.EXIT</code>
    <cmt/>
  </macro>
  <macro>
    <name>.skip.ok</name>
    <act>Y</act>
    <stx/>
    <dsc>Flag in screen translated code to skip ok confirmation box</dsc>
    <code>/(.S).SKIP.OK</code>
    <cmt/>
  </macro>
  <macro>
    <name>.sn</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the network time.</dsc>
    <code>S(0)</code>
    <cmt>&quot;sn&quot; = S(0) for the network</cmt>
  </macro>
  <macro>
    <name>.time.zone.offset</name>
    <act>Y</act>
    <stx/>
    <dsc>Application database time zone offset from the HCIS time.</dsc>
    <code>/(.D).TZO</code>
    <cmt>Translates to the variable containing the application database time zone offset from the HCIS time, in seconds.</cmt>
  </macro>
  <macro>
    <name>.today</name>
    <act>Y</act>
    <stx/>
    <dsc>The current date in internal (YYYYMMDD) format.</dsc>
    <code>/(.S).DAT</code>
    <cmt>Translates to the variable containing the current date in internal (YYYYMMDD) format.</cmt>
  </macro>
  <macro>
    <name>.unv</name>
    <act>Y</act>
    <stx/>
    <dsc>The Universe to which the user is signed on.</dsc>
    <code>/(.S).UNV</code>
    <cmt>Translates to the variable containing the Universe to which the user is signed on.</cmt>
  </macro>
  <macro>
    <name>.update.today</name>
    <act>Y</act>
    <stx/>
    <dsc>Code that does the standard updating of the current date variable.</dsc>
    <code>IF{&quot;_D(34)_D(34)_&quot;^/(.S).DAT;%(Z)date.in(&quot;_D(34)_&quot;T&quot;_D(34)_&quot;)^/(.S).DAT}</code>
    <cmt/>
  </macro>
  <macro>
    <name>.urn</name>
    <act>Y</act>
    <stx/>
    <dsc>Screen multiple current urn</dsc>
    <code>urn</code>
    <cmt>Translates to local variable urn which is used in screen translator-generated code to store the urn (ie. key field value) of the entry in a multiple on which the cursor is currently pointing.</cmt>
  </macro>
  <macro>
    <name>.user</name>
    <act>Y</act>
    <stx/>
    <dsc>Translates to the variable containing the current user.</dsc>
    <code>/(.S).USR</code>
    <cmt/>
  </macro>
  <macro>
    <name>3D.frames</name>
    <act>Y</act>
    <stx>@3D.frames(row,col,height in rows,width in cols)</stx>
    <dsc>Creates a three dimensional frame on the screen</dsc>
    <code>D(4,10,@1,@2,@3,@4)</code>
    <cmt/>
  </macro>
  <macro>
    <name>3Tier.copy.mem.to.client</name>
    <act>Y</act>
    <stx>@3Tier.copy.mem.to.client(serverHandle,clientHandle,serverPrefix)</stx>
    <dsc>Copy memory buffer from application server to client.</dsc>
    <code>{@2,^@3,@1}^#mz</code>
    <cmt>Copies the contents of a memory buffer on the application server (serverHandle) to a memory buffer on the client (clientHandle).  The &apos;serverPrefix&apos; is the prefix that is opened to the application server containing the memory buffer.  Memory buffer contents are copied from the current cursor position in the server memory buffer and written starting at the current cursor position in the client memory buffer.</cmt>
  </macro>
  <macro>
    <name>3Tier.copy.mem.to.server</name>
    <act>Y</act>
    <stx>@3Tier.copy.mem.to.server(clientHandle,serverHandle,serverPrefix)</stx>
    <dsc>Copy memory buffer from client to application server.</dsc>
    <code>#mz[{@1,^@3,@2}]</code>
    <cmt>Copies the contents of a memory buffer on a client (clientHandle) to a memory buffer on the application server (serverHandle).  The &apos;serverPrefix&apos; is the prefix that is opened to the application server containing the memory.  Memory buffer contents are copied from the current cursor position in the client memory buffer and written starting at the current cursor position in the server memory buffer.</cmt>
  </macro>
  <macro>
    <name>3Tier.copy.saf.to.client</name>
    <act>Y</act>
    <stx>@3Tier.copy.saf.to.client(clientPrefix,serverPrefix)</stx>
    <dsc>Copy SAF from application server to client.</dsc>
    <code>^@1^@2Z</code>
    <cmt>Copies an SAF that lives on an application server to a client.

The &apos;serverPrefix&apos; is the prefix opened to the SAF on the application server and the &apos;clientPrefix&apos; is the prefix opened to the SAF on the client.

Example:
  ^/^\Z where / is open to application server SAF and \ is open to client SAF.
</cmt>
  </macro>
  <macro>
    <name>3Tier.copy.saf.to.server</name>
    <act>Y</act>
    <stx>@3Tier.copy.saf.to.server(clientPrefix,serverPrefix)</stx>
    <dsc>Copy SAF from client to application server.</dsc>
    <code>@1Z[^@2]</code>
    <cmt>The clientPrefix is the prefix opened to the SAF on the client and the serverPrefix is the prefix opened to the SAF on the application server.

Example: \Z[^/] where \ is open to client SAF and / is open to application server SAF.
</cmt>
  </macro>
  <macro>
    <name>API.error</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the last API error as a number.</dsc>
    <code>#aE</code>
    <cmt>Example: &apos;87&apos; means Invalid Parameter</cmt>
  </macro>
  <macro>
    <name>API.invoke</name>
    <act>Y</act>
    <stx>@API.invoke(APIName,memoryHandle)</stx>
    <dsc>Invokes the API [APIName] where [memoryHandle] passes in arguments</dsc>
    <code>#aI[@1,@2]</code>
    <cmt>[memoryHandle] should point to a string of semi-colon delimited arguments.

Returns: return value of the API if successful, else NIL.</cmt>
  </macro>
  <macro>
    <name>API.load</name>
    <act>Y</act>
    <stx>@API.load(memoryHandle)</stx>
    <dsc>Loads one or more Librarys with associated APIs.</dsc>
    <code>#aL[@1]</code>
    <cmt>[memoryHandle] contains entries in the following format:

[LibraryName]
APIName;ReturnType;ArgumentType;...;ArgumentType
...

Types (for Arguments or Return):
0 = DWORD
1 = String
2 = LPBuffer (MemoryID)
3 = DOUBLE (64 bit double precision)

Returns: NIL if successful else Error#</cmt>
  </macro>
  <macro>
    <name>AT.bitmap</name>
    <act>Y</act>
    <stx>@AT.bitmap(bitmapFile)</stx>
    <dsc>Annotation Tool -- Save the picture with graphics to [bitmapFile]</dsc>
    <code>#rA[5,@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>AT.data</name>
    <act>Y</act>
    <stx>@AT.data(memBuf)</stx>
    <dsc>Annotation Tool -- insert annotations from [memBuf] into the image</dsc>
    <code>#rA[2,@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>AT.detach</name>
    <act>Y</act>
    <stx>@AT.detach(&quot;&quot;)</stx>
    <dsc>Annotation Tool -- Shut down VMagicAT</dsc>
    <code>#rA[86]</code>
    <cmt/>
  </macro>
  <macro>
    <name>AT.image</name>
    <act>Y</act>
    <stx>@AT.image(newPictureFile)</stx>
    <dsc>Annotation Tool -- Replace the picture in VMagicAT with [newPictureFile]</dsc>
    <code>#rA[1,@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>AT.key</name>
    <act>Y</act>
    <stx>@AT.key(&quot;&quot;)</stx>
    <dsc>Annotation Tool -- Lets the user draw.</dsc>
    <code>#rA[3]</code>
    <cmt>This function goes hung for VMagicAT, and returns when the user types &lt;F12&gt; or clicks the &quot;X&quot; button.  When under MagicCS control, the &quot;X&quot; button does not close the program, but     instead behaves as if the user had typed &lt;F12&gt;.</cmt>
  </macro>
  <macro>
    <name>AT.notes</name>
    <act>Y</act>
    <stx>@AT.notes(textFile)</stx>
    <dsc>Annotation Tool -- Save the text portion of the annotations into [textFile]</dsc>
    <code>#rA[6,@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>AT.quick.text</name>
    <act>Y</act>
    <stx>@AT.quick.text(memoryHandle)</stx>
    <dsc>Feed quick text buffer to VMagicAT</dsc>
    <code>#rA[7,@1]</code>
    <cmt>When user enters punctuation, preceding word is searched for in this buffer to look for replacement text.  [memoryHandle] is a Memory buffer, which contains lite list:

     D(1)
     D(1)_mnemonic_D(3)_replace_D(2)_D(3)   &lt;repeat as necessary&gt;
     D(1)_mnemonic_D(3)_replace_D(2)
     D(2)
</cmt>
  </macro>
  <macro>
    <name>AT.results</name>
    <act>Y</act>
    <stx>@AT.results(memBuf)</stx>
    <dsc>Annotation Tool -- Retrieve the annotaions in FS list format into [memBuf]</dsc>
    <code>#rA[4,@1]</code>
    <cmt>This retrieves not only the text but also the information about marker size, color,</cmt>
  </macro>
  <macro>
    <name>AT.start</name>
    <act>Y</act>
    <stx>@AT.start(startingPictureFile)</stx>
    <dsc>Annotation Tool -- Start VMagicAT with the image from [startingPictureFile]</dsc>
    <code>#rA[0,@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Abs</name>
    <act>Y</act>
    <stx>@Abs(A)</stx>
    <dsc>Calculate the absolute value of A.</dsc>
    <code>(@1!(0-(@1)))</code>
    <cmt/>
  </macro>
  <macro>
    <name>Add</name>
    <act>Y</act>
    <stx>@Add(A,B)</stx>
    <dsc>Adds B to A and places the result in B.</dsc>
    <code>&quot;_IF{S&apos;=2 %NPRLER(&quot;FN&quot;,@0);&quot;@1+@2^@2&quot;}_&quot;</code>
    <cmt/>
  </macro>
  <macro>
    <name>Alt.highlight.panel.row</name>
    <act>Y</act>
    <stx>@Alt.highlight.panel.row(row,column,width)</stx>
    <dsc>Display a dotted box around a row at [row] and [column] in a &apos;recessed&apos; panel.</dsc>
    <code>D(16,@1,@2,24,8,@3)</code>
    <cmt>Used as an alternate highlight in panels in screens to show which row you are on.</cmt>
  </macro>
  <macro>
    <name>Alt.highlight.panel.row.cur.pos</name>
    <act>Y</act>
    <stx>@Alt.highlight.panel.row.cur.pos(width)</stx>
    <dsc>Display a dotted box around a row at current cursor pos in &apos;recessed&apos; panel</dsc>
    <code>D(24,8,@1)</code>
    <cmt>Used as an alternate highlight in panels in screens to show which row you are on.</cmt>
  </macro>
  <macro>
    <name>Alt.highlight.row</name>
    <act>Y</act>
    <stx>@Alt.highlight.row(row,column,width)</stx>
    <dsc>Display a dotted box around a row at [row] and [column].</dsc>
    <code>D(16,@1,@2,24,6,@3)</code>
    <cmt>Used as an alternate highlight in &quot;process&quot; screens to show which row you are on.</cmt>
  </macro>
  <macro>
    <name>Alt.highlight.row.cur.pos</name>
    <act>Y</act>
    <stx>@Alt.highlight.row.cur.pos(width)</stx>
    <dsc>Display a dotted box around a row at the current cursor position.</dsc>
    <code>D(24,6,@1)</code>
    <cmt>Used as an alternate highlight in &quot;process&quot; screens to show which row you are on.</cmt>
  </macro>
  <macro>
    <name>Alt.normal.panel.row</name>
    <act>Y</act>
    <stx>@Alt.normal.panel.row(row,column,width)</stx>
    <dsc>Erase a dotted box around a row at [row] and [column] in a &apos;recessed&apos; panel.</dsc>
    <code>D(16,@1,@2,24,9,@3)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Alt.normal.panel.row.cur.pos</name>
    <act>Y</act>
    <stx>@Alt.normal.panel.row.cur.pos(width)</stx>
    <dsc>Erase a dotted box around a row at current cursor pos in &apos;recessed&apos; panel</dsc>
    <code>D(24,9,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Alt.normal.row</name>
    <act>Y</act>
    <stx>@Alt.normal.row(row,column,width)</stx>
    <dsc>Erase a dotted box around a row at row and column.</dsc>
    <code>D(16,@1,@2,24,7,@3)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Alt.normal.row.cur.pos</name>
    <act>Y</act>
    <stx>@Alt.normal.row.cur.pos(width)</stx>
    <dsc>Erase a dotted box around a row at the current cursor position.</dsc>
    <code>D(24,7,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Appl.file.prefix</name>
    <act>Y</act>
    <stx>@Appl.file.prefix(appl,filename)</stx>
    <dsc>At translation time, substitute the prefix used for this logical filename.</dsc>
    <code>&quot;_&amp;IA[S[1]]PFX[S[2]]|0_&quot;</code>
    <cmt>Example: @Appl.file.prefix(LAB,CDATA) translates to: *(S)</cmt>
  </macro>
  <macro>
    <name>Atomic.increment</name>
    <act>Y</act>
    <stx/>
    <dsc>Provides a method to increment a disk based counter without using locks.</dsc>
    <code>i(@1)</code>
    <cmt>The Atomic Increment function is meant to replace code that locks a structure, increments and then unlocks it.

@Lock(@Root(@audit.trail)),
@Last(audit.urn)+1^audit.urn,
{ACTION,@.sd,@.user,@.device,step}^@audit.trail,
@Unlock(@Root(@audit.trail))

could be rewritten as

i(@Root(@audit.trail))^audit.urn,
{ACTION,@.sd,@.user,@.device,step}^@audit.trail,

For more see the Wiki article for Atomic Increment.</cmt>
  </macro>
  <macro>
    <name>Authenticated.user</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns domain\authenticated user</dsc>
    <code>#UA</code>
    <cmt>Returns domain\authenticated user or nil</cmt>
  </macro>
  <macro>
    <name>Base64.decode</name>
    <act>Y</act>
    <stx/>
    <dsc>Decodes data from base64 to a string</dsc>
    <code>@AS</code>
    <cmt>Additional Notes:

On the decoding side, there are some checks for the validity of the input data. That said, some errors are ignored as well. For instance, illegal characters are simply ignored and passed by. However, the function expects to be handed an integral multiple of 4 decodeable characters. For instance, if you hand it 128 characters which are broken into 2 lines of 64 characters each, and a CRLF between (total of 130 characters), it will ignore the CRLF when it encounters them, so ythese will be OK. It does expect correct padding with =&apos;s on the input stream.

This can get tricky  if you&apos;re trying to decode a larger block of data if you&apos;re uncertain about it containing line breaks, etc. If you&apos;re uncertain, it might be wise to first normalize the data by running it through a translate string that deletes illegal characters first. Then you can simpy pass in chunks of any integral multiple of 4 characters from your scrubbed source data.</cmt>
  </macro>
  <macro>
    <name>Base64.encode</name>
    <act>Y</act>
    <stx/>
    <dsc>Encodes data from a string to base64</dsc>
    <code>@SA</code>
    <cmt>Note: By definition, the encoded data is longer than the source data. The application must make allowance for this. For instance X$240@SA^Y is not a good choice.</cmt>
  </macro>
  <macro>
    <name>Bell</name>
    <act>Y</act>
    <stx>@Bell(&quot;&quot;)^#</stx>
    <dsc>Rings the &quot;bell&quot; on the user&apos;s PC.</dsc>
    <code>D(7)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Break.disable</name>
    <act>Y</act>
    <stx>@Break.disable(&quot;&quot;)^#</stx>
    <dsc>Disables the &apos;BREAK&apos; key: &lt;CTRL&gt;&lt;PAUSE&gt;</dsc>
    <code>D(15,0)</code>
    <cmt>The default state of a USER mode MagicCS session is to have the &apos;BREAK&apos; key disabled.  To enable the &apos;BREAK&apos; key, use @Break.enable or sign on in PROG mode.</cmt>
  </macro>
  <macro>
    <name>Break.enable</name>
    <act>Y</act>
    <stx>@Break.enable(&quot;&quot;)^#</stx>
    <dsc>Enables the &apos;BREAK&apos; key: &lt;CTRL&gt;&lt;PAUSE&gt;</dsc>
    <code>D(15,1)</code>
    <cmt>The default state of a USER mode MagicCS session is to have the &apos;BREAK&apos; key disabled (see @Break.disable).  To enable the &apos;BREAK&apos; key, use this macro or sign on in PROG mode.</cmt>
  </macro>
  <macro>
    <name>Bufferpool.stats</name>
    <act>Y</act>
    <stx/>
    <dsc>Server function to return data about the buffer pool.</dsc>
    <code>@Bs</code>
    <cmt/>
  </macro>
  <macro>
    <name>Button.blast</name>
    <act>Y</act>
    <stx>@Button.blast(memoryHandle/&lt;path&gt;Filename)</stx>
    <dsc>Creates a set of buttons from entries in a file or buffer.</dsc>
    <code>#bB[@1]</code>
    <cmt>The argument may be either:  a number, meaning the handle of a MagicCS memory buffer or a &lt;path&gt;Filename, indicating the file containing the Toolbar/Buttons information.  The buffer contains one &lt;CRLF&gt; delimited entry for each button.  Each entry is a semicolon(;) delimited string with the following format:

ButtonType;Row;Col;PixelOffsetVertical;PixelOffsetHorizontal;Height;Width;Flags;HotKey;
Text;Font
 or
&lt;Path&gt;FileName(picture);ToolTipText;Font

o  Row and Col specify MagicCS character position.
o  PixelOffsetVertical and PixelOffsetHorizontal indicate a shift from the                      upper-left-hand-corner of the character position. These may be negative (eg. -2).
o  Flags is a bitmask where 1 = DisabledOnCreate and 4 = ShortCut.  All other bits are          undefined.
o  The ShortCut flag causes the shortcut symbol to be displayed in the                          lower-left-hand-corner of the button.

o  Font (0-15) is used to specify a font for any text associated with the button.  Upon
   completion of call to #bB the CurrentFont is restored.
</cmt>
  </macro>
  <macro>
    <name>Button.create</name>
    <act>Y</act>
    <stx>@Button.create(buttonType,row,column,height,width,buttonLabel,hotKey!vOffset)</stx>
    <dsc>Creates a button at {[row],[column]}.  Returns: ButtonHandle.</dsc>
    <code>#bC[@1,@2,@3,@4,@5,@6&quot;_IF{S[7] &quot;,@7&quot;}_&quot;]</code>
    <cmt>[row]=&quot;H&quot; means to place the button in the header bar of the Windows window.

The [buttonLabel] parameter has a different meaning depending on the button type:

[buttonTypes]:
    0 Pushbutton (the basic &quot;button&quot;).
    1 Default Pushbutton (the basic &quot;button&quot; with highlight).
    2 CheckBox
    3 Auto CheckBox
    4 RadioButton
    5 3-State Button
    6 Auto 3-State
    7 Group Frame
    8 UserButton
    9 Auto RadioButton
   11 Owner Draw button.
   15 Basic PashButton (text will highlight if @Button.highlight is used)
   16 Static Control.
   17 Multi-line button
   67 &quot;Sticky&quot; button

   128 May be added to the above to indicate a button which will be initially Disabled          (except #16 which has different rules).

For button types 0 and 1, the ButtonLabel is the text of the button.  The text may contain an ampersand (&amp;) indicating that the following character is the Hot key for this button.  If AND ONLY IF one of the buttons has the focus and the Hot key is typed, the focus will return and the #L will indicate that the button with the Hot key was clicked.  You set the focus to a button using the @Button.focus macro.

For button type 11, the ButtonLabel is the pictureHandle which contains the images that are to be displayed for the button in its unpressed and pressed states.  The pictureHandle is returned by the @Picture.create macro.

For button type 11, the HotKey may also be specified to indicate a key which, when pressed with the &lt;ALT&gt; key will cause the button to behave as if it had been pushed.  For button types 0, 1 &amp; 15, the hotKey argument acts as a verticalOffset field that changes the vertical position of the button in pixels.

Owner draw buttons derive their size from the picture.  This picture must include the border around the button as well as the button itself and its image.  For @Button.create, the picture must be exactly 3-times taller than the actual button.  The top of the picture depicts the button in its unpressed state; the middle of the picture depicts the button in its pressed state; the bottom of the picture depicts the button in its disabled state.  See also @Button.make.

For button types 0 and 1, the height parameter is ignored, and the width parameter is expressed in characters in the original font for the MagicCS window.  For button type 11, both the height and width parameters are expressed in pixels.  If these parameters are values less than or equal to the actual button size expressed in the bitmap, the parameters are ignored; otherwise, the button is drawn centered in the region defined by those parameters offset from the origin row and column.

For button types 0,1 and 15 if the height parameter is less than 10 the current 24 pixel high button will be created.  If the value is greater than ten then a button will be created that is that number of pixels in height.

For button type 17, the text can now be split by added the \r where a line break should occur these characters are not to be counted as part of the width of the button.  The height of such a button should be expressed in pixels like the type 15 button

Button type 67 will create a &quot;sticky&quot; button which will remain depressed after hit has been
selected and will return to normal when selected again.  This is based on the radio button so height should be 1 in all cases.
</cmt>
  </macro>
  <macro>
    <name>Button.delete</name>
    <act>Y</act>
    <stx>@Button.delete(buttonHandle)</stx>
    <dsc>Deletes the designated button.</dsc>
    <code>#bX[@1]</code>
    <cmt>Deletes the button and erases the background to the current background color.</cmt>
  </macro>
  <macro>
    <name>Button.disable</name>
    <act>Y</act>
    <stx>@Button.disable(buttonHandle)</stx>
    <dsc>Disables the designated button.</dsc>
    <code>#bD[@1]</code>
    <cmt>The button no longer receives mouse clicks, and is displayed &quot;greyed out.&quot;  Setting focus to the button using #bF[] cancels this condition.</cmt>
  </macro>
  <macro>
    <name>Button.enable</name>
    <act>Y</act>
    <stx>@Button.enable(buttonHandle)</stx>
    <dsc>Enables the designated button.</dsc>
    <code>#bE[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Button.focus</name>
    <act>Y</act>
    <stx>@Button.focus(buttonHandle)</stx>
    <dsc>Sets the input focus to the designated button.</dsc>
    <code>#bF[@1]</code>
    <cmt>All input will be processed by the button, and no input will be processed by any other MagicCS routine.  The input will be satisfied by typing the Hot key of this or one of &lt;CR&gt;, &lt;ESC&gt;, &lt;BACKSPACE&gt;, &lt;TAB&gt;, &lt;NextSection-F6&gt;, &lt;Exit-F11&gt;, &lt;OK-F12&gt;, and the &quot;Cluster&quot; Keys (Insert, Delete, Home, End, PageUp, PageDown, Arrows), or by clicking this or another button with the mouse.  Typing a Hot key is just like clicking with the mouse, putting the information in #L.  Typing one of the other keys puts the key code in #Y.

Setting focus automatically re-enables a button if it was disabled using #bD[].
</cmt>
  </macro>
  <macro>
    <name>Button.highlight</name>
    <act>Y</act>
    <stx>@Button.highlight(buttonHandle,textColor)</stx>
    <dsc>Changes the Text color for Static Controls (#bC[16,...]) to the color specified.</dsc>
    <code>#bH[@1,@2]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Button.make</name>
    <act>Y</act>
    <stx>@Button.make(row,column,flags,hotKey,UNVFilename)</stx>
    <dsc>Create an ownerdraw button at [row] and [column]</dsc>
    <code>#bM[@1,@2,@3,@4,@5]</code>
    <cmt>Creates an Ownerdraw button at the specified [row] and [column] position using the picture contained in [UNVFilename] as the glyph.

The `button&apos; part is drawn by the system as well as the glyph in its disabled state.  If a [hotKey] is specified it is drawn in the upper right hand corner of the button.  [flags] is a bitmask where 1 = DisabledOnCreate.  All other bits are undefined.</cmt>
  </macro>
  <macro>
    <name>Button.make.relative</name>
    <act>Y</act>
    <stx>@Button.make.relative(vertOffset,horizOffset,flags,hotKey,UNVFilename)</stx>
    <dsc>Create an ownerdraw button [vertOffset] and [horizOffset] pixels from cur pos</dsc>
    <code>#bL[@1,@2,@3,@4,@5]</code>
    <cmt>Creates an Ownerdraw button at [vertOffset] and [horizOffset] in pixels from the current cursor position using the picture contained in [UNVFilename] as the glyph.

The `button&apos; part is drawn by the system as well as the glyph in its disabled state.  If a [hotKey] is specified it is drawn in the upper right hand corner of the button.  [flags] is a bitmask where 1 = DisabledOnCreate.  All other bits are undefined.  [vertOffset] and [horizOffset] may be negative (eg. -2).
</cmt>
  </macro>
  <macro>
    <name>Button.state.get</name>
    <act>Y</act>
    <stx>@Button.state.get(buttonHandle)</stx>
    <dsc>Returns the Check-state of the specified button.</dsc>
    <code>#bG[@1]</code>
    <cmt>For ALL buttons:
  0 = Unchecked/Unselected/Unpushed

For RadioButtons and CheckBoxes:
  1 = Checked
  2 = Indeterminate

For Pushbuttons and Ownerdraw Buttons:
  4 = Pushed
</cmt>
  </macro>
  <macro>
    <name>Button.state.set</name>
    <act>Y</act>
    <stx>@Button.state.set(buttonHandle,state)</stx>
    <dsc>Sets the Check-state of the specified button.</dsc>
    <code>#bS[@1,@2]</code>
    <cmt>For ALL buttons:
  0 = Unchecked/Unselected/Unpushed

For RadioButtons and CheckBoxes:
  1 = Checked
  2 = Indeterminate

For Pushbuttons and Ownerdraw Buttons:
  1 = Pushed
</cmt>
  </macro>
  <macro>
    <name>Button.tip</name>
    <act>Y</act>
    <stx>@Button.tip(buttonHandle,Text)</stx>
    <dsc>Pop-up help for buttons if you move the mouse pointer over the button</dsc>
    <code>#bT[@1,@2]</code>
    <cmt>Creates a Tooltip with the specified text and associates it with the button.  The text must be &lt; 80 characters. </cmt>
  </macro>
  <macro>
    <name>Cache.interval</name>
    <act>Y</act>
    <stx>msec@Cache.interval</stx>
    <dsc>RAF cache interval</dsc>
    <code>@ZCS</code>
    <cmt>Interval (in milliseconds) for MagicCS to check if the RAF pointed to by pfx has changed. The default for the interval is 5000ms which should not need to be changed. </cmt>
  </macro>
  <macro>
    <name>Cache.off</name>
    <act>Y</act>
    <stx>^prefix@Cache.off</stx>
    <dsc>Turn client RAF caching off for prefix.</dsc>
    <code>@ZCN</code>
    <cmt/>
  </macro>
  <macro>
    <name>Cache.on</name>
    <act>Y</act>
    <stx>^prefix@Cache.on</stx>
    <dsc>Turn client RAF caching on for prefix.</dsc>
    <code>@ZCY</code>
    <cmt/>
  </macro>
  <macro>
    <name>Cache.timestamp</name>
    <act>Y</act>
    <stx>^prefix@Cache.timestamp</stx>
    <dsc>Returns information about for the RAF pointed to by [prefix]</dsc>
    <code>@ZCT</code>
    <cmt>Returns 4 bytes of time information and 4 bytes of counter information for the RAF pointed to by the specified prefix.  For use by server program only... not for general use.
</cmt>
  </macro>
  <macro>
    <name>Cal.banner</name>
    <act>Y</act>
    <stx>@Cal.banner(month,bannerAttr)</stx>
    <dsc>Display the specified [month] (0-12) banner in the specified attribute.</dsc>
    <code>#kM[@1,&quot;_IF{S[2];D(34,34)}_&quot;]</code>
    <cmt>[bannerAttr] is a byte string specifying the background color for the banner.  Numbers 0-15 are accepted and correspond to the 16 colors in the MEDITECH palette.</cmt>
  </macro>
  <macro>
    <name>Cal.disp.date</name>
    <act>Y</act>
    <stx>@Cal.disp.date(date,attr)</stx>
    <dsc>Display the [date] specified (YYYYMMDD) in the [attr] specified.</dsc>
    <code>#kD[@1,&quot;_IF{S[2];D(34,34)}_&quot;]</code>
    <cmt>Attr is a byte string specifying the color for the date.  Numbers 0-15 are accepted and correspond to the 16 colors in the MEDITECH palette.</cmt>
  </macro>
  <macro>
    <name>Cal.draw</name>
    <act>Y</act>
    <stx>@Cal.draw(row,col,height,startDate,dateDisplayString)^endDate</stx>
    <dsc>Draws a calendar on the current screen at [row] and [column].</dsc>
    <code>#kC[@1,@2,@3,@4,{D(21,1,21,1,21)},{&quot;_IF{S[5];D(34,34)}_&quot;}]</code>
    <cmt>[row],[col]         = position of the top left corner of the calendar
[height]            = the number of rows the calendar should take up
[startDate]         = starting date of the calendar in YYYYMMDD format
[dateDisplayString] = a string of bytes that defines how the dates should display.  If a nil                       list is passed in, all dates will appear in black.
                         0-15 defines the foreground color
                         16 innie
                         32 bold face
                         64 highlight bit (if on, all else is ignored and date is displayed                                              in white on a dark blue background.)
                        128 dotted box

In all the calendar functions, no calendar ID is specified, because there is exactly one calendar allowed on a given Page, so all functions apply to THE calendar.
</cmt>
  </macro>
  <macro>
    <name>Cal.erase</name>
    <act>Y</act>
    <stx/>
    <dsc>Deletes the calendar on the current page</dsc>
    <code>#kX</code>
    <cmt/>
  </macro>
  <macro>
    <name>Cal.redisplay</name>
    <act>Y</act>
    <stx>@Cal.redisplay(startDate,dateAttrs)^endDate</stx>
    <dsc>Redisplay the calendar starting on [startDate].</dsc>
    <code>#kR[@1,{D(21,1,21,1,21)},{&quot;_IF{S[2];D(34,34)}_&quot;}]</code>
    <cmt>[dateAttrs] = a string of bytes that defines how the dates should display.  If a nil                       list is passed in, all dates will appear in black.
                  0-15 defines the foreground color
                  16 innie
                  32 bold face
                  64 highlight bit (if on, all else is ignored and date is displayed in                                           white on a dark blue background.)
                 128 Dotted box
</cmt>
  </macro>
  <macro>
    <name>Call.windows</name>
    <act>Y</act>
    <stx>@Call.windows(pathCommandTail,windowShowCalledWin,windowShowCallingWin,modailty)</stx>
    <dsc>Launches another process running the specified Windows program.</dsc>
    <code>#C[@1,@2,@3,@4]</code>
    <cmt>[pathCommandTail]
The complete path to the specified program.  Include .EXE (or whatever extension) on the program name.  Anything after the initial &lt;SPACE&gt; will be passed to the new procedure as command-tail arguments.

[windowShow]
The value of this argument is passed directly to Windows as the the ShowWindow state.
   1=Normal
   2=Minimize
   3=Maximize
   4=Normal but not active
   5=(don&apos;t use)
   6=Minimize
   7=Minimize but do not activate
   8=Show but do not activate
   9=Restore

[modality]
   0=Asynchronous (the function returns immediately, with the new window either active or                       not, depending on the [windowShow] parameter; if the new window is                           Active, MagicCS will not actually run until MagicCS becomes the active                       window).

  &gt;0=Synchronous  (the function does not return until the user explicitly terminates the                        process created with this command, regardless of whether or not MagicCS                      becomes the active window)

Interprocess Communication (IPC) Functions:

These functions are to allow a VMagic process to start and send data to another process, VMagic or Magic Workstation. The communication is one way from the originator to the new process.

Once started the focus is transferred to the new process. The process ID listed below is any name of the user&apos;s choice. If a process is already &quot;register&quot;&apos;ed by this name the input is directed to that process. How to start a process running with IPC is described below.

The order of coding should be something like:

   1. Start the process via #C syntax.
   2. Issue the hang command on the originator.
   3. If the hang returns success, issue the password command.

How to launch a process for IPC:

there was a change made to the #C syntax to allow for IPC to work.

the new format is:
#C[&quot;path to .exe&quot;_D(254)_{process ID},ShowHim,ShowMe,WaitFlag]

Initialization of the VMagic/Workstation will recognize this flag and &quot;register&quot; by this name.
</cmt>
  </macro>
  <macro>
    <name>Change.wnd.title</name>
    <act>Y</act>
    <stx>@Change.wnd.title(title)</stx>
    <dsc>Change the title of the current open window.</dsc>
    <code>@1^#W</code>
    <cmt/>
  </macro>
  <macro>
    <name>Check.lines.left</name>
    <act>Y</act>
    <stx>@Check.lines.left(arg)</stx>
    <dsc>Code used to check the number of lines left in the current page of a report.</dsc>
    <code>IF{/R.LL&lt;@1 [/R.NEW.PAGE.PGM](0)},/R.LL-1^/R.LL</code>
    <cmt>Calls the program in /R.NEW.PAGE.PGM if the number of lines left is less than the value of [arg].  The number of lines left should be the value of /R.LL.</cmt>
  </macro>
  <macro>
    <name>Chg.prefix</name>
    <act>Y</act>
    <stx>@Chg.prefix(dpmName,prefix1,prefix2)</stx>
    <dsc>Change subsequent prefix1 references to prefix2 for DPM in xlated object code</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..chg.prefix(^S)_&quot;</code>
    <cmt>Causes subsequent references to any data element or structure in the DPM [dpmName] that uses prefix1 to be changed to prefix2.  Translation time only - no code produced.
</cmt>
  </macro>
  <macro>
    <name>Client.buffer.address</name>
    <act>Y</act>
    <stx/>
    <dsc>Server function only.</dsc>
    <code>@St</code>
    <cmt/>
  </macro>
  <macro>
    <name>Client.info</name>
    <act>Y</act>
    <stx/>
    <dsc>Server function only.</dsc>
    <code>@CI</code>
    <cmt/>
  </macro>
  <macro>
    <name>Client.sequence.number</name>
    <act>Y</act>
    <stx/>
    <dsc>Server function only.</dsc>
    <code>@GS</code>
    <cmt/>
  </macro>
  <macro>
    <name>Clipboard.get</name>
    <act>Y</act>
    <stx>@Clipboard.get(format,otherArgs)</stx>
    <dsc>Get information from the clipboard in the specified [format].</dsc>
    <code>#cG[@1,@2]</code>
    <cmt>[format]
  1 = TEXT  The additional argument is a MemoryID (#mA).
            The text will be put into the memory buffer, and the return value is the number              of characters copied.  The buffer will be expanded if necessary to fit the                   text.  Additional formats may be added in the future.
</cmt>
  </macro>
  <macro>
    <name>Clipboard.load</name>
    <act>Y</act>
    <stx>@Clipboard.load(memoryHandle)</stx>
    <dsc>Copies the contents of [memoryHandle] to the Windows clipboard.</dsc>
    <code>#cC[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Close.search.handle</name>
    <act>Y</act>
    <stx/>
    <dsc>After a @First.file/@Next.file loop, closes the handle.</dsc>
    <code>@ZFC</code>
    <cmt/>
  </macro>
  <macro>
    <name>Close.window.button</name>
    <act>Y</act>
    <stx>arg@Close.window.button</stx>
    <dsc>Configure the [x] box (close box) in the Windows Title Bar.</dsc>
    <code>@ZCW</code>
    <cmt>If arg = &quot;D&quot;, disable it.
If arg = &quot;E&quot;, enable it, but confirm that the user wishes to close if he/she clicks on it                    (error trap will be invoked if he/she confirms close).
If arg = &quot;X&quot;, close window without confirmation (and do not invoke error trap).

See also @Error.type.
</cmt>
  </macro>
  <macro>
    <name>Clr.buf</name>
    <act>Y</act>
    <stx>@Clr.buf(X[,@segment.name])</stx>
    <dsc>Clears the local buffer, optionally saving it to @segment.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.buf(^S)_&quot;</code>
    <cmt>If @segment.name specified, X^@segment.name.
In either case, &quot;&quot;^X

See @Est.buf or @Def.buf for more details.
</cmt>
  </macro>
  <macro>
    <name>Clr.t.rec</name>
    <act>Y</act>
    <stx>@Clr.t.rec(X[,@segment.name])</stx>
    <dsc>Clears a local record buffer and optionally saves the copy to [@segment.name].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.t.rec(^S)_&quot;</code>
    <cmt>If @segment.name is specified, G(..) function is used to copy from the buffer to [@segment.name].  In either case, the local buffer (./(.TX)) is closed.

Example:
  @Clr.t.rec(X,@MIS.USER.main)  ==&gt;  G(/(.TX)GU[gu],&amp;(G)GU[gu]),C(/(.TX)U)

Also see @Def.t.rec or @Est.t.rec for details.

</cmt>
  </macro>
  <macro>
    <name>Color.background</name>
    <act>Y</act>
    <stx>@Color.background(color)</stx>
    <dsc>Sets the background color of characters.</dsc>
    <code>D(25,1,@1)</code>
    <cmt>color=0-15 are standard windows colors.
color=255 means restore prior color. </cmt>
  </macro>
  <macro>
    <name>Color.foreground</name>
    <act>Y</act>
    <stx>@Color.foreground(color)</stx>
    <dsc>Sets the foreground color of characters.</dsc>
    <code>D(25,0,@1)</code>
    <cmt>color=0-15 are standard windows colors.
color=255 means restore prior color. </cmt>
  </macro>
  <macro>
    <name>Color.use</name>
    <act>Y</act>
    <stx>@Color.use(color)</stx>
    <dsc>The sets the current colors (background and foreground) based on usage.</dsc>
    <code>D(1,@1)</code>
    <cmt>The following macros should be used:

  @Z.color.labels - window &quot;interior&quot; including any text = 1
  @Z.color.data - data entry fields = 2
  @Z.color.alt.labels - same background color as with @Z.color.labels, but a different                                 foreground color = 3
  @Z.color.panels - special purposes area or panels = 15
  @Z.color.highlights - highlight colors for current color use = 255
</cmt>
  </macro>
  <macro>
    <name>Column</name>
    <act>Y</act>
    <stx>@Column(element,screen)</stx>
    <dsc>Returns the column of [element] in the specified [screen].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..screen(^S)_&quot;</code>
    <cmt>Returns the column of [element] in the specified [screen].  Specify &quot;*&quot; for [screen] for screen associated with the current procedure. </cmt>
  </macro>
  <macro>
    <name>Combo.add.item</name>
    <act>Y</act>
    <stx>@Combo.add.item(handle,string)</stx>
    <dsc>Adds [string] to the bottom of the drop-down list specified by [handle]</dsc>
    <code>#CA[@1,@2]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Combo.buffer</name>
    <act>Y</act>
    <stx>@Combo.buffer(handle,Function,MemoryID)</stx>
    <dsc>Buffer the combobox</dsc>
    <code>#CB[@1,@2,@3]</code>
    <cmt>The buffer contains &lt;CRLF&gt; delimited strings.

Functions:
  0 means Retreive all items into the buffer.
     returns number of items retreived.
  1 means Add all items to the combo.
     returns index of last item added.  Items are added to the end, no items are deleted.
</cmt>
  </macro>
  <macro>
    <name>Combo.create</name>
    <act>Y</act>
    <stx>@Combo.create(row,column,height,width,type)</stx>
    <dsc>Create a combobox at [row],[column].  Returns a handle.</dsc>
    <code>#CC[@1,@2,@3,@4,&quot;_IF{S[5];3}_&quot;]</code>
    <cmt>The parameters refer to character rows and columns, not pixels.  The control displayed will be one row high and [width] columns wide.  The [height] parameter specifies how many rows the drop-down list may occupy.  To allow for the &quot;drop-down&quot; button on the right,  applications should specify a Width 4 columns larger than the length of the longest item they wish to display.

The optional fifth argument is for Type.  There are 3 to choose from:
 1 - The edit field may be typed into and the drop-down list is always displayed
 2 - The edit field may be typed into but the drop-down list is only displayed when the user      clicks the arrow.
 3 - (default) The edit field may not be typed into and the drop-down list is only displayed      when the user clicks the arrow.
</cmt>
  </macro>
  <macro>
    <name>Combo.delete</name>
    <act>Y</act>
    <stx>@Combo.delete(handle)</stx>
    <dsc>Delete the combobox specified by [handle]</dsc>
    <code>#CX[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Combo.focus</name>
    <act>Y</act>
    <stx>@Combo.focus(handle,DropDown)</stx>
    <dsc>&quot;Go hung&quot; for the control.</dsc>
    <code>#CF[@1&quot;_IF{S[2] &quot;,&quot;_S[2]}_&quot;]</code>
    <cmt>The read is terminated by clicking on some other clickable object (button, scrollbar, etc) or by the following keys:
          &lt;Return&gt;, &lt;Escape&gt;, &lt;F1&gt; - &lt;F12&gt;
          &lt;Insert&gt;, &lt;Delete&gt;, &lt;Home&gt;, &lt;End&gt;, &lt;PageUp&gt;, &lt;PageDown&gt;

The read is NOT terminated by the arrow keys, which have meaning within the combobox itself. To support the mouse/combobox interface, if a read is terminated by clicking on a combobox, #L returns {&quot;C&quot;,Handle,SelectedIndex,&quot;L&quot;,&quot;S&quot;}.

handle = handle to Combo Box
DropDown = 0 - places the focus without opening the drop-down.
           1 - places the focus and opens the drop-down.</cmt>
  </macro>
  <macro>
    <name>Combo.get.selection</name>
    <act>Y</act>
    <stx>@Combo.get.selection(handle)</stx>
    <dsc>Returns the index of the current item in [handle] if one is selected, or NIL.</dsc>
    <code>#CG[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Combo.index</name>
    <act>Y</act>
    <stx>@Combo.index(handle,Index,String)</stx>
    <dsc>Insert the String at Index</dsc>
    <code>#CI[@1,@2,@3]</code>
    <cmt>Insert the String at Index for the combobox identified by handle.
</cmt>
  </macro>
  <macro>
    <name>Combo.limit.input</name>
    <act>Y</act>
    <stx>@Combo.limit.input(handle,length)</stx>
    <dsc>Limit input length of the combo input field</dsc>
    <code>#CL[@1,@2]</code>
    <cmt>this function will limit the amount of text that a user can type into the edit field of a combobox.  This does not affect the length of text in the drop-down list.</cmt>
  </macro>
  <macro>
    <name>Combo.reset</name>
    <act>Y</act>
    <stx>@Combo.reset(handle)</stx>
    <dsc>Remove all entries from the drop-down list specified by [handle].</dsc>
    <code>#CR[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Combo.select.item</name>
    <act>Y</act>
    <stx>@Combo.select.item(handle,n)</stx>
    <dsc>Select an item from the drop-down list specified by [handle].</dsc>
    <code>#CS[@1,@2]</code>
    <cmt>n may have one of the following types:

-1     means select nothing (clear the box)
number means select by index
string means select by (exact) string match</cmt>
  </macro>
  <macro>
    <name>Combo.set.edit.field</name>
    <act>Y</act>
    <stx>@Combo.set.edit.field(handle,string)</stx>
    <dsc>Sets the Edit field of the combobox to String</dsc>
    <code>#CE[@1,@2]</code>
    <cmt>Sets the Edit field of the ComboBox to String.

In the case of Type 3 ComboBoxes, where the Edit field can only reflect a selection from the list, this function is a noop.

Returns 1 on success, else NIL.</cmt>
  </macro>
  <macro>
    <name>Command.line</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the command line used to start MagicCS session.</dsc>
    <code>@CL</code>
    <cmt>Returns the command line used to initiate the MagicCS session, including any arguments.</cmt>
  </macro>
  <macro>
    <name>Command.path</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the path to the MagicCS .exe file.</dsc>
    <code>@CM</code>
    <cmt/>
  </macro>
  <macro>
    <name>Cond.clr.t.rec</name>
    <act>Y</act>
    <stx>@Cond.clr.t.rec(X,@segment.name)</stx>
    <dsc>Clear the map from a segment to temp prefix, and conditionally write data back</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.t.rec(^S)_&quot;</code>
    <cmt>Clear the map from a segment to a temp prefix, and conditionally copy data in @segment.name to the temp if there is no data for that segment in the temp yet.

Example:  @Cond.clr.t.rec(X,@MIS.USER.main)

      IF{zrecbuf[&quot;&amp;(G)GU[gu&quot;] G(/(.TX)GU[gu],&amp;(G)GU[gu]),C(/(.TX)U),&quot;&quot;^zrecbuf[&quot;&amp;(G)GU[gu&quot;]}

See also @Clr.t.rec

NOTE:  @Cond.clr.t.rec should always be used together with @Cond.est.t.rec in the same program to guarantee desired results from the translator.


 </cmt>
  </macro>
  <macro>
    <name>Cond.est.t.rec</name>
    <act>Y</act>
    <stx>@Cond.est.t.rec(X,@segment.name)</stx>
    <dsc>Set up the map from a segment to a temp prefix, and conditionally buffer data</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.t.rec(^S)_&quot;</code>
    <cmt>Set up the map from a segment to a temp prefix, and conditionally copy data in [@segment.name] to the temp if there is no data for that segment in the temp yet.

Example:  @Cond.est.t.rec(X,@MIS.USER.main)

          IF{/(.TX)GU[gu];
             &gt;/(.TX)GU[gu,&quot;&quot;];
             O(/(.TX)S,&quot;P&quot;),M(&amp;(G)GU[gu],/(.TX)GU[gu]),
             1^zrecbuf[&quot;&amp;(G)GU[gu&quot;]}

See also @Est.t.rec.

NOTE:  @Cond.clr.t.rec should always be used together with @Cond.clr.t.rec in the same program to guarantee desired results from the translator.

</cmt>
  </macro>
  <macro>
    <name>Cond.t.rec</name>
    <act>Y</act>
    <stx>@Cond.t.rec(X)</stx>
    <dsc>Returns true if conditional temp record was established.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.t.rec(^S)_&quot;</code>
    <cmt>Where X has been used to buffer @MIS.USER.main:

Source: @Cond.t.rec(X)            Object: zrecbuf[&quot;&amp;(G)GU[gu&quot;]

This will return true if a @Cond.est.t.rec has been set for X.</cmt>
  </macro>
  <macro>
    <name>Counter.dec</name>
    <act>Y</act>
    <stx>@Counter.dec(c)</stx>
    <dsc>Global counting function -- Decrement counter [c].</dsc>
    <code>@Cd</code>
    <cmt>Legal values of c range from 0 thru 2047 inclusive.  Modifying counters 0-1023 at the application level is prohibited, as these are reserved for system-level counters.

All instances of VMagic running on a computer share the same counters!  Only when all VMagic instances have exited are counters re-initialized.
</cmt>
  </macro>
  <macro>
    <name>Counter.inc</name>
    <act>Y</act>
    <stx>@Counter.inc(c)</stx>
    <dsc>Global counting function -- Increment counter [c].</dsc>
    <code>@Ci</code>
    <cmt>Legal values of c range from 0 thru 2047 inclusive.  Modifying counters 0-1023 at the application level is prohibited, as these are reserved for system-level counters.

All instances of VMagic running on a computer share the same counters!  Only when all VMagic instances have exited are counters re-initialized.
</cmt>
  </macro>
  <macro>
    <name>Counter.read</name>
    <act>Y</act>
    <stx>@Counter.read(c)</stx>
    <dsc>Global counting function -- Read counter [c].</dsc>
    <code>@Cr</code>
    <cmt>Legal values of c range from 0 thru 2047 inclusive.  Modifying counters 0-1023 at the application level is prohibited, as these are reserved for system-level counters.

All instances of VMagic running on a computer share the same counters!  Only when all VMagic instances have exited are counters re-initialized.
</cmt>
  </macro>
  <macro>
    <name>Counter.write</name>
    <act>Y</act>
    <stx>val@Counter.write(c)</stx>
    <dsc>Global counting function -- Write [val] to counter [c].</dsc>
    <code>@Cw</code>
    <cmt>Legal values of c range from 0 thru 2047 inclusive.  Modifying counters 0-1023 at the application level is prohibited, as these are reserved for system-level counters.

All instances of VMagic running on a computer share the same counters!  Only when all VMagic instances have exited are counters re-initialized.
</cmt>
  </macro>
  <macro>
    <name>Create.process</name>
    <act>Y</act>
    <stx>commandLine@Create.process</stx>
    <dsc>Starts the process indicated in [commandLine].</dsc>
    <code>@CP</code>
    <cmt>Returns: nil if unsuccessful; non-nil otherwise.</cmt>
  </macro>
  <macro>
    <name>Create.process.extra</name>
    <act>N</act>
    <stx>path@Create.process.extra</stx>
    <dsc>Create process with more handles returned</dsc>
    <code>@CS</code>
    <cmt>Returns:

{Process handle,Thread handle, Process id}
</cmt>
  </macro>
  <macro>
    <name>Create.process.suspended</name>
    <act>Y</act>
    <stx>path@Create.process.suspended</stx>
    <dsc>Creates a process that starts suspended.</dsc>
    <code>@CS</code>
    <cmt>Returns:

{Process handle,Thread handle, Process id}

Must use Threadhandle@Thread.resume to get process to launch.
 </cmt>
  </macro>
  <macro>
    <name>Create.process.wait</name>
    <act>Y</act>
    <stx>commandLine@Create.process.wait</stx>
    <dsc>Starts the process indicated in [commandLine] and waits until process finishes</dsc>
    <code>@Cp</code>
    <cmt>Similar to @Create.process except that it waits for the child process to finish.</cmt>
  </macro>
  <macro>
    <name>Credentials.authenticate.ml</name>
    <act>Y</act>
    <stx>@Credentials.authenticate.ml(networkSocketHandle)</stx>
    <dsc>Authenticate credentials against a TCPproxy service using an open connection</dsc>
    <code>%(Z)tcpproxy.auth(&quot;_D(34)_&quot;A&quot;_D(34)_&quot;,&quot;_D(34,34)_&quot;,@1)</code>
    <cmt>The Z utility is written to handle both 2-Tier and 3-Tier environments.
Returns 1 if the credentials associated to this session were deemed valid, a 0 otherwise.
Note: This utility is expecting that the executing routine has already opened up to the TCPproxy service and the network socket handle to pass to @Net.to must be supplied in networkSocketHandle argument.
</cmt>
  </macro>
  <macro>
    <name>Credentials.authenticate.ml.tcp</name>
    <act>Y</act>
    <stx/>
    <dsc>Authenticate credentials against the TCPproxy service, open/close the connection</dsc>
    <code>%(Z)tcpproxy.auth(&quot;_D(34)_&quot;A&quot;_D(34)_&quot;,&quot;_D(34)_&quot;O&quot;_D(34)_&quot;)</code>
    <cmt>The Z utility is written to handle both 2-Tier and 3-Tier environments.
Returns 1 if the credentials associated to this session were deemed valid, a 0 otherwise.
Note: This utility will open and close a connection to the TCPproxy service defined in the MIS HUB parameters (@MIS.PARAM.hub.server.name and @MIS.PARAM.hub.ssl.port.enc.on).
</cmt>
  </macro>
  <macro>
    <name>Credentials.challenge</name>
    <act>Y</act>
    <stx/>
    <dsc>Challenges the current user credentials using the CS File Server.</dsc>
    <code>@UC</code>
    <cmt>Returns 1 if the credentials associated to this session were deemed valid.
</cmt>
  </macro>
  <macro>
    <name>Credentials.challenge.ml</name>
    <act>Y</act>
    <stx>@Credentials.challenge.ml(networkSocketHandle)</stx>
    <dsc>Challenges credentials against a TCPproxy service using an open connection</dsc>
    <code>%(Z)tcpproxy.auth(&quot;_D(34)_&quot;C&quot;_D(34)_&quot;,&quot;_D(34,34)_&quot;,@1)</code>
    <cmt>The Z utility is written to handle both 2-Tier and 3-Tier environments.
Returns 1 if the credentials associated to this session were deemed valid, a 0 otherwise.
Note: This utility is expecting that the executing routine has already opened up to the TCPproxy service and the network socket handle to pass to @Net.to must be supplied in networkSocketHandle argument.
</cmt>
  </macro>
  <macro>
    <name>Credentials.challenge.ml.tcp</name>
    <act>Y</act>
    <stx/>
    <dsc>Challenges credentials against the TCPproxy service, open/close the connection</dsc>
    <code>%(Z)tcpproxy.auth(&quot;_D(34)_&quot;C&quot;_D(34)_&quot;,&quot;_D(34)_&quot;O&quot;_D(34)_&quot;)</code>
    <cmt>The Z utility is written to handle both 2-Tier and 3-Tier environments.
Returns 1 if the credentials associated to this session were deemed valid, a 0 otherwise.
Note: This utility will open and close a connection to the TCPproxy service defined in the MIS HUB parameters (@MIS.PARAM.hub.server.name and @MIS.PARAM.hub.ssl.port.enc.on).
</cmt>
  </macro>
  <macro>
    <name>Credentials.get.last.error</name>
    <act>Y</act>
    <stx/>
    <dsc>Retrieve the last error encountered when executing an MSOclient.dll function</dsc>
    <code>@UX</code>
    <cmt>If called after one of the other MSOclient.dll credential authentication/checking functions (@UA/@UB/@UC/@UD/@UF/@UH) has indicated a failure (return value = 0), this function will indicate the cause of the error in a {error code|error string} format.
</cmt>
  </macro>
  <macro>
    <name>Credentials.unload.dll.ml</name>
    <act>Y</act>
    <stx/>
    <dsc>Unloads the MSOclient.dll</dsc>
    <code>@UU</code>
    <cmt>This function must be executed if a credentials Authentication/Challenge has failed.
</cmt>
  </macro>
  <macro>
    <name>Critical.write.off</name>
    <act>Y</act>
    <stx>@Critical.write.off(&quot;&quot;)</stx>
    <dsc>Turns critical write mode off for all DATA type files for current application</dsc>
    <code>%(Z)critical.write(&quot;_D(34,34)_&quot;)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Critical.write.on</name>
    <act>Y</act>
    <stx>@Critical.write.on(&quot;&quot;)</stx>
    <dsc>Turns critical write mode on for all DATA type files for current application.</dsc>
    <code>%(Z)critical.write(&quot;_IF{S[1]&apos;=D(34,34);1}_&quot;)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Current.directory</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the directory where the MagicCS .exe for the current session is located.</dsc>
    <code>@CD</code>
    <cmt/>
  </macro>
  <macro>
    <name>Debug.accept</name>
    <act>Y</act>
    <stx/>
    <dsc>Accepts a Debug socket connection.</dsc>
    <code>@ZDC</code>
    <cmt>Used in the thread code.  Creates a &quot;lite&quot; TCP socket.  @Net.xxx  functions used to communicate.</cmt>
  </macro>
  <macro>
    <name>Debug.event.wait</name>
    <act>Y</act>
    <stx/>
    <dsc>Causes Debug thread to wait for user to click on &quot;allow Debug&quot; on control menu</dsc>
    <code>@ZDW</code>
    <cmt>Used in the debug thread.</cmt>
  </macro>
  <macro>
    <name>Debug.flags</name>
    <act>Y</act>
    <stx>integer@Debug.flags</stx>
    <dsc>Set flags for the debugger.</dsc>
    <code>@YX</code>
    <cmt>Bits in debug flags bitmask:

  1 - enter DDT on ERR for type 0 threads
  2 - enter DDT on DIAG for type 0 threads
  4 - enter DDT on ERR for type 3 threads
  8 - enter DDT on DIAG for type 3 threads
 16 - enable event logging of MAGIC errors
 32 - enable event logging of info events
 64 - handle exceptions as MAGIC errors for type 0 threads
128 - handle exceptions as MAGIC errors for type 3 threads

Thread types:
  0 - interpretation or GUI
  1 - bkg buffer writer
  2 - not used
  3 - XO (&quot;worker&quot; threads)
</cmt>
  </macro>
  <macro>
    <name>Debug.init.event</name>
    <act>Y</act>
    <stx/>
    <dsc>Initializes Debug event</dsc>
    <code>@ZDE</code>
    <cmt>Used to setup debug thread.
</cmt>
  </macro>
  <macro>
    <name>Debug.init.menu</name>
    <act>Y</act>
    <stx/>
    <dsc>Adds &quot;Allow Debug&quot; to control menu.</dsc>
    <code>@ZDM</code>
    <cmt>Used to setup Debug Thread.
</cmt>
  </macro>
  <macro>
    <name>Debug.init.tcp.socket</name>
    <act>Y</act>
    <stx/>
    <dsc>Gets a tcp socket and returns the port number</dsc>
    <code>@ZDS</code>
    <cmt>Used in the debug thread.</cmt>
  </macro>
  <macro>
    <name>Debug.line</name>
    <act>Y</act>
    <stx>^symbol.table@Debug.line</stx>
    <dsc>Returns: {first.line.of.pgm,chars.before.error,chars.after.error}</dsc>
    <code>@ZEL</code>
    <cmt/>
  </macro>
  <macro>
    <name>Debug.listen</name>
    <act>Y</act>
    <stx/>
    <dsc>Listens for a socket connection</dsc>
    <code>@ZDL</code>
    <cmt>Used in the debug thread.</cmt>
  </macro>
  <macro>
    <name>Debug.prog</name>
    <act>Y</act>
    <stx>program@Debug.prog</stx>
    <dsc>Sets the debug program.</dsc>
    <code>@ZDB</code>
    <cmt>Unlike X(), symbol table is preserved with a debug program. </cmt>
  </macro>
  <macro>
    <name>Debug.reg</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns register information for an error.</dsc>
    <code>@ZER</code>
    <cmt/>
  </macro>
  <macro>
    <name>Debug.spy.menu</name>
    <act>Y</act>
    <stx/>
    <dsc>Enables the spy menu.</dsc>
    <code>@ZSM</code>
    <cmt/>
  </macro>
  <macro>
    <name>Def.buf</name>
    <act>Y</act>
    <stx>@Def.buf(X,@segment.name)</stx>
    <dsc>Same as @Est.buf except that assignment operation (@segment.name^X) is not done</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.buf(^S)_&quot;</code>
    <cmt>This is useful in conjunction with the @Next.get or @Prev.get macros which do the assignment themselves.  @Def.buf simply tells the translator that all future references to the fields on the segment should use X.</cmt>
  </macro>
  <macro>
    <name>Def.t.rec</name>
    <act>Y</act>
    <stx>@Def.t.rec(X,@segment.name)</stx>
    <dsc>Tells translator that future refs to fields in this segment should use buffer</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.t.rec(^S)_&quot;</code>
    <cmt>Tells the translator that all future references to fields in this segment should use the buffer until it is cleared by a @Clr.t.rec.  See @Est.t.rec.

Like @Def.buf, but for a whole segment and its children.
</cmt>
  </macro>
  <macro>
    <name>Default.windows.printer</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the default Windows printer for this client.</dsc>
    <code>#PD</code>
    <cmt>Returns informations as a queue:  {printerName,printerPort}

Example: {&quot;LURLEEN&quot;,&quot;\\NUMBERS\LURLEEN&quot;}
</cmt>
  </macro>
  <macro>
    <name>Define.region</name>
    <act>Y</act>
    <stx>@Define.region(row,column,height,width)</stx>
    <dsc>Defines a region for drawing pictures, etc.</dsc>
    <code>D(6,0,@1,@2,@3,@4)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Digital.sig.alloc</name>
    <act>Y</act>
    <stx>@Digital.sig.alloc^Result</stx>
    <dsc>Allocate an initial 4Kb buffer.</dsc>
    <code>@Wa</code>
    <cmt>Result
   Returns initial buffer size on success.  Nil indicates failure.
</cmt>
  </macro>
  <macro>
    <name>Digital.sig.cert.name</name>
    <act>Y</act>
    <stx>Name@Digital.sig.cert.name^Result</stx>
    <dsc>Set or get certificate name.</dsc>
    <code>@Wn</code>
    <cmt>Name (optional)
   The name of the certificate to be used for encryption.  Nil returns current setting.

Result
   Name of certificate or nil if not set.</cmt>
  </macro>
  <macro>
    <name>Digital.sig.cert.store</name>
    <act>Y</act>
    <stx>Name@Digital.sig.cert.store^Result</stx>
    <dsc>Set or get certificate store.</dsc>
    <code>@Wc</code>
    <cmt>Name (optional)
   The name of the certificate storage location.  (ie &quot;MY&quot;)  Nil returns current setting.

Result
   Name of certificate storage location or nil of not set.</cmt>
  </macro>
  <macro>
    <name>Digital.sig.decrypt</name>
    <act>Y</act>
    <stx>Options@Digital.sig.decrypt^Result</stx>
    <dsc>Verifies message in buffer.</dsc>
    <code>@Wv</code>
    <cmt>Options
   0x10000000 CERT_CHAIN_REVOCATION_CHECK_END_CERT
                Revocation checking is done on the end certificate and only the end
                certificate.
   0x20000000 CERT_CHAIN_REVOCATION_CHECK_CHAIN
                Revocation checking is done on all of the certificates in every chain.
   0x40000000 CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT
                Revocation checking is done on all certificates in all of the chains except
                the root certificate.
   0x80000000 CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY
                Revocation checking only accesses cached URLs.

Result
   Returns message size if successful or nil upon failure.
</cmt>
  </macro>
  <macro>
    <name>Digital.sig.encrypt</name>
    <act>Y</act>
    <stx>Options@Digital.sig.encrypt^Result</stx>
    <dsc>Signs message in buffer.</dsc>
    <code>@Ws</code>
    <cmt>Options
   0x00000001 Detach message.
   0x00000002 Add signing time attribute.

Result
   Returns message size if successful or an error code &gt; 2147483648 upon failure.

   Error codes:
   2147483649 - could not open cert store, more info from Digital.sig.status.
   2147483650 - could not get certificate, more info from Digital.sig.status.
   2147483651 - problem signing message, more info from Digital.sig.status.
   2147483652 - problem signing message, more info from Digital.sig.status.
   2147483653 - problem signing message, more info from Digital.sig.status.
   2147483654 - problem signing message, more info from Digital.sig.status.</cmt>
  </macro>
  <macro>
    <name>Digital.sig.free</name>
    <act>Y</act>
    <stx>@Digital.sig.free^Result</stx>
    <dsc>Free buffer.</dsc>
    <code>@Wx</code>
    <cmt>Result
   Returns final buffer size if successful, nil upon failure.
</cmt>
  </macro>
  <macro>
    <name>Digital.sig.hash</name>
    <act>Y</act>
    <stx>Hash@Digital.sig.hash^Result</stx>
    <dsc>Set or get Hash OID.</dsc>
    <code>@Wo</code>
    <cmt>Hash
   The OID of the Hash code to be used for encrypting.

   Description                          OID
   szOID_RSA                            &quot;1.2.840.113549&quot;
   szOID_PKCS                           &quot;1.2.840.113549.1&quot;
   szOID_RSA_HASH                       &quot;1.2.840.113549.2&quot;
   szOID_RSA_ENCRYPT                    &quot;1.2.840.113549.3&quot;
   szOID_PKCS_1                         &quot;1.2.840.113549.1.1&quot;
   szOID_PKCS_2                         &quot;1.2.840.113549.1.2&quot;
   szOID_PKCS_3                         &quot;1.2.840.113549.1.3&quot;
   szOID_PKCS_4                         &quot;1.2.840.113549.1.4&quot;
   szOID_PKCS_5                         &quot;1.2.840.113549.1.5&quot;
   szOID_PKCS_6                         &quot;1.2.840.113549.1.6&quot;
   szOID_PKCS_7                         &quot;1.2.840.113549.1.7&quot;
   szOID_PKCS_8                         &quot;1.2.840.113549.1.8&quot;
   szOID_PKCS_9                         &quot;1.2.840.113549.1.9&quot;
   szOID_PKCS_10                        &quot;1.2.840.113549.1.10&quot;
   szOID_PKCS_12                        &quot;1.2.840.113549.1.12&quot;
   szOID_RSA_MD2                        &quot;1.2.840.113549.1.1.2&quot;
   szOID_RSA_MD4                        &quot;1.2.840.113549.1.1.3&quot;
   szOID_RSA_MD5                        &quot;1.2.840.113549.2.5&quot;
   szOID_RSA_RSA                        &quot;1.2.840.113549.1.1.1&quot;
   szOID_RSA_MD2RSA                     &quot;1.2.840.113549.1.1.2&quot;
   szOID_RSA_MD4RSA                     &quot;1.2.840.113549.1.1.3&quot;
   szOID_RSA_MD5RSA                     &quot;1.2.840.113549.1.1.4&quot;
   szOID_RSA_SHA1RSA                    &quot;1.2.840.113549.1.1.5&quot;
   szOID_RSA_SETOAEP_RSA                &quot;1.2.840.113549.1.1.5&quot;
   szOID_RSA_DH                         &quot;1.2.840.113549.1.3.1&quot;
   szOID_RSA_data                       &quot;1.2.840.113549.1.7.1&quot;
   szOID_RSA_signedData                 &quot;1.2.840.113549.1.7.2&quot;
   szOID_RSA_envelopedData              &quot;1.2.840.113549.1.7.3&quot;
   szOID_RSA_signEnvData                &quot;1.2.840.113549.1.7.4&quot;
   szOID_RSA_digestedData               &quot;1.2.840.113549.1.7.5&quot;
   szOID_RSA_hashedData                 &quot;1.2.840.113549.1.7.5&quot;
   szOID_RSA_encryptedData              &quot;1.2.840.113549.1.7.6&quot;
   szOID_RSA_emailAddr                  &quot;1.2.840.113549.1.9.1&quot;
   szOID_RSA_unstructName               &quot;1.2.840.113549.1.9.2&quot;
   szOID_RSA_contentType                &quot;1.2.840.113549.1.9.3&quot;
   szOID_RSA_messageDigest              &quot;1.2.840.113549.1.9.4&quot;
   szOID_RSA_signingTime                &quot;1.2.840.113549.1.9.5&quot;
   szOID_RSA_counterSign                &quot;1.2.840.113549.1.9.6&quot;
   szOID_RSA_challengePwd               &quot;1.2.840.113549.1.9.7&quot;
   szOID_RSA_unstructAddr               &quot;1.2.840.113549.1.9.8&quot;
   szOID_RSA_extCertAttrs               &quot;1.2.840.113549.1.9.9&quot;
   szOID_RSA_SMIMECapabilities          &quot;1.2.840.113549.1.9.15&quot;
   szOID_RSA_preferSignedData           &quot;1.2.840.113549.1.9.15.1&quot;
   szOID_RSA_RC2CBC                     &quot;1.2.840.113549.3.2&quot;
   szOID_RSA_RC4                        &quot;1.2.840.113549.3.4&quot;
   szOID_RSA_DES_EDE3_CBC               &quot;1.2.840.113549.3.7&quot;
   szOID_RSA_RC5_CBCPad                 &quot;1.2.840.113549.3.9&quot;
   szOID_ANSI_x942                      &quot;1.2.840.10046&quot;
   szOID_ANSI_x942_DH                   &quot;1.2.840.10046.2.1&quot;
   szOID_X957                           &quot;1.2.840.10040&quot;
   szOID_X957_DSA                       &quot;1.2.840.10040.4.1&quot;
   szOID_DATA STRUCTURE                 &quot;1.2.840.10040.4.3&quot;
   szOID_DS                             &quot;2.5&quot;
   szOID_DSALG                          &quot;2.5.8&quot;
   szOID_DSALG_CRPT                     &quot;2.5.8.1&quot;
   szOID_DSALG_HASH                     &quot;2.5.8.2&quot;
   szOID_DSALG_SIGN                     &quot;2.5.8.3&quot;
   szOID_DSALG_RSA                      &quot;2.5.8.1.1&quot;
   szOID_OIW                            &quot;1.3.14&quot;
   szOID_OIWSEC                         &quot;1.3.14.3.2&quot;
   szOID_OIWSEC_md4RSA                  &quot;1.3.14.3.2.2&quot;
   szOID_OIWSEC_md5RSA                  &quot;1.3.14.3.2.3&quot;
   szOID_OIWSEC_md4RSA2                 &quot;1.3.14.3.2.4&quot;
   szOID_OIWSEC_desECB                  &quot;1.3.14.3.2.6&quot;
   szOID_OIWSEC_desCBC                  &quot;1.3.14.3.2.7&quot;
   szOID_OIWSEC_desOFB                  &quot;1.3.14.3.2.8&quot;
   szOID_OIWSEC_desCFB                  &quot;1.3.14.3.2.9&quot;
   szOID_OIWSEC_desMAC                  &quot;1.3.14.3.2.10&quot;
   szOID_OIWSEC_rsaSign                 &quot;1.3.14.3.2.11&quot;
   szOID_OIWSEC_dsa                     &quot;1.3.14.3.2.12&quot;
   szOID_OIWSEC_shaDSA                  &quot;1.3.14.3.2.13&quot;
   szOID_OIWSEC_mdc2RSA                 &quot;1.3.14.3.2.14&quot;
   szOID_OIWSEC_shaRSA                  &quot;1.3.14.3.2.15&quot;
   szOID_OIWSEC_dhCommMod               &quot;1.3.14.3.2.16&quot;
   szOID_OIWSEC_desEDE                  &quot;1.3.14.3.2.17&quot;
   szOID_OIWSEC_sha                     &quot;1.3.14.3.2.18&quot;
   szOID_OIWSEC_mdc2                    &quot;1.3.14.3.2.19&quot;
   szOID_OIWSEC_dsaComm                 &quot;1.3.14.3.2.20&quot;
   szOID_OIWSEC_dsaCommSHA              &quot;1.3.14.3.2.21&quot;
   szOID_OIWSEC_rsaXchg                 &quot;1.3.14.3.2.22&quot;
   szOID_OIWSEC_keyHashSeal             &quot;1.3.14.3.2.23&quot;
   szOID_OIWSEC_md2RSASign              &quot;1.3.14.3.2.24&quot;
   szOID_OIWSEC_md5RSASign              &quot;1.3.14.3.2.25&quot;
   szOID_OIWSEC_sha1                    &quot;1.3.14.3.2.26&quot;
   szOID_OIWSEC_dsaSHA1                 &quot;1.3.14.3.2.27&quot;
   szOID_OIWSEC_dsaCommSHA1             &quot;1.3.14.3.2.28&quot;
   szOID_OIWSEC_sha1RSASign             &quot;1.3.14.3.2.29&quot;
   szOID_OIWDIR                         &quot;1.3.14.7.2&quot;
   szOID_OIWDIR_CRPT                    &quot;1.3.14.7.2.1&quot;
   szOID_OIWDIR_HASH                    &quot;1.3.14.7.2.2&quot;
   szOID_OIWDIR_SIGN                    &quot;1.3.14.7.2.3&quot;
   szOID_OIWDIR_md2                     &quot;1.3.14.7.2.2.1&quot;
   szOID_OIWDIR_md2RSA                  &quot;1.3.14.7.2.3.1&quot;
   szOID_INFOSEC                        &quot;2.16.840.1.101.2.1&quot;
   szOID_INFOSEC_sdnsSignature          &quot;2.16.840.1.101.2.1.1.1&quot;
   szOID_INFOSEC_mosaicSignature        &quot;2.16.840.1.101.2.1.1.2&quot;
   szOID_INFOSEC_sdnsConfidentiality    &quot;2.16.840.1.101.2.1.1.3&quot;
   szOID_INFOSEC_mosaicConfidentiality  &quot;2.16.840.1.101.2.1.1.4&quot;
   szOID_INFOSEC_sdnsIntegrity          &quot;2.16.840.1.101.2.1.1.5&quot;
   szOID_INFOSEC_mosaicIntegrity        &quot;2.16.840.1.101.2.1.1.6&quot;
   szOID_INFOSEC_sdnsTokenProtection    &quot;2.16.840.1.101.2.1.1.7&quot;
   szOID_INFOSEC_mosaicTokenProtection  &quot;2.16.840.1.101.2.1.1.8&quot;
   szOID_INFOSEC_sdnsKeyManagement      &quot;2.16.840.1.101.2.1.1.9&quot;
   szOID_INFOSEC_mosaicKeyManagement    &quot;2.16.840.1.101.2.1.1.10&quot;
   szOID_INFOSEC_sdnsKMandSig           &quot;2.16.840.1.101.2.1.1.11&quot;
   szOID_INFOSEC_mosaicKMandSig         &quot;2.16.840.1.101.2.1.1.12&quot;
   szOID_INFOSEC_SuiteASignature        &quot;2.16.840.1.101.2.1.1.13&quot;
   szOID_INFOSEC_SuiteAConfidentiality  &quot;2.16.840.1.101.2.1.1.14&quot;
   szOID_INFOSEC_SuiteAIntegrity        &quot;2.16.840.1.101.2.1.1.15&quot;
   szOID_INFOSEC_SuiteATokenProtection  &quot;2.16.840.1.101.2.1.1.16&quot;
   szOID_INFOSEC_SuiteAKeyManagement    &quot;2.16.840.1.101.2.1.1.17&quot;
   szOID_INFOSEC_SuiteAKMandSig         &quot;2.16.840.1.101.2.1.1.18&quot;
   szOID_INFOSEC_mosaicUpdatedSig       &quot;2.16.840.1.101.2.1.1.19&quot;
   szOID_INFOSEC_mosaicKMandUpdSig      &quot;2.16.840.1.101.2.1.1.20&quot;
   szOID_INFOSEC_mosaicUpdatedInteg     &quot;2.16.840.1.101.2.1.1.21&quot;
   szOID_PKIX_NO_SIGNATURE              &quot;1.3.6.1.5.5.7.6.2&quot;
   szOID_RSA_SSA_PSS                    &quot;1.2.840.113549.1.1.10&quot;
   szOID_ECDSA_SPECIFIED                &quot;1.2.840.10045.4.3&quot;

Result
   Hash OID or nil if not set.
</cmt>
  </macro>
  <macro>
    <name>Digital.sig.read</name>
    <act>Y</act>
    <stx>Length@Digital.sig.read^Result</stx>
    <dsc>Reads data from buffer after signing or verification.</dsc>
    <code>@Wr</code>
    <cmt>Length
   The number of characters to read from the buffer.

Result
   Buffer contents.   </cmt>
  </macro>
  <macro>
    <name>Digital.sig.status</name>
    <act>Y</act>
    <stx>@Digital.sig.status^Result</stx>
    <dsc>Status or Error information.</dsc>
    <code>@We</code>
    <cmt>Result
   Last stats or error encountered.</cmt>
  </macro>
  <macro>
    <name>Digital.sig.write</name>
    <act>Y</act>
    <stx>Value@Digital.sig.write^Result</stx>
    <dsc>Writes the [value] to buffer.</dsc>
    <code>@Ww</code>
    <cmt>Value
   Data to be appended to buffer.

Result
   Returns [value] if successful.</cmt>
  </macro>
  <macro>
    <name>Digital.sign.allocate</name>
    <act>N</act>
    <stx/>
    <dsc>Initializes digital signature struct and allocates an initial 4k message buffer</dsc>
    <code>@Wa</code>
    <cmt>Returns initial buffer size on success, nil on failure.</cmt>
  </macro>
  <macro>
    <name>Direct.appl</name>
    <act>Y</act>
    <stx>@Direct.appl[function,args...]</stx>
    <dsc>Provides access to Magic.dll which allows MagicCS to control other software.</dsc>
    <code>#d</code>
    <cmt>This syntax provides access to MAGIC.DLL, which allows MagicCS to control other software. Specifically it was designed to allow MagicCS to control WordView.exe for viewing MSWord-format documents.

A partial list of functions:

#d[&quot;START&quot;,&lt;Path&gt;Filename,CommandTail] returns a process Handle.
   Start the specified program (minimized), optionally passing the command tail

#d[&quot;SHOW&quot;,Handle,State]
   Change the visual state of the process.
      State=1 means Regular size
      State=2 means Minimize
      State=3 means Maximize

#d[&quot;FILE&quot;,Handle,&lt;Path&gt;Filename]
   Load the specified file into the process.

#d[&quot;CLOSE&quot;,Handle]
   Close the current file in the process.  In the case of a multiple document program like      WordView, only the top (active) document will be closed.

#d[&quot;QUIT&quot;,Handle]
   Unhook the process, closing the handle.  If no other MagicCS jobs have handles open to       the process, it is signalled to stop.

#d[&quot;HANG&quot;,Handle] returns a Key Code
   Bring the process to the foreground and suspend MagicCS until the user types &lt;F12&gt; or        closes the process (by clicking the X button, for example).

#d[&quot;WAIT&quot;,Handle] returns a Key Code
   Similar to &quot;HANG&quot;, but is used to interact with a MagicFS process which can control when     to return to MagicCS.  Brings the MagicFS process to the foreground and suspends MagicCS     until MagicFS calls the KBFLAG function.  The argument to this function is the value         passed back to MagicCS as the Key Code.

#d[&quot;TIME&quot;,Handle,Seconds]
   Set a timer value for subsequent &quot;HANG&quot; functions.  If MagicCS is suspended and the user     does not type any keys or move the mouse for this many seconds, the HANG function returns    with no Key Code.

#d[&quot;Window&quot;,String]
   Checks for the existence of a window whose title contains the specified String, and          returns the full Window Title if found.

#d[&quot;Class&quot;,String]
   Checks for the existence of a window of the specified Class, and returns 1 if found.

</cmt>
  </macro>
  <macro>
    <name>Direct.appl.lite</name>
    <act>Y</act>
    <stx>@Direct.appl.lite(arg)</stx>
    <dsc>Provides access to Magic.dll which allows MagicCS to control other software.</dsc>
    <code>#dl[@1]</code>
    <cmt>Unlike @Direct.appl, allows for only a single argument which is passed to MAGIC.DLL. However, provides means for handling arbitraily deeply nested list forms.

arg must of the form:  D(1)_item_D(3)_SubItemList_SubItemList_D(2)_D(3)_Item_D(2)
</cmt>
  </macro>
  <macro>
    <name>Direct.appl.memory</name>
    <act>Y</act>
    <stx>@Direct.appl.memory(memoryHandle)</stx>
    <dsc>Provides access to Magic.dll which allows MagicCS to control other software.</dsc>
    <code>#dm[@1]</code>
    <cmt>Unlike @Direct.appl, allows for only a single argument which is passed to MAGIC.DLL. However, provides means for handling arbitraily deeply nested list forms.  Similar to @Direct.appl.lite, except the list is contained in the buffer pointed to by memoryHandle. This allows the list to be longer than 256 bytes.

The contents of the buffer must be of the form:    D(1)_item_D(3)_SubItemList_SubItemList_D(2)_D(3)_Item_D(2)
</cmt>
  </macro>
  <macro>
    <name>Directory.create</name>
    <act>Y</act>
    <stx>path@Directory.create</stx>
    <dsc>Creates a Windows directory (folder) at the specified path.</dsc>
    <code>@DC</code>
    <cmt>Returns: 1 if successful; else 0.</cmt>
  </macro>
  <macro>
    <name>Directory.create.default</name>
    <act>Y</act>
    <stx>path@Directory.create.default</stx>
    <dsc>Creates a directory with a default Access Control List (ACL)</dsc>
    <code>@Dc</code>
    <cmt/>
  </macro>
  <macro>
    <name>Directory.delete</name>
    <act>Y</act>
    <stx>path@Directory.delete</stx>
    <dsc>Deletes a Windows directory (folder) at the specified path.</dsc>
    <code>@DD</code>
    <cmt>Returns: 1 if successful; else 0.</cmt>
  </macro>
  <macro>
    <name>Disk.error</name>
    <act>Y</act>
    <stx/>
    <dsc>Deturns the disk error in the event that @File.open or @File.close returned nil.</dsc>
    <code>@DE</code>
    <cmt/>
  </macro>
  <macro>
    <name>Disk.free.space</name>
    <act>Y</act>
    <stx>drive@Disk.free.space</stx>
    <dsc>Returns the free space for [drive].</dsc>
    <code>@ZSF</code>
    <cmt>Suggested usage is V(&quot;&lt;drive&gt;:\&quot;@Disk.free.space), since for large volumes an arithmetic expression is returned that must be evaluated to give an integer result.</cmt>
  </macro>
  <macro>
    <name>Disk.total.space</name>
    <act>Y</act>
    <stx>drive@Disk.total.space</stx>
    <dsc>Returns the total space for drive.</dsc>
    <code>@ZST</code>
    <cmt>Suggested usage is V(&quot;&lt;drive&gt;:\&quot;@Disk.total.space), since for large volumes an arithmetic expression is returned that must be evaluated to give an integer result.</cmt>
  </macro>
  <macro>
    <name>Dispatch</name>
    <act>Y</act>
    <stx>exp@Dispatch</stx>
    <dsc>Forces the interpreter to dispatch (branch) to the [exp]-th local subroutine.</dsc>
    <code>@XF</code>
    <cmt>Each subroutine must be separated from main body of code by a blank line.  Each subroutine&apos;s source must have a first line of the form dispatch.1 to dispatch.nn to match the value of [exp] in the command. </cmt>
  </macro>
  <macro>
    <name>Display</name>
    <act>Y</act>
    <stx>@Display(field.name,screen or *,value)</stx>
    <dsc>Display [value] at the location of [field.name] on [screen].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..screen(^S)_&quot;</code>
    <cmt>Display [value] at the location of [field.name] on [screen].  If the screen is part of the same procedure as the procedure logic, use * for [screen].

Example:
P(row,column,value:nL)^#

where n = length of field.name


</cmt>
  </macro>
  <macro>
    <name>Display.label</name>
    <act>Y</act>
    <stx>@Display.label(field.name,screen or *,value)</stx>
    <dsc>Like @Display, but uses label font and color.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..screen(^S)_&quot;</code>
    <cmt>Example:
D(1,1,2,2)_P(row,column,value:nL)_D(2,0,1,2)^#

where n = length of field.name

Restores font and color to data attributes, after the display.
</cmt>
  </macro>
  <macro>
    <name>Display.queue.no</name>
    <act>Y</act>
    <stx>@Display.queue.no(row,column,length,value)</stx>
    <dsc>Displays queue #s at a multiple by queue on a screen.</dsc>
    <code>D(1,1,2,2,6,0,@1,@2-1,1,@3+1,6,9,6,14)_&quot;_D(34)_&quot;R&quot;_D(34)_&quot;_{@4}_D(2,0,1,1)</code>
    <cmt>Defines a region at position [row], [column]-1 and of size 1,[length]+1, and right justifies the value in that region.  It is up to the programmer to set Arial Bold font and label color, if necessary, and to reset them, if necessary. </cmt>
  </macro>
  <macro>
    <name>Display.string</name>
    <act>Y</act>
    <stx>@Display.string(jfy,string)</stx>
    <dsc>Displays [string] vertically centered in the current region.</dsc>
    <code>D(6,14)_@1_{@2}</code>
    <cmt>Displays string either left-justified ([jfy]=&quot;L&quot;), right-justified ([jfy]=&quot;R&quot;), or centered ([jfy]=&quot;C&quot;) and vertically centered in the current region.

</cmt>
  </macro>
  <macro>
    <name>Domain.suffix</name>
    <act>Y</act>
    <stx/>
    <dsc>Allows changing/viewing of appended domain suffix</dsc>
    <code>@ND</code>
    <cmt>domainname@ND sets domainname as the default string to be appended to names as they are resolved.

&quot;&quot;@ND will return the current string

.@ND clears the currently set default (any one byte argument)
</cmt>
  </macro>
  <macro>
    <name>Drag.and.drop</name>
    <act>Y</act>
    <stx/>
    <dsc>Activate Drag&amp;Drop mode.</dsc>
    <code>4^#D</code>
    <cmt>Cursor shape (indicated by the &quot;4&quot;):   Copy (arrow and a shadow page with + sign).

The mode is automatically cancelled when the mouse button is released.  This syntax is only effective when the user has pressed the Left Mouse button in a mouse-active region with a timer, and is still holding the button down.

While in Drag&amp;Drop mode, 2 conditions pertain:

1)  The cursor will not change shape when a read is terminated, thereby allowing the             application to have control over it during Drag period.

2)  The application will be informed whenever the mouse button is released, no matter where      the cursor is at the time.  Upon release, #L|4=&quot;U&quot; to indicate the release.  If the          cursor is not over any recognizable region, the &quot;Handle&quot; and &quot;Row&quot; fields (#L|1 &amp; #L|2)      are NIL.
</cmt>
  </macro>
  <macro>
    <name>Drag.not.drop</name>
    <act>Y</act>
    <stx/>
    <dsc>Activate Drag&amp;Drop mode.</dsc>
    <code>2^#D</code>
    <cmt>Cursor shape (indicated by the &quot;2&quot;):   No (circle with slash)

The mode is automatically cancelled when the mouse button is released.  This syntax is only effective when the user has pressed the Left Mouse button in a mouse-active region with a timer, and is still holding the button down.

While in Drag&amp;Drop mode, 2 conditions pertain:

1)  The cursor will not change shape when a read is terminated, thereby allowing the             application to have control over it during Drag period.

2)  The application will be informed whenever the mouse button is released, no matter where      the cursor is at the time.  Upon release, #L|4=&quot;U&quot; to indicate the release.  If the          cursor is not over any recognizable region, the &quot;Handle&quot; and &quot;Row&quot; fields (#L|1 &amp; #L|2)      are NIL.
</cmt>
  </macro>
  <macro>
    <name>Draw.box</name>
    <act>Y</act>
    <stx>@Draw.box(row,column,height,width)</stx>
    <dsc>Draws a graphics box of [height] and [width] at [row],[column].</dsc>
    <code>D(16,@1,@2,4,2,@3,@4)</code>
    <cmt>Box lines are in the middle of the character cell (see also @Draw.pixel.box.cur.pos).  With [height]=1 or [width]=1, draws a thick horizontal or vertical graphics line.  NOTE: These are not recessed boxes and are not intended as data entry fields (answerboxes) - see @Draw.boxes.
</cmt>
  </macro>
  <macro>
    <name>Draw.box.cur.pos</name>
    <act>Y</act>
    <stx>@Draw.box.cur.pos(height,width)</stx>
    <dsc>Draws a graphics box of [height] and [width] at the current cursor position.</dsc>
    <code>D(4,2,@1,@2)</code>
    <cmt>Box lines are in the middle of the character cell (see also @Draw.pixel.box.cur.pos).  With [height]=1 or [width]=1, draws a thick horizontal or vertical graphics line.
</cmt>
  </macro>
  <macro>
    <name>Draw.boxes</name>
    <act>Y</act>
    <stx>@Draw.boxes(row,column,height.width)</stx>
    <dsc>Draws a bordered answerbox of [height] and [width] at [row],[column].</dsc>
    <code>D(16,@1,@2,5,0,@3,@4)</code>
    <cmt>If [height]&gt;1, each row is separated by thin gray lines, and should be used for multiples only. </cmt>
  </macro>
  <macro>
    <name>Draw.boxes.cur.pos</name>
    <act>Y</act>
    <stx>@Draw.boxes.cur.pos(height.width)</stx>
    <dsc>Draws a bordered answerbox of [height] and [width] at current cursor position.</dsc>
    <code>D(5,0,@1,@2)</code>
    <cmt>If height&gt;1, each row is separated by thin gray lines, and should be used for multiples only. </cmt>
  </macro>
  <macro>
    <name>Draw.cell</name>
    <act>Y</act>
    <stx>@Draw.cell(row,column,height,width)</stx>
    <dsc>Draws a bordered region of [height] and [width] at the [row],[column].</dsc>
    <code>D(16,@1,@2,5,4,@3,@4)</code>
    <cmt>If height&gt;1, there are no separators between rows.

Similar to @Draw.region except that the borders are drawn so that two cells adjacent vertically will not overlap and that borders on all sides are equal.  This is used primarily for spreadsheets.
</cmt>
  </macro>
  <macro>
    <name>Draw.cell.cur.pos</name>
    <act>Y</act>
    <stx>@Draw.cell.cur.pos(height,width)</stx>
    <dsc>Draws a bordered region of [height] and [width] at the current cursor position.</dsc>
    <code>D(5,4,@1,@2)</code>
    <cmt>If height&gt;1, there are no separators between rows.

Similar to @Draw.region except that the borders are drawn so that two cells adjacent vertically will not overlap and that borders on all sides are equal.  This is used primarily for spreadsheets.
</cmt>
  </macro>
  <macro>
    <name>Draw.horiz.line</name>
    <act>Y</act>
    <stx>@Draw.horiz.line(row,column,width)</stx>
    <dsc>Draws a thin horizontal line of [width] at [row],[column].</dsc>
    <code>D(16,@1,@2,4,3,@3)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Draw.horiz.line.cur.pos</name>
    <act>Y</act>
    <stx>@Draw.horiz.line.cur.pos(width)</stx>
    <dsc>Draws a thin horizontal line of [width] at the curent cursor position.</dsc>
    <code>D(4,3,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Draw.icon</name>
    <act>Y</act>
    <stx>@Draw.icon(row,column,height,width,icon#)</stx>
    <dsc>Draws [icon#] in the region defined by [row],[column],[height],[width].</dsc>
    <code>D(6,0,@1,@2,@3,@4,6,7,@5)</code>
    <cmt>Icons 0-4 are delivered with Windows; the others are linked into the MagicCS Client program.

Icon Meaning:

  0 - Application (black box around white)
  1 - Stop Sign
  2 - Question Mark
  3 - Exclamation Mark
  4 - Information Symbol
  5 - MagicCS Program Icon
  9 - File Cabinet
 10 - Big Left Arrow
 11 - Big Right Arrow
 14 - Stop Light
 15 - Trash Can
</cmt>
  </macro>
  <macro>
    <name>Draw.panel</name>
    <act>Y</act>
    <stx>@Draw.panel(row,column,height,width)</stx>
    <dsc>Draws a cutout panel style border at [row],[column] of [height] and [width]</dsc>
    <code>D(6,0,@1,@2,@3,@4,6,9,6,11)</code>
    <cmt>The color.use (see @Color.use) should be Z.color.panels before invoking this command. </cmt>
  </macro>
  <macro>
    <name>Draw.panel.border</name>
    <act>Y</act>
    <stx>@Draw.panel.border(&quot;&quot;)</stx>
    <dsc>Draw a cutout panel-style border around the current region.</dsc>
    <code>D(6,11)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Draw.panel.button</name>
    <act>Y</act>
    <stx>@Draw.panel.button(&quot;&quot;)</stx>
    <dsc>Draw a button-style border around the current region.</dsc>
    <code>D(6,17,2)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Draw.pixel.border</name>
    <act>Y</act>
    <stx>@Draw.pixel.border(row,column,height,width,attribute)</stx>
    <dsc>Draw a 1-pixel box of [height] and [width] at [row],[column] in [attribute]</dsc>
    <code>D(16,@1,@2,4,8,@3,@4,@5)</code>
    <cmt>If [attribute] is &gt; 127, then a dotted box is drawn.  The box is drawn outside the character cells, rather than within the character cells, as in the case of @Draw.pixel.box.</cmt>
  </macro>
  <macro>
    <name>Draw.pixel.border.cur.pos</name>
    <act>Y</act>
    <stx>@Draw.pixel.border.cur.pos(height,width,attribute)</stx>
    <dsc>Draw a 1-pixel box of [height] and [width] at current cursor pos in [attribute]</dsc>
    <code>D(4,8,@1,@2,@3)</code>
    <cmt>If [attribute] is &gt; 127, then a dotted box is drawn.  The box is drawn outside the character cells, rather than within the character cells, as in the case of @Draw.pixel.box.</cmt>
  </macro>
  <macro>
    <name>Draw.pixel.box</name>
    <act>Y</act>
    <stx>@Draw.pixel.box(row,column,height,width,attribute)</stx>
    <dsc>Draw a 1-pixel box of [height] and [width] at [row],[column] in [attribute]</dsc>
    <code>D(16,@1,@2,4,6,@3,@4,@5)</code>
    <cmt>If [attribute] is 255, the current foreground color is used.  If [attribute]&gt;127, then a dotted box is drawn.  The box is drawn within the character cells, rather than outside the character cells, as in the case of @Draw.pixel.border.</cmt>
  </macro>
  <macro>
    <name>Draw.pixel.box.cur.pos</name>
    <act>Y</act>
    <stx>@Draw.pixel.box.cur.pos(height,width,attribute)</stx>
    <dsc>Draw a 1-pixel box of [height] and [width] at current cursor pos in [attribute]</dsc>
    <code>D(4,6,@1,@2,@3)</code>
    <cmt>If [attribute] is 255, the current foreground color is used. If [attribute]&gt;127, then a dotted box is drawn.  The box is drawn within the character cells, rather than outside the character cells, as in the case of @Draw.pixel.border.


</cmt>
  </macro>
  <macro>
    <name>Draw.pixel.line</name>
    <act>Y</act>
    <stx>@Draw.pixel.line(row,column,y-offset,x-offset,height,width,attribute)</stx>
    <dsc>Draw a pixel line in [attribute] at pixel offsets x,y starting at [row],[column]</dsc>
    <code>D(16,@1,@2,4,7,@3,@4,@5,@6,@7)</code>
    <cmt>Draw a pixel line in the specified [attribute] at pixel offsets [y-offset] and [x-offset] starting at the top, left (0,0) of the character cell at [row] and [column].  Each cell is 16 X 7 pixels.

If [attribute] is 255, the current foreground color is used.
</cmt>
  </macro>
  <macro>
    <name>Draw.pixel.line.cur.pos</name>
    <act>Y</act>
    <stx>@Draw.pixel.line.cur.pos(y-offset,x-offset,height,width,attribute)</stx>
    <dsc>Draw a pixel line in [attribute] at pixel offsets x,y starting at current pos</dsc>
    <code>D(4,7,@1,@2,@3,@4,@5)</code>
    <cmt>Draw a pixel line in the specified [attribute] at pixel offsets [y-offset] and [x-offset] starting at the top, left (0,0) of the character cell at the current cursor position.  Each cell is 16 X 7 pixels.

If [attribute] is 255, the current foreground color is used.
</cmt>
  </macro>
  <macro>
    <name>Draw.pixel.offset.border</name>
    <act>Y</act>
    <stx>@Draw.pixel.offset.border(row,column,y-offset,x-offset,height,width,attribute)</stx>
    <dsc>Draw a pixel box in [attribute] at pixel offsets x,y starting at [row],[column]</dsc>
    <code>D(16,@1,@2,4,9,@3,@4,@5,@6,@7)</code>
    <cmt>Draw a box at [y-offset] and [x-offset] pixels from the top left (0,0) of the character cell at [row] and [column], with [height] and [width] specified in pixels.

If [attribute] &gt; 127, then a dotted box is drawn.
</cmt>
  </macro>
  <macro>
    <name>Draw.pixel.offset.border.cur.pos</name>
    <act>Y</act>
    <stx>@Draw.pixel.offset.border.cur.pos(y-offset,x-offset,height,width,attribute)</stx>
    <dsc>Draw a pixel box in [attribute] at pixel offsets x,y starting at current pos</dsc>
    <code>D(4,9,@1,@2,@3,@4,@5)</code>
    <cmt>Draw a box at [y-offset] and [x-offset] pixels from the top left (0,0) of the character cell at the current cursor position, with [height] and [width] specified in pixels.

If [attribute] &gt; 127, then a dotted box is drawn.
</cmt>
  </macro>
  <macro>
    <name>Draw.region</name>
    <act>Y</act>
    <stx>@Draw.region(row,column,height,width)</stx>
    <dsc>Draws a bordered region of [height] and [width] starting at [row],[column]</dsc>
    <code>D(16,@1,@2,5,2,@3,@4)</code>
    <cmt>If height&gt;1, there are no separators between rows.  This is used primarily for text input areas. </cmt>
  </macro>
  <macro>
    <name>Draw.region.box</name>
    <act>Y</act>
    <stx>@Draw.region.box(&quot;&quot;)</stx>
    <dsc>Draws a 1-pixel box around the current region.</dsc>
    <code>D(6,1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Draw.region.cur.pos</name>
    <act>Y</act>
    <stx>@Draw.region.cur.pos(height,width)</stx>
    <dsc>Draws a bordered region of [height] and [width] at current cursor position</dsc>
    <code>D(5,2,@1,@2)</code>
    <cmt>If height&gt;1, there are no separators between rows.  This is used primarily for text input areas. </cmt>
  </macro>
  <macro>
    <name>Draw.region.cur.pos.alt</name>
    <act>Y</act>
    <stx>@Draw.region.cur.pos.alt(Height,Width)</stx>
    <dsc>Draws a bordered region at [Height] and [Width] in the current attribute</dsc>
    <code>D(5,5,@1,@2)</code>
    <cmt>Functions like @Draw.region.cur.pos but without forcing the attribute.  Because this function is outside the standard parameters for answerboxes, no guarentee is made that any of the highlighting or erase-by-attribute functions will work predictably in this region.

NOTE: This is only available in versions 5.2 or greater.  In earlier versions the @Draw.region.cur.pos macro will be used.
</cmt>
  </macro>
  <macro>
    <name>Duplicate.handle</name>
    <act>Y</act>
    <stx>{pid,handle}@Duplicate.handle^handle</stx>
    <dsc>Duplicates handle (NT only)</dsc>
    <code>@DH</code>
    <cmt/>
  </macro>
  <macro>
    <name>Enc.get</name>
    <act>Y</act>
    <stx/>
    <dsc>Gets Encryption data</dsc>
    <code>@Eg</code>
    <cmt>Used only for system tools.</cmt>
  </macro>
  <macro>
    <name>Enc.share.exit</name>
    <act>Y</act>
    <stx/>
    <dsc>Exits encryption share</dsc>
    <code>@Ex</code>
    <cmt>Used only by system tools.</cmt>
  </macro>
  <macro>
    <name>Enc.share.init</name>
    <act>Y</act>
    <stx>keys@Enc.share.init</stx>
    <dsc>Initialize encryption</dsc>
    <code>@Ei</code>
    <cmt>Used only by system tools.</cmt>
  </macro>
  <macro>
    <name>Enc.update</name>
    <act>Y</act>
    <stx>{keys,IPA,unqueid}@Enc.update(type)</stx>
    <dsc>Updates encryption keys</dsc>
    <code>@Eu</code>
    <cmt>Used only by system tools.</cmt>
  </macro>
  <macro>
    <name>Erase.boxes</name>
    <act>Y</act>
    <stx>@Erase.boxes(row,column,height,width)</stx>
    <dsc>Erase answerboxes within the specified region</dsc>
    <code>D(16,@1,@2,5,1,@3,@4)</code>
    <cmt>Erases answerboxes within the specified region whether the data is displayed as normal or highlighted characters.  This can be used to erase data in an area created by either @Draw.boxes or @Draw.region.  NOTE: In many cases, this is what you should use in the place of previous uses @Erase.region whose functionality has changed.
</cmt>
  </macro>
  <macro>
    <name>Erase.boxes.cur.pos</name>
    <act>Y</act>
    <stx>@Erase.boxes.cur.pos(height,width)</stx>
    <dsc>Erase answerboxes within the region whose top left corner is at current position</dsc>
    <code>D(5,1,@1,@2)</code>
    <cmt>Erases answerboxes, whether the data is displayed as normal or highlighted characters, within the region whose top left corner is the current cursor position and is defined by [height] and [width].  This can be used to erase data in an area created by either @Draw.boxes or @Draw.region.  NOTE: In many cases, this is what you should use in the place of previous uses @Erase.region whose functionality has changed.
</cmt>
  </macro>
  <macro>
    <name>Erase.field</name>
    <act>Y</act>
    <stx>@Erase.field([row,column,]width)</stx>
    <dsc>Erase the characters at the current cursor position for [width]</dsc>
    <code>&quot;_IF{S[3] &quot;D(16,@1,@2,5,3,@3)&quot;;&quot;D(5,3,@1)&quot;}_&quot;</code>
    <cmt/>
  </macro>
  <macro>
    <name>Erase.panel.border</name>
    <act>Y</act>
    <stx>@Erase.panel.border(&quot;&quot;)</stx>
    <dsc>Erase a cutout panel-style border around the current region.</dsc>
    <code>D(6,15)</code>
    <cmt>This is the inverse of @Draw.panel.border. </cmt>
  </macro>
  <macro>
    <name>Erase.panel.button</name>
    <act>Y</act>
    <stx>@Erase.panel.button(&quot;&quot;)</stx>
    <dsc>Erase a cutout panel-style border around the current region.</dsc>
    <code>D(6,17,0)</code>
    <cmt>This is the inverse of @Draw.panel.button. </cmt>
  </macro>
  <macro>
    <name>Erase.region</name>
    <act>Y</act>
    <stx>@Erase.region(row,column,height,width)</stx>
    <dsc>Erase all pixels in the specified region to the bkg color of current color use</dsc>
    <code>D(6,0,@1,@2,@3,@4,6,9)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Erase.region.box</name>
    <act>Y</act>
    <stx>@Erase.region.box(&quot;&quot;)</stx>
    <dsc>Erase the 1-pixel box around the current region.</dsc>
    <code>D(6,16)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Error.type</name>
    <act>Y</act>
    <stx>@Error.type(&quot;&quot;)</stx>
    <dsc>On error, returns error type</dsc>
    <code>@ZET</code>
    <cmt>&quot;C&quot; for user clicked close box
&quot;S&quot; for user clicked spy/break
else error line #</cmt>
  </macro>
  <macro>
    <name>Est.buf</name>
    <act>Y</act>
    <stx>@Est.buf(X,@segment.name)</stx>
    <dsc>Copy segment.name into variable X and tell translator to use buffered ref to seg</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.buf(^S)_&quot;</code>
    <cmt>This macro does two things.  First, it copies the value at the physical address of the segment name into the variable name of the buffer (X in this case).  Next, it tells the translator that all future references to fields on that segment should use X as the base until the buffer is cleared by a @Clr.buf.

Example:

Consider a segment called main with a physical file name of BZ and subscript local bz.

@Est.buf(X,@segment.name)       @segment.name^X,
which would translate to        BZ[bz]^X

@Est.buf(X,@segment.name,initial.value)   Typically used to initialize the buffer to nil (eg., @Est.buf(X,@main,&quot;&quot;)). initial.value^X

</cmt>
  </macro>
  <macro>
    <name>Est.t.rec</name>
    <act>Y</act>
    <stx>@Est.t.rec(X,@segment.name[,noCopy])</stx>
    <dsc>Copy the value at and below segment.name into buffer and translate to buf refs</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.t.rec(^S)_&quot;</code>
    <cmt>This macro does two things.  First, it copies the value at and below the physical address of the segment name into the buffered record.  Next, it tells the translator that all future references to fields in this segment should use the buffer until it is cleared by a @Clr.t.rec.  If noCopy is non-nil, the code to open the temporary prefix is generated, but no move is performed.

Examples:
@Est.t.rec(X,@MIS.USER.main)       O(/(.TX)S,&quot;P&quot;),M(&amp;(G)GU[gu],/(.TX)GU[gu])
@Est.t.rec(X,@MIS.USER.main,1)     O(/(.TX)S,&quot;P&quot;)

Like @Def.buf, but for a whole segment and its children.  The prefix /(.TX) is opened to a temporary RAF.  The prefix portion of all RAF references is replaced with this temporary buffer prefix.
</cmt>
  </macro>
  <macro>
    <name>Event.create.auto</name>
    <act>Y</act>
    <stx>NAME@Event.create.auto</stx>
    <dsc>Creates a optionally named auto-reset event</dsc>
    <code>@EA</code>
    <cmt>Used for Windows events and Semaphores.  Returns nil on error, or handle on success.</cmt>
  </macro>
  <macro>
    <name>Event.create.manual</name>
    <act>Y</act>
    <stx>NAME@Event.create.manual</stx>
    <dsc>Create a optionally named manual-reset event</dsc>
    <code>@EM</code>
    <cmt>Used for Windows events and Semaphores.  Returns nil on error, or handle on success.</cmt>
  </macro>
  <macro>
    <name>Event.log.close</name>
    <act>Y</act>
    <stx>@Event.log.close(&quot;&quot;)</stx>
    <dsc>Close the NT Eventlog</dsc>
    <code>#lC</code>
    <cmt>Closes the NT Eventlog and returns nil.</cmt>
  </macro>
  <macro>
    <name>Event.log.entry</name>
    <act>Y</act>
    <stx>{arg1,arg2,arg3,arg4,arg5}@Event.log.entry</stx>
    <dsc>Creates an entry in the NT event log.</dsc>
    <code>@ZLE</code>
    <cmt>[arg1]  `event type&apos;:
  E - Error
  W - Warning
  I - Information
[arg2]   `event id&apos;
[arg3]   category
[arg4]   event source&apos;
[arg5]   text included with the entry

Example:
{&quot;I&quot;,12345,67,&quot;LAB.DEV&quot;,&quot;123abc&quot;}@ZLE

type = Information
event id = 12345
category = 67
event source = LAB.DEV
text= &quot;123abc&quot;
</cmt>
  </macro>
  <macro>
    <name>Event.log.open</name>
    <act>Y</act>
    <stx>@Event.log.open(ComputerName,EventLog)</stx>
    <dsc>Open the specified NT Eventlog on the specified Computer</dsc>
    <code>#lO[@1,@2]</code>
    <cmt>Returns 1 if successful, else NIL.

Only one EventLog can be open at a time.  If a log is open when this function is called, it will be closed before this function executes.

ComputerName
  name of computer to access (not UNC name)

EventLog
  Three choices are available:
    - Application
    - System
    - Security</cmt>
  </macro>
  <macro>
    <name>Event.log.read</name>
    <act>Y</act>
    <stx>@Event.log.read(Flags,RecordOffset,MemoryID)</stx>
    <dsc>Read the specified record, placing the data in the MemoryID buffer</dsc>
    <code>#lR[@1,@2,@3]</code>
    <cmt>Returns: # of bytes read if successful
         &quot;E-BufferSize&quot; if MemoryID could not be made big enough
         &quot;E-&quot;_number to indicate other failure

Flags
 EVENTLOG_SEQUENTIAL_READ        1
 EVENTLOG_SEEK_READ              2
 EVENTLOG_FORWARDS_READ          4
 EVENTLOG_BACKWARDS_READ         8

 These values can also be used in unison.  ie. A sequential backwards read is 1 + 8 = 9.

RecordOffset
 is which record to start from</cmt>
  </macro>
  <macro>
    <name>Event.log.warning</name>
    <act>Y</act>
    <stx/>
    <dsc>Event.log.warning</dsc>
    <code>@ZLW</code>
    <cmt/>
  </macro>
  <macro>
    <name>Event.open</name>
    <act>Y</act>
    <stx>NAME@Event.open</stx>
    <dsc>Opens to a named event.</dsc>
    <code>@EO</code>
    <cmt>Used for Windows events and Semaphores.  Returns nil on error, or handle on success.</cmt>
  </macro>
  <macro>
    <name>Event.reset</name>
    <act>Y</act>
    <stx>handle@Event.reset</stx>
    <dsc>Rests the event for Manual events.</dsc>
    <code>@ER</code>
    <cmt>Used for Windows events and Semaphores.  Returns nil on error, or handle on success.</cmt>
  </macro>
  <macro>
    <name>Event.set</name>
    <act>Y</act>
    <stx>handle@Event.set</stx>
    <dsc>Sets event.</dsc>
    <code>@ES</code>
    <cmt>Used for Windows events and Semaphores.  Returns nil on error, or handle on success.

On auto reset events the named event will reset after one thread has been released.
On manual reset events Event.reset is needed to reset the event.</cmt>
  </macro>
  <macro>
    <name>Event.set.registry.key</name>
    <act>Y</act>
    <stx>arg@Event.set.registry.key</stx>
    <dsc>Creates a new subkey in the NT Registry</dsc>
    <code>@ZLK</code>
    <cmt>Creates a new subkey in the NT Registry under the key:
    SYSTEM\CurrentControlSet\Services\EventLog\Application of HKEY_LOCAL_MACHINE.

Examples:
&quot;LAB.DEV&quot;@ZLK will create the subkey:
    SYSTEM\CurrentControlSet\Services\EventLog\Application\LAB.DEV

&quot;MagicApp\LAB.DEV&quot;@ZLK will create the subkey:
    SYSTEM\CurrentControlSet\Services\EventLog\Application\MagicApp\LAB.DEV

(This may not be of any value because Event Viewer appears to only allow filtering of entries by `event source&apos; based on the first level below `Application&apos;.)

</cmt>
  </macro>
  <macro>
    <name>Event.set.registry.value</name>
    <act>Y</act>
    <stx>{arg1,arg2,arg3}@Event.set.registry.value</stx>
    <dsc>Sets a value in the NT registry.</dsc>
    <code>@ZLV</code>
    <cmt>[arg1] = key
[arg2] =  name
[arg3] =  value

Example:
{&quot;LAB.DEV&quot;,&quot;TypesSupported&quot;,2}@ZLV
    will assign the value &quot;2&quot; to the name &quot;TypesSupported&quot; in the subkey
    SYSTEM\CurrentControlSet\Services\EventLog\Application\LAB.DEV

</cmt>
  </macro>
  <macro>
    <name>Event.thread</name>
    <act>Y</act>
    <stx/>
    <dsc>Event Thread</dsc>
    <code>@ET</code>
    <cmt>System use only.</cmt>
  </macro>
  <macro>
    <name>Execute.3tier</name>
    <act>Y</act>
    <stx>@Execute.3tier(string)</stx>
    <dsc>Execute [string] on a 3-tier client.</dsc>
    <code>#ZX[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Execute.object.foreground</name>
    <act>Y</act>
    <stx/>
    <dsc>Similar to @Execute.object.local except code runs in the forground.</dsc>
    <code>@Xo</code>
    <cmt>See Thread Functions documentation on the Intranet.</cmt>
  </macro>
  <macro>
    <name>Execute.object.local</name>
    <act>Y</act>
    <stx>[{argList}]@Execute.object.local(code)</stx>
    <dsc>Starts a thread to execute passed-in code.</dsc>
    <code>@XO</code>
    <cmt>Example: @XO(4@GC)
Alternative: {arguments}@XO(code)
</cmt>
  </macro>
  <macro>
    <name>Execute.object.remote</name>
    <act>Y</act>
    <stx/>
    <dsc>Executes a thread on target Vmagic Server</dsc>
    <code>@XR</code>
    <cmt>This replaces @XU and @XT that were used in the UDP world.

When using @XR do not open or close the TCP socket, nor is a listening socket needed.
Must follow this command with a @Net.read.tcp.

If the client-side code is using @Net.buffer.size, this call must go after the call to @Execute.object.remote to prevent a memory leak.

Any threads use this command and are using  @Net.buffer.size need to do a 0@Net.buffer.size, and a @Net.flush.tcp at the end.</cmt>
  </macro>
  <macro>
    <name>Execute.object.tcp</name>
    <act>Y</act>
    <stx>@Execute.object.tcp(code,prefix)</stx>
    <dsc>Start a new thread on the [prefix]&apos;s machine to execute [code].</dsc>
    <code>@XT</code>
    <cmt>Example: @XT(4@GC,%)^A

See Thread Code documentation on the Intranet.</cmt>
  </macro>
  <macro>
    <name>Execute.object.udp</name>
    <act>Y</act>
    <stx>@Execute.object.udp(code,prefix)</stx>
    <dsc>Start a thread on [prefix]&apos;s machine to execute [code].  Opens TCP connection.</dsc>
    <code>@XU</code>
    <cmt>Example: @XU(4@GC,%)^A

See Thread Code documentation on the Intranet.</cmt>
  </macro>
  <macro>
    <name>FS.dll</name>
    <act>Y</act>
    <stx>arg@FS.dll(slot,function)</stx>
    <dsc>Calls a function in the FS dll loaded in specified slot</dsc>
    <code>@@1@2</code>
    <cmt>To use this macro, the &quot;slot&quot; and &quot;function&quot; must not be in quotes.

So say anpclient.dll is loaded under slot - a, and the function is B then the call would be:

ARGS@FS.dll(a,B)

where a and B are not variables, but just non-quoted letters.

Alternate form:

If the amount of data being sent or returned from the dll will exceed 64k then it will be necessary to use an alternate form of the FS.load.dll and FL.dll commands. The differences are how the dll is loaded and the case of the slot function ( letter ) to be executed. If you load the dll using the alternate form then all calls to the FS.dll must also use the alternate form, you can&apos;t mix your calling methods at your convenience - the way you load it dictates the way you must call the functions.

Syntax:  {&lt;Size&gt;,&lt;GlobalHandle&gt;}@FS.dll(slot,function)^&lt;NumberOfBytes&gt;,
Return:  NumberOfBytes
Example: {Size,GH}@FS.dll(a,b)^Bytes   Translated =&gt;  {Size,GH}@ae^Bytes,

Technical Notes:

Difference between: old &quot;U&quot;pper case letter, and new &quot;l&quot;ower case letter, DLL calls:

FS Style DLLs are all the same - each function expects to be passed a &quot;point&quot; (the address in memory of the argument(s)) and an &quot;extent&quot; (the number of bytes of data being passed). The difference between @aA and @aa is simply how those things are determined. When you use the &quot;old&quot; style functions in CS, the CS interpreter ( has a 64k limit ) evaluates the data you passed, and calculates those two parameters to pass to the dll. With the &quot;new&quot; style functions, the application is responsible for knowing the address of the data to be passed and the byte count. Also of note, the return value to the application will simply be the number of bytes in the answer, you won&apos;t directly receive the answer. You would need to read those bytes from the address you passed in (the answer is always written to the same memory location as the arguments). </cmt>
  </macro>
  <macro>
    <name>FS.get.dll</name>
    <act>Y</act>
    <stx>slot@FS.get.dll</stx>
    <dsc>Returns the path to the dll loaded in slot.</dsc>
    <code>@1@Xn</code>
    <cmt>This function will check to see if a MEDITECH dll is loaded in a slot.  It returns the path to the dll loaded.
</cmt>
  </macro>
  <macro>
    <name>FS.load.dll</name>
    <act>Y</act>
    <stx>dll.path@FS.load.dll(slot)</stx>
    <dsc>This function loads a FS style DLL and assigns it the lowercase letter passed in</dsc>
    <code>@X@1</code>
    <cmt>The lowercase letter used to define the DLL is not to be in quotes.  Also the letter range for the slots allowed is a thru m.
Ex.

&quot;anpclient.dll&quot;@FS.load.dll(a)

will load the anpclient.dll into slot a.

Alternate form:

If the amount of data being sent or returned from the dll will exceed 64k then it will be necessary to use an alternate form of the FS.load.dll and FL.dll commands. The differences are how the dll is loaded and the case of the slot function ( letter ) to be executed. If you load the dll using the alternate form then all calls to the FS.dll must also use the alternate form, you can&apos;t mix your calling methods at your convenience - the way you load it dictates the way you must call the functions.

Syntax:  dll.path@FS.load.dll(slot)(&lt;GlobalHandle&gt;,&lt;GlobalHandle&gt;+&lt;BufferSize&gt;)
Return:  True - Dll has been loaded.
         &quot;&quot;   - Dll has not been loaded.
Example: &quot;anpclient.dll&quot;@FS.load.dll(a)(GH,GH+BS)   Translated =&gt;  &quot;anpclient.dll&quot;@Xa(GH,GH+BS)

Technical Notes:

Difference between: old &quot;U&quot;pper case letter, and new &quot;l&quot;ower case letter, DLL calls:

FS Style DLLs are all the same - each function expects to be passed a &quot;point&quot; (the address in memory of the argument(s)) and an &quot;extent&quot; (the number of bytes of data being passed). The difference between @aA and @aa is simply how those things are determined. When you use the &quot;old&quot; style functions in CS, the CS interpreter ( has a 64k limit ) evaluates the data you passed, and calculates those two parameters to pass to the dll. With the &quot;new&quot; style functions, the application is responsible for knowing the address of the data to be passed and the byte count. Also of note, the return value to the application will simply be the number of bytes in the answer, you won&apos;t directly receive the answer. You would need to read those bytes from the address you passed in (the answer is always written to the same memory location as the arguments). </cmt>
  </macro>
  <macro>
    <name>FS.magic.dll.exec</name>
    <act>Y</act>
    <stx>{point,extent,code member}@FS.magic.dll.exec</stx>
    <dsc>Executes code in magicfs.dll</dsc>
    <code>&quot;_IF{S[1] &quot;@JX&quot;_&quot;(&quot;_S[1]_&quot;)&quot;;&quot;@Jx&quot;}_&quot;</code>
    <cmt>Returns size of value in buffer defined by point.

Alternative method would be to call
data@FS.magic.dll.exe(code member)
This returns data on the stack.</cmt>
  </macro>
  <macro>
    <name>FS.magic.dll.init</name>
    <act>Y</act>
    <stx>path@FS.magic.dll.init</stx>
    <dsc>Initialized the magicfs.dll</dsc>
    <code>@JI</code>
    <cmt/>
  </macro>
  <macro>
    <name>FS.magic.dll.load</name>
    <act>Y</act>
    <stx>matprogram@FS.magic.dll.load</stx>
    <dsc>Loads MAT program into dll from the path specified.</dsc>
    <code>@JL</code>
    <cmt/>
  </macro>
  <macro>
    <name>FS.magic.dll.unload</name>
    <act>Y</act>
    <stx>@FS,magic.dll.unload</stx>
    <dsc>Unloads magicfs.dll</dsc>
    <code>@JZ</code>
    <cmt/>
  </macro>
  <macro>
    <name>FS.stack.address</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns {point, extent, size} of Magic FS data stack</dsc>
    <code>@JS</code>
    <cmt>This is to be used in conjunction with the MagicFS.dll or in csmagic.dll when called by magic.exe.
</cmt>
  </macro>
  <macro>
    <name>FS.unload.dll</name>
    <act>Y</act>
    <stx>@FS.unload.dll(slot)</stx>
    <dsc>Unload the dll specified by the slot</dsc>
    <code>&quot;_D(34,34)_&quot;@X@1</code>
    <cmt>Ex.
@FS.unload.dll(a)

will unload the dll in slot a.
Do not put the slot letter in quotes.
</cmt>
  </macro>
  <macro>
    <name>Field.handle</name>
    <act>Y</act>
    <stx>@Field.handle(field.name,screen.name.or.*)</stx>
    <dsc>Returns field handle (var &apos;s&apos; in scrn obj) for [field.name] in [screen.name]</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..screen(^S)_&quot;</code>
    <cmt>Returns the field handle (value of local variable &apos;s&apos; in screen object code) for [field.name] in [screen.name] or the screen associated with the current procedure (*).

Example:  May be used to mouse-enable a field that had to be redrawn (^#H).
</cmt>
  </macro>
  <macro>
    <name>File.attributes</name>
    <act>Y</act>
    <stx>{path,attributeString}@File.attributes</stx>
    <dsc>Allows for the reading and setting of file attributes.</dsc>
    <code>@Fa</code>
    <cmt>[path] is the path to the file we&apos;re interested in.  [attributeString] is a concatenation of any combination of R, A, S, and H, indicating Read-Only, Archive, System, and Hidden respectively.  Using the upper-case characters will cause those attributes to be set; using lower-case will cause them to be cleared.  If successful, the function will return the current attribute settings; otherwise errno_&quot;E&quot; will be returned.  If the [attributeString] is omitted, the function will return the current settings.
</cmt>
  </macro>
  <macro>
    <name>File.audit.trail</name>
    <act>Y</act>
    <stx>@File.audit.trail(^segment.name,DPM,filer.program,database,flag)</stx>
    <dsc>Call to program %Z.file.audit.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..functions(^S)_&quot;</code>
    <cmt>Arguments:

A = name of file (Example: ^@main)
B = DPM (optional - it will be computed if not supplied)
C = logical name of filer program (defaults to the procedure if nil)
D = database to use if not @.db (optional)
E = flag to force entry to be filed as NEW (optional)

Example:
@File.audit.trail(^@MIS.USER.main,&quot;MIS.USER&quot;,&quot;MIS.USER.file&quot;,&quot;MIS&quot;)


</cmt>
  </macro>
  <macro>
    <name>File.close</name>
    <act>Y</act>
    <stx/>
    <dsc>Closes the current file.</dsc>
    <code>@Fc</code>
    <cmt>See @File.open.</cmt>
  </macro>
  <macro>
    <name>File.copy</name>
    <act>Y</act>
    <stx>{srcPath,tarPath}@File.copy</stx>
    <dsc>Copy source file to target file.</dsc>
    <code>@FC</code>
    <cmt/>
  </macro>
  <macro>
    <name>File.create</name>
    <act>Y</act>
    <stx>path@File.create</stx>
    <dsc>Create an empty file.</dsc>
    <code>@FA</code>
    <cmt/>
  </macro>
  <macro>
    <name>File.date</name>
    <act>Y</act>
    <stx>[TimeInSeconds]@File.date</stx>
    <dsc>Set modification date of current file or get time for current file.</dsc>
    <code>@Fd</code>
    <cmt>If [TimeInSeconds] is specified, sets the modification date of the current file to this time.  Else, returns the time for the current file.</cmt>
  </macro>
  <macro>
    <name>File.delete</name>
    <act>Y</act>
    <stx>path@File.delete</stx>
    <dsc>Delete a file.</dsc>
    <code>@FD</code>
    <cmt/>
  </macro>
  <macro>
    <name>File.destroy</name>
    <act>Y</act>
    <stx>path@File.destroy</stx>
    <dsc>Destroy the contents of a file and delete it.</dsc>
    <code>@FX</code>
    <cmt>This function should be used to destroy an unencrypted client temp file if it contained Protected Health Information (PHI).  Destroying the file both zeros out the contents and deletes the file.</cmt>
  </macro>
  <macro>
    <name>File.encrypt.pfx</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the necessary prefix to make a file encrypted.</dsc>
    <code>@FP</code>
    <cmt>This function simply returns the prefix string which indicates that a client temp file should be encrypted.  It should be prepended to an absolute file path used with the @File.create, @File.copy, or @File.move functions.

When using @File.copy or @File.move, the target file will be encrypted if prefixed by @File.encrypt.pfx regardless of whether the source file was encrypted.  If the target file path is not prefixed by @File.encrypt.pfx, the target filewill NOT be encrypted regardless of the encryption state of the source file.

examples:

   &quot;C:\tempfile.txt&quot;@File.create
      - &quot;C:\tempfile.txt&quot; is created and is not encrypted.

   @File.encrypt.pfx_&quot;C:\tempfile.txt&quot;@File.create
      - &quot;C:\tempfile.txt&quot; is created and is encrypted.

   {&quot;C:\tempfile.txt&quot;,&quot;C:\tempfile2.txt&quot;}@File.move
      - &quot;C:\tempfile2.txt&quot; is an unencrypted version of &quot;C:\tempfile.txt&quot;, regardless of
         whether &quot;C:\tempfile.txt&quot; was encrypted.

   {&quot;C:\tempfile.txt&quot;,@File.encrypt.pfx_&quot;C:\tempfile2.txt&quot;}@File.move
      - &quot;C:\tempfile2.txt&quot; is an encrypted version of &quot;C:\tempfile.txt&quot;, regardless of
         whether &quot;C:\tempfile.txt&quot; was encrypted.

   {&quot;C:\tempfile.txt&quot;,&quot;C:\tempfile2.txt&quot;}@File.copy
      - &quot;C:\tempfile2.txt&quot; is an unencrypted copy of &quot;C:\tempfile.txt&quot;, regardless of
         whether &quot;C:\tempfile.txt&quot; was encrypted.

   {&quot;C:\tempfile.txt&quot;,@File.encrypt.pfx_&quot;C:\tempfile2.txt&quot;}@File.copy
      - &quot;C:\tempfile2.txt&quot; is an encrypted copy of &quot;C:\tempfile.txt&quot;, regardless of
         whether &quot;C:\tempfile.txt&quot; was encrypted.
</cmt>
  </macro>
  <macro>
    <name>File.encrypted</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns 1 iff the current file is encrypted, else 0.</dsc>
    <code>@FE</code>
    <cmt/>
  </macro>
  <macro>
    <name>File.handle</name>
    <act>Y</act>
    <stx>fileHandle@File.handle</stx>
    <dsc>Sets the current file handle.</dsc>
    <code>@Fh</code>
    <cmt>While only one file handle is kept internally by MagicCS, &gt;1 files can be opened using @File.open or @File.open.safe and the file handles saved locally for use in subsequent @File.handle commands.</cmt>
  </macro>
  <macro>
    <name>File.move</name>
    <act>Y</act>
    <stx>{srcPath,tarPath}@File.move</stx>
    <dsc>Move source file to target directory (folder).</dsc>
    <code>@FM</code>
    <cmt/>
  </macro>
  <macro>
    <name>File.open</name>
    <act>Y</act>
    <stx>path@File.open</stx>
    <dsc>Opens the file at path. Returns a fileHandle if successful, else nil.</dsc>
    <code>@Fo</code>
    <cmt>MagicCS &quot;remembers&quot; the fileHandle as the &quot;current file&quot;.</cmt>
  </macro>
  <macro>
    <name>File.open.dialog</name>
    <act>Y</act>
    <stx>@File.open.dialog(path,additionalFilters,createFlag[,defaultFile])</stx>
    <dsc>Displays the Windows-defined OpenFileName dialog box</dsc>
    <code>#FO[@1,@2,@3&quot;_IF{S[4] &quot;,@4&quot;}_&quot;]</code>
    <cmt>Displays the Windows-defined OpenFileName dialog box and returns a path and filename, if one is selected, else NIL.

[path]
The initial directory in which the dialog will start.

[additionalFilters]
The file types automatically include Text files (*.txt) and All files (*.*).  By specifying additional filters here, other types may be selected.  The syntax of this argument is: TextToBeDisplayed|ExtensionPattern|...| (eg Rich Text Files (*.rtf)|*.rtf|).  These filters are prepended to the defaults, and the first one specified will be initially selected.

[createFlag]
If this flag is set (&gt;0) and the file specified does not exist, the user will be asked if the file is to be created.  If the answer is yes, the dialog ends and the path/name is returned.  If the answer is no, the dialog continues.

Passing an empty #mA type memory buffer with a flag of 256 in the create/overwrite flag will cause the file open to allow for more than one file to be selected.  It is returned in the
memory buffer in the format:

        directory_D(0)_file0_D(0),file1_D(0)...fileN_D(0)_D(0)_D(0)

In the case of a single file being selected the memory buffer has the following format:

        directory\file_D(0)_D(0)_D(0)

The macro will return the number of bytes in the buffer

[defaultFile]
Optional argument which indicates a default file to display.
</cmt>
  </macro>
  <macro>
    <name>File.open.exclusive</name>
    <act>Y</act>
    <stx>path@File.open.exclusive</stx>
    <dsc>Performs an exclusive open of the file at path.  Returns fileHandle or NIL.</dsc>
    <code>@Fx</code>
    <cmt>Performs an exclusive open of the file at path.  Returns a fileHandle if successful, else NIL.

MagicCS &quot;remembers&quot; the fileHandle as the &quot;current file&quot;.
</cmt>
  </macro>
  <macro>
    <name>File.open.readonly</name>
    <act>Y</act>
    <stx>path@File.open.readonly</stx>
    <dsc>Performs a read-only open of the file at path.  Returns fileHandle or NIL.</dsc>
    <code>@Fl</code>
    <cmt>Performs a read-only open of the file at path.  Returns a FileHandle if successful, else NIL.

MagicCS &quot;remembers&quot; the FileHandle as the &quot;current file&quot;.</cmt>
  </macro>
  <macro>
    <name>File.position.beg</name>
    <act>Y</act>
    <stx>#bytes@File.position.beg</stx>
    <dsc>Move the byte pointer for the current file [#bytes] forward from start of file</dsc>
    <code>@Fb</code>
    <cmt>The &quot;current file&quot; is the file for which MagicCS is &quot;remembering&quot; a fileHandle internally. Only one such file exists, but the current file can be changed using the @File.handle macro and other file handles managed programmatically.</cmt>
  </macro>
  <macro>
    <name>File.position.end</name>
    <act>Y</act>
    <stx>#bytes@File.position.end</stx>
    <dsc>Move the byte pointer for the current file #bytes backward from end of file</dsc>
    <code>@Fe</code>
    <cmt>The &quot;current file&quot; is the file for which MagicCS is &quot;remembering&quot; a fileHandle internally. Only one such file exists, but the current file can be changed using the @File.handle macro and other file handles managed programmatically.</cmt>
  </macro>
  <macro>
    <name>File.position.neg</name>
    <act>Y</act>
    <stx>#bytes@File.position.neg</stx>
    <dsc>Move byte pointer for the current file [#bytes] backward from current pointer</dsc>
    <code>@Fn</code>
    <cmt>The &quot;current file&quot; is the file for which MagicCS is &quot;remembering&quot; a fileHandle internally. Only one such file exists, but the current file can be changed using the @File.handle macro and other file handles managed programmatically.</cmt>
  </macro>
  <macro>
    <name>File.position.pos</name>
    <act>Y</act>
    <stx>#bytes@File.position.pos</stx>
    <dsc>Move byte pointer for the current file [#bytes] forward from the current pointer</dsc>
    <code>@Fp</code>
    <cmt>The &quot;current file&quot; is the file for which MagicCS is &quot;remembering&quot; a fileHandle internally. Only one such file exists, but the current file can be changed using the @File.handle macro and other file handles managed programmatically.</cmt>
  </macro>
  <macro>
    <name>File.read</name>
    <act>Y</act>
    <stx>#bytes@File.read</stx>
    <dsc>Returns [#bytes] from the current file pointer forward.</dsc>
    <code>@Fr</code>
    <cmt/>
  </macro>
  <macro>
    <name>File.save.dialog</name>
    <act>Y</act>
    <stx>@File.save.dialog(path,additionalFilters,overwriteFlag[,defaultFile])</stx>
    <dsc>Displays the Windows-defined SaveFileName dialog box and returns a path</dsc>
    <code>#FS[@1,@2,@3&quot;_IF{S[4] &quot;,@4&quot;}_&quot;]</code>
    <cmt>Displays the Windows-defined SaveFileName dialog box and returns a path and filename, if one is selected, else NIL.

[path]
The initial directory in which the dialog will start.

[additionalFilters]
The file types automatically include Text files (*.txt) and All files (*.*).  By specifying additional filters here, other types may be selected.  The syntax of this argument is: TextToBeDisplayed|ExtensionPattern|...| (eg Rich Text Files (*.rtf)|*.rtf|).  These filters are prepended to the defaults, and the first one specified will be initially selected.

[overwriteFlag]
If this flag is set (&gt;0) and the file specified exists, the user will be asked if the file is to be overwritten.  If the answer is yes, the dialog ends and the path/name is returned. If the answer is no, the dialog continues.

[defaultFile]
Optional argument which indicates a default file to display.

</cmt>
  </macro>
  <macro>
    <name>File.size</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the size in bytes of the current file.</dsc>
    <code>@Fs</code>
    <cmt>See @File.open.</cmt>
  </macro>
  <macro>
    <name>File.t.rec</name>
    <act>Y</act>
    <stx>@File.t.rec(X,@segment.name)</stx>
    <dsc>Saves the local record buffer specified by [X] to [@segment.name].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.t.rec(^S)_&quot;</code>
    <cmt>G(..) function is used to copy from the buffer to @segment.name.

@File.t.rec(X,@MIS.USER.main)     G(/(.TX)GU[gu],&amp;(G)GU[gu])

Also see @Def.t.rec or @Est.t.rec for details.

</cmt>
  </macro>
  <macro>
    <name>File.truncate</name>
    <act>Y</act>
    <stx/>
    <dsc>Truncates the current file at the file pointer.</dsc>
    <code>@Ft</code>
    <cmt/>
  </macro>
  <macro>
    <name>File.txn.log</name>
    <act>Y</act>
    <stx>@File.txn.log([drFlag])</stx>
    <dsc>Call to program %Z.file.txn.</dsc>
    <code>IF{&apos;gxz;%(Z)file.txn(gxz&quot;_IF{S[1]&apos;=D(34,34) &quot;,@1&quot;}_&quot;)}</code>
    <cmt>Files an entry to the MIS Audit Trail log.  See any dictionary filer for usage.  If optional argument [drFlag] is non-NIL, an image of the record is set up for the Data Repositiory.

</cmt>
  </macro>
  <macro>
    <name>File.utc.date</name>
    <act>Y</act>
    <stx/>
    <dsc>File timestamp in GMT format (non-localized).</dsc>
    <code>@Fu</code>
    <cmt>This will be used by by the server program to check timestamps on files for CHKPGM transactions which fixes a problem with virtual memory being consumed after the fall Daylight Saving Change.</cmt>
  </macro>
  <macro>
    <name>File.version</name>
    <act>Y</act>
    <stx>path@File.version</stx>
    <dsc>Returns the internal file version for file specified by [path]</dsc>
    <code>@FV</code>
    <cmt/>
  </macro>
  <macro>
    <name>File.write</name>
    <act>Y</act>
    <stx>string@File.write</stx>
    <dsc>Writes string to the current file beginning at the file pointer.</dsc>
    <code>@Fw</code>
    <cmt/>
  </macro>
  <macro>
    <name>First</name>
    <act>Y</act>
    <stx>@First(element.name[,segment.name])</stx>
    <dsc>Produces code that gets the first value for the subscript [element.name].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..nexting(^S)_&quot;</code>
    <cmt>Produces code that gets the first value for the subscript [element.name].  If [segment.name] is specified, use it; else use @main.

Example:
@First(@MIS.USER.abs.tape.svc)    +&amp;(G)GU[gu]A[&quot;&quot;]


</cmt>
  </macro>
  <macro>
    <name>First.file</name>
    <act>Y</act>
    <stx>pattern@First.file^X</stx>
    <dsc>Begin a file search using pattern.  Pattern is a path and file pattern.</dsc>
    <code>@ZFF</code>
    <cmt>Example:
pattern = &quot;\\SERVER\D\DIR\A*.*&quot;.

Returns:

{filename,attr,size,create.seconds,last.edit.seconds,last.access.seconds}

where [attr = attributes: &quot;D&quot; for directory, &quot;R&quot; for read-only, etc.]

See also @Next.file.
</cmt>
  </macro>
  <macro>
    <name>Folder.tab.create</name>
    <act>Y</act>
    <stx>@Folder.tab.create(`tabText,...,tabText&apos;)</stx>
    <dsc>Create folder tabs at the top of the current MagicCS window.</dsc>
    <code>#fC[@1]</code>
    <cmt>The argument is a list of text strings, each corresponding to one tab.  Tabs will be arranged in rows based on the size of the text.  The first tab will be initially selected.
An ampersand (&amp;) preceding a character in a tabText argument designates the character that follows as the hot-key for that tab.  Typing &lt;ALT&gt;+hot-key returns information to the MagicCS job as if the user had clicked the mouse over the tab. To display an ampersand as part of the text type &amp;&amp;.

Returns a list of folderHandles (integers) which can be used for selection.  The folderHandles correspond to the tabText arguments.  For example, @Folder.tab.create(`The first one,The next one,The last one&apos;) will return {1,2,3}.

This function causes a change in the real estate of the window in which it is used.  If you create 1 row of folder tabs you lose 2 character rows.  If you create 2-9 rows of folder tabs you lose 3 character rows.
</cmt>
  </macro>
  <macro>
    <name>Folder.tab.disable</name>
    <act>Y</act>
    <stx>@Folder.tab.disable(folderHandle)</stx>
    <dsc>Disable the specified folder tab.</dsc>
    <code>#fD[@1]</code>
    <cmt>Disable the specified folder tab.  The text on the tab is redisplayed in grey and clicking the mouse over the Tab or typing the &lt;ALT&gt;+hot-key will have no effect.

You cannot disable the currently selected tab.  Explicitly selecting a disabled tab using @Folder.tab.select automatically re-enables the tab.
</cmt>
  </macro>
  <macro>
    <name>Folder.tab.enable</name>
    <act>Y</act>
    <stx>@Folder.tab.enable(folderHandle)</stx>
    <dsc>Enable the specified folder tab. The text on the tab is redisplayed in black.</dsc>
    <code>#fE[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Folder.tab.select</name>
    <act>Y</act>
    <stx>@Folder.tab.select(folderHandle)</stx>
    <dsc>Select the specified folder tab.</dsc>
    <code>#fS[@1]</code>
    <cmt>Select the specified folder tab.  If the newly selected folder tab occupies a row other than the front row, the rows are switched.</cmt>
  </macro>
  <macro>
    <name>Folder.tab.status</name>
    <act>Y</act>
    <stx>@Folder.tab.status(folderHandle)</stx>
    <dsc>Return the state of the folder tab. &quot;E&quot; = Enabled &quot;D&quot; = Disabled.</dsc>
    <code>#fM[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Folder.tab.text</name>
    <act>Y</act>
    <stx>@Folder.tab.text(folderHandle,text)</stx>
    <dsc>Change the text of the specified folder to [text].</dsc>
    <code>#fT[@1,@2]</code>
    <cmt>A Hot Key may be designated with the &amp;.  The new text will be truncated if necessary to fit the pre-established tab width.</cmt>
  </macro>
  <macro>
    <name>Frame.maximize</name>
    <act>Y</act>
    <stx/>
    <dsc>Maximizes Vmagic Frame for maximum client area</dsc>
    <code>#w[20]</code>
    <cmt>Maximize the VMagic Frame to the allow for the maximum client area.  It will return the maximum window size that can be created in the current font size (normal or large), screen
resolution and monitor size.</cmt>
  </macro>
  <macro>
    <name>Frame.normal</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns Vmagic Frame to its standard client area</dsc>
    <code>#w[21]</code>
    <cmt>Normalizes the VMagic frame to allow for the standard 26x92 client area.</cmt>
  </macro>
  <macro>
    <name>Get.code</name>
    <act>Y</act>
    <stx>subroutine#@Get.code</stx>
    <dsc>Returns the code associated with [subroutine#] of the program being executed.</dsc>
    <code>@GC</code>
    <cmt>Example: 4@GC

See Thread Functions documentation on Intranet.
</cmt>
  </macro>
  <macro>
    <name>Global.alloc</name>
    <act>Y</act>
    <stx>#bytes@Global.alloc</stx>
    <dsc>Allocates [#bytes] of memory.  Returns a memory address.</dsc>
    <code>@GA</code>
    <cmt>The memory address is used as a &quot;handle&quot; when invoking other functions.  Be sure to allocate sufficient memory for the intended use as more is not allocated dynamically, nor are there protections against reading/writing beyond the intended memory space.  See @Global.alloc.read and @Global.alloc.write.

NOTE: This function should only be used in system and utility programs
</cmt>
  </macro>
  <macro>
    <name>Global.alloc.append</name>
    <act>Y</act>
    <stx>data@Global.alloc.append(handle)</stx>
    <dsc>Appends [data] to the tail of the memory buffer pointed to by [handle].</dsc>
    <code>@GT</code>
    <cmt>The first 4 bytes of the memory buffer will be updated automatically to the correct size value, and the data will be appended to the end of the memory buffer.

Caution: The allocation size of the memory buffer will not be changed, however it is possible to append beyond the allocation limit.  To be certain that you have sufficient space available to accomodate the data being appended, subtract the current length of data in use from the allocation size value &lt;@GZ(handle) - @GL(handle)&gt;.

NOTE: This function should only be used in system and utility programs.
</cmt>
  </macro>
  <macro>
    <name>Global.alloc.insert.head</name>
    <act>Y</act>
    <stx/>
    <dsc/>
    <code>@GH</code>
    <cmt/>
  </macro>
  <macro>
    <name>Global.alloc.insert.tail</name>
    <act>Y</act>
    <stx/>
    <dsc/>
    <code>@GT</code>
    <cmt/>
  </macro>
  <macro>
    <name>Global.alloc.length</name>
    <act>Y</act>
    <stx>@Global.alloc.length(handle)</stx>
    <dsc>Returns the size of the data in the memory buffer pointed to by [handle].</dsc>
    <code>@GL</code>
    <cmt>To determine the number of free bytes remaining in a global memory buffer, use @GZ-@GL.</cmt>
  </macro>
  <macro>
    <name>Global.alloc.prepend</name>
    <act>Y</act>
    <stx>data@Global.alloc.prepend(handle)</stx>
    <dsc>Prepends [data] to the beginning of the memory buffer pointed to by [handle].</dsc>
    <code>@GH</code>
    <cmt>The first 4 bytes of the memory buffer will be updated automatically to the correct size value, and the data will be inserted to the beginning of the memory buffer.

Caution: The allocation size of the memory buffer will not be changed, however it is possible to grow the data size beyond the allocation limit.  To be certain that you have sufficient space available to accomodate the data being appended, subtract the current length of data in use from the allocation size value &lt;@GZ(handle) - @GL(handle)&gt;.

NOTE: This function should only be used in system and utility programs.</cmt>
  </macro>
  <macro>
    <name>Global.alloc.read</name>
    <act>Y</act>
    <stx>@Global.alloc.read(handle)</stx>
    <dsc>Returns the content of the memory buffer pointed to by [handle].</dsc>
    <code>@GR</code>
    <cmt>Data is returned as: first 4 bytes = length of data followed by the data which must not exceed memory allocated by @Global.alloc for this buffer.

NOTE: This function should only be used in system and utility programs.
</cmt>
  </macro>
  <macro>
    <name>Global.alloc.read.raw</name>
    <act>Y</act>
    <stx>#bytes@Global.alloc.read.raw(address)</stx>
    <dsc>Returns [#bytes] from memory [address].</dsc>
    <code>@Gr</code>
    <cmt>[#bytes] of data is returned and must not exceed memory allocated by @Global.alloc for this buffer.  See also @Global.alloc.

NOTE: This function should only be used in system and utility programs.
</cmt>
  </macro>
  <macro>
    <name>Global.alloc.size</name>
    <act>Y</act>
    <stx>@Global.alloc.size(memoryAddress)</stx>
    <dsc>Gives the size of the associated GlobalAlloc (@GA)</dsc>
    <code>@GZ</code>
    <cmt/>
  </macro>
  <macro>
    <name>Global.alloc.string</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns a numeric string representing memory allocated by user functions</dsc>
    <code>@GD</code>
    <cmt>As follows:

     &lt;globalallocs&gt;.&lt;localsymboltable&gt;.&lt;pstructure&gt;</cmt>
  </macro>
  <macro>
    <name>Global.alloc.write</name>
    <act>Y</act>
    <stx>data@Global.alloc.write(handle)</stx>
    <dsc>Writes [data] to the memory buffer pointed to by [handle].</dsc>
    <code>@GW</code>
    <cmt>Data must be formatted as: first 4 bytes = length of data followed by the data and must not exceed memory allocated by @Global.alloc for this buffer.

NOTE: This function should only be used in system and utility programs.
</cmt>
  </macro>
  <macro>
    <name>Global.alloc.write.raw</name>
    <act>Y</act>
    <stx>data@Global.alloc.write.raw(address)</stx>
    <dsc>Writes [data] to memory [address].</dsc>
    <code>@Gw</code>
    <cmt>Data must not exceed memory allocated by @Global.alloc for this buffer.

NOTE: This function should only be used in system and utility programs.

</cmt>
  </macro>
  <macro>
    <name>Global.critical.write</name>
    <act>Y</act>
    <stx>[mode]@Global.critical.write</stx>
    <dsc>Returns or sets the global critical write mode.</dsc>
    <code>@CW</code>
    <cmt>Mode = nil returns the global mode in the format:
mode.#_extra_disk writes_caused_by_this_mode

Mode = 0 turns global critical write OFF

Mode = 2 causes writes to disk whenever the naked pointer moves

NOTE: This function should only be used in system and utility programs.

</cmt>
  </macro>
  <macro>
    <name>Global.debt</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns information about current memory usage</dsc>
    <code>@GD</code>
    <cmt>Returns:

&lt;Global membuff usage&gt;.&lt;Total symbol table usage&gt;.&lt;Total Pstruct Usage&gt;</cmt>
  </macro>
  <macro>
    <name>Global.free</name>
    <act>Y</act>
    <stx>handle@Global.free</stx>
    <dsc>Free memory allocated previously by @Global.alloc.</dsc>
    <code>@GF</code>
    <cmt>[handle] is actually the memory address returned by @Global.alloc when the memory is allocated.</cmt>
  </macro>
  <macro>
    <name>Global.hash</name>
    <act>Y</act>
    <stx/>
    <dsc>Cryptographic hash function</dsc>
    <code>@Gh</code>
    <cmt>New function to create a cryptographic hash function.

{alg,size}@Gh(buf) returns the hash on success and nil on failure.

 alg - Use 0x8003 for MD5 and 0x8004 for SHA1
size - Size of data to be encrypted

Global buffer contains data to be encrypted</cmt>
  </macro>
  <macro>
    <name>Global.list.bkwd</name>
    <act>Y</act>
    <stx>byteOffset@Global.list.bkwd</stx>
    <dsc>Retrieves a magic list by going backwards through the file</dsc>
    <code>@Gb</code>
    <cmt>Usage:  Move the byte pointer to the end of the file then issue call to macro

        @Fs@Gb^{Address,Length}.

ByteOffset must point to the end of a magic list (&quot;}&quot;).  The function reads from the &quot;current&quot; file handle, typically established by opening a file via one of the @F? functions. Address is the address of the memory buffer that contains the first complete magic list the function encountered.  Length is the length of the address memory buffer.
</cmt>
  </macro>
  <macro>
    <name>Global.list.extract</name>
    <act>Y</act>
    <stx>{Address,elementOffset}@Global.list.extract</stx>
    <dsc>Retrieves a particular element from a magic list</dsc>
    <code>@Gp</code>
    <cmt>Usage: {Address,ElementOffset}@Gp^{Address,Length}

Once a magic list is retrieved from reading a buffer established using @Gl (@Global.list.fwd) or @Gb (@Global.list.bkwd), @Gp (@Global.list.extract) is used to extract a particular element from the list.  It does *not* allocate memory -- it simply returns a pointer into the buffer that passed in as an argument.

For example, assume the following list exists in a file:

{&quot;Blue&quot;|&quot;Green&quot;|&quot;Yellow&quot;}

0@Gl^{A0,L},  //Returns the entire list in the address buffer A0 with a length of L.
{A,1}@Gp^{A1,L}  //Returns &quot;Green&quot; in address buffer A1 with a length of L.

To retrieve the data an @Gr (@Global.alloc.read.raw) is used.  L@Gr(A1)^VALUE;
</cmt>
  </macro>
  <macro>
    <name>Global.list.fwd</name>
    <act>Y</act>
    <stx>byteOffset@Global.list.fwd</stx>
    <dsc>Retrieves a magic list by going forward through the file</dsc>
    <code>@Gl</code>
    <cmt>Usage:  ByteOffset@Gl^{Address,Length}

ByteOffset must point to the start of a magic list (&quot;{&quot;).  The function reads from the &quot;current&quot; file handle, typically established by opening a file via one of the @F? functions. Address is the address of the memory buffer that contains the first complete magic list the function encountered.  Length is the length of the address memory buffer.
</cmt>
  </macro>
  <macro>
    <name>Global.sig.check</name>
    <act>Y</act>
    <stx>size@Global.sig.check(handle)</stx>
    <dsc>Checks the MEDITECH Digital Signature of a SAF</dsc>
    <code>@Gv(@1)</code>
    <cmt>Returns OK if success.</cmt>
  </macro>
  <macro>
    <name>Graph.admin</name>
    <act>N</act>
    <stx>@Graph.admin(graphID,thingToSet,value)</stx>
    <dsc>Sets Administrative values for the specified graph.</dsc>
    <code>#gA[@1,@2,@3]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Graph.begin</name>
    <act>N</act>
    <stx>@Graph.begin(graphID,dataType,series/points)</stx>
    <dsc>Signals the beginning of data to follow.</dsc>
    <code>#gB[@1,@2,@3]</code>
    <cmt>Field Meaning

dataType 1 = values for plotting in the chart

series/points = NumberOfPointsPerSeries * 65536 + NumberOfSeries

</cmt>
  </macro>
  <macro>
    <name>Graph.create</name>
    <act>N</act>
    <stx>@Graph.create(row,column,height,width,type,style)</stx>
    <dsc>Creates a graph centered at the indicated region. Returns a graphID or nil.</dsc>
    <code>#gC[@1,@2,@3,@4,@5,@6]</code>
    <cmt>Field Meaning

Type 256 = 3-Dimensional; 1024 = include Toolbar

Style One = number to try is 0xFF7FFFFF = 4286578687.

Further detail on this and many other functions is beyond the scope of this documentation.
</cmt>
  </macro>
  <macro>
    <name>Graph.delete</name>
    <act>N</act>
    <stx>@Graph.delete(graphID)</stx>
    <dsc>Deletes the indicated graph.</dsc>
    <code>#gD[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Graph.end</name>
    <act>N</act>
    <stx>@Graph.end(graphID)</stx>
    <dsc>Signals the end of data passing and causes the indicated graph to be displayed.</dsc>
    <code>#gE[@1,@2]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Graph.font</name>
    <act>N</act>
    <stx>@Graph.font(graphID,titleCode,fontID)</stx>
    <dsc>Modifies the font, but not the color, of any titles and legends in a graph.</dsc>
    <code>#gF[@1,@2,@3]</code>
    <cmt>[graphID] identifies the Graph.

[titleCode] identifies the particular title or legent to modify.

[fontID] identifies one of the fonts in the MagicCS font table.
</cmt>
  </macro>
  <macro>
    <name>Graph.ini.value</name>
    <act>N</act>
    <stx>@Graph.ini.value(graphID,series,point,value)</stx>
    <dsc>Set initial values for points on the indicated graph.</dsc>
    <code>#gI[@1,@2,@3,@4]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Graph.message</name>
    <act>N</act>
    <stx>@Graph.message(graphID,message,wordParameter,longParameter)</stx>
    <dsc>Sends a message to the indicated graph.</dsc>
    <code>#gM[@1,@2,@3,@4]</code>
    <cmt>Messages are used to alter the size, shape and appearance of the graph as well as the options available (eg. toolbars).

If the first byte of the longParameter is D(127), then the parameter is a string; otherwise it is a number.
</cmt>
  </macro>
  <macro>
    <name>Graph.print</name>
    <act>N</act>
    <stx>@Graph.print(graphicHandle,UNCName)</stx>
    <dsc>Creates a metafile of a graph for printing.</dsc>
    <code>#gP[@1,@2]</code>
    <cmt>This was a way for applications to print a graph as part of a document.  The function creates a metafile of the graph, which can then be played back in any context.

[UNCName] is an enhanced MetaFile into which the graph is to be written.
</cmt>
  </macro>
  <macro>
    <name>Graph.value</name>
    <act>N</act>
    <stx>@Graph.value(graphID,series,point,value)</stx>
    <dsc>Sets the value of a point in the indicated graph.</dsc>
    <code>#gV[@1,@2,@3,@4]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Graph.xvalue</name>
    <act>N</act>
    <stx>@Graph.xvalue(graphID,series,point,value)</stx>
    <dsc>Sets the X-value of a point on a Scatter graph.</dsc>
    <code>#gX[@1,@2,@3,@4]</code>
    <cmt>[graphID] identifies the Graph

[series] &amp; [point] identify the point to set

[value] is what to set it to
</cmt>
  </macro>
  <macro>
    <name>Graphic.unc</name>
    <act>Y</act>
    <stx>@Graphic.unc([folder,fileName])</stx>
    <dsc>Returns the path to a bitmap file.</dsc>
    <code>:(.GL)%0&quot;_IF{S[1] &quot;_&quot;_D(34)_&quot;\&quot;_D(34)^xxx_&quot;_@1&quot;_IF{S[2] xxx_&quot;_@2&quot;}}_&quot;</code>
    <cmt>Example:
@Graphic.unc(&quot;toolbar&quot;,&quot;copy&quot;) results in the code:

:(.GL)%0_&quot;\&quot;_&quot;toolbar&quot;_&quot;\&quot;_&quot;copy&quot;

The arguments are optional so you can return the sharename of different levels of the graphics folder if needed.
</cmt>
  </macro>
  <macro>
    <name>Handle.close</name>
    <act>Y</act>
    <stx>handle@Handle.close</stx>
    <dsc>Closes handle</dsc>
    <code>@HC</code>
    <cmt>Returns nil on success, otherwise error #.</cmt>
  </macro>
  <macro>
    <name>Hang</name>
    <act>Y</act>
    <stx>@Hang(arg)</stx>
    <dsc>Suspend (&quot;hang&quot;) program execution.</dsc>
    <code>H(IF{HANG;3}^HANG*@1)</code>
    <cmt>The program is suspended for [arg]*3 seconds unless overridden by the value in local variable HANG, if it exists.
</cmt>
  </macro>
  <macro>
    <name>Highlight.cell</name>
    <act>Y</act>
    <stx>@Highlight.cell(row,column,height,width)</stx>
    <dsc>Highlights the cell at [row] and [column] of [height] and [width].</dsc>
    <code>D(16,@1,@2,24,12,@3,@4)</code>
    <cmt>Used with cells created with @Draw.cell.  See also @Normal.cell.</cmt>
  </macro>
  <macro>
    <name>Highlight.cell.cur.pos</name>
    <act>Y</act>
    <stx>@Highlight.cell.cur.pos(height,width)</stx>
    <dsc>Highlights the cell at the curent cursor position of [height] and [width].</dsc>
    <code>D(24,12,@1,@2)</code>
    <cmt>Used with cells created with @Draw.cell.  See also @Normal.cell.</cmt>
  </macro>
  <macro>
    <name>Highlight.field</name>
    <act>Y</act>
    <stx>@Highlight.field(&quot;&quot;)</stx>
    <dsc>Highlights the text within the field in which the cursor is located.</dsc>
    <code>D(24,2)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Highlight.panel.row</name>
    <act>Y</act>
    <stx>@Highlight.panel.row(row,column,width)</stx>
    <dsc>Highlight a panel row located at [row] and [column] for [width] characters.</dsc>
    <code>D(16,@1,@2,24,4,@3)</code>
    <cmt>See @Draw.panel.</cmt>
  </macro>
  <macro>
    <name>Highlight.panel.row.cur.pos</name>
    <act>Y</act>
    <stx>@Highlight.panel.row.cur.pos(width)</stx>
    <dsc>Highlight a panel row located at the current cursor position for [width] chars</dsc>
    <code>D(24,4,@1)</code>
    <cmt>See @Draw.panel.</cmt>
  </macro>
  <macro>
    <name>Highlight.pixel.region</name>
    <act>Y</act>
    <stx>@Highlight.pixel.region(row,col,y-offset,x-offset,height,width)</stx>
    <dsc>Highlight area [x,y offset] pixels from [row],[column] w/[height],[width] pixels</dsc>
    <code>D(16,@1,@2,28,0,@3,@4,@5,@6)</code>
    <cmt>Highlight an area at cursor position y-offset and x-offset in pixels from row and column with height and width in pixels.

See also @Normal.pixel.region.</cmt>
  </macro>
  <macro>
    <name>Highlight.pixel.region.cur.pos</name>
    <act>Y</act>
    <stx>@Highlight.pixel.region.cur.pos(y-offset,x-offset,height,width)</stx>
    <dsc>Highlight area [x,y offset] pixels from current pos w/[height],[width] pixels</dsc>
    <code>D(28,0,@1,@2,@3,@4)</code>
    <cmt>Highlight an area at cursor position y-offset and x-offset in pixels from the current cursor position with height and width in pixels.

See also @Normal.pixel.region.
</cmt>
  </macro>
  <macro>
    <name>Highlight.row</name>
    <act>Y</act>
    <stx>@Highlight.row(row,column,width)</stx>
    <dsc>Highlight a row located at [row] and [column] for [width] characters.</dsc>
    <code>D(16,@1,@2,24,0,@3)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Highlight.row.color</name>
    <act>Y</act>
    <stx>@Highlight.row.color(row,column,width)</stx>
    <dsc>Highlight an answer box at [row] and [column] for [width] characters</dsc>
    <code>D(16,@1,@2,24,10,@3)</code>
    <cmt>Highlight an answer box at [row] and [column] for [width] characters using the current foreground color. </cmt>
  </macro>
  <macro>
    <name>Highlight.row.color.cur.pos</name>
    <act>Y</act>
    <stx>@Highlight.row.color.cur.pos(width)</stx>
    <dsc>Highlight an answer box at the current cursor position for [width] characters.</dsc>
    <code>D(24,10,@1)</code>
    <cmt>Highlight an answer box at the current cursor position for [width] characters using the current foreground color. </cmt>
  </macro>
  <macro>
    <name>Highlight.row.cur.pos</name>
    <act>Y</act>
    <stx>@Highlight.row.cur.pos(width)</stx>
    <dsc>Highlight a row located at the current cursor position for [width] characters.</dsc>
    <code>D(24,0,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Html</name>
    <act>Y</act>
    <stx>@Html(class,arg1,arg2...argn)</stx>
    <dsc>HTML Command</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..web(^S)_&quot;</code>
    <cmt/>
  </macro>
  <macro>
    <name>IOCP.Create</name>
    <act>Y</act>
    <stx>@IOCP.Create^h</stx>
    <dsc>Creates an IoCompletionPort</dsc>
    <code>@Pc</code>
    <cmt/>
  </macro>
  <macro>
    <name>IOCP.Get</name>
    <act>Y</act>
    <stx>timeout@IOCP.Get(h)^{num,PID}</stx>
    <dsc>Gets a number that was posted to the IoCompletionPort</dsc>
    <code>@Pg</code>
    <cmt/>
  </macro>
  <macro>
    <name>IOCP.Post</name>
    <act>Y</act>
    <stx>number@IOCP.Post(h)</stx>
    <dsc>posts a number to someone waiting on the IoCompletionPort</dsc>
    <code>@Pp</code>
    <cmt/>
  </macro>
  <macro>
    <name>IOCP.get</name>
    <act>N</act>
    <stx>timeout@IOCP.get(h)^{num,PID}</stx>
    <dsc>Waits for someone to post to the IoCompletionPort</dsc>
    <code>@Pg</code>
    <cmt/>
  </macro>
  <macro>
    <name>IPC.accept.credentials</name>
    <act>Y</act>
    <stx/>
    <dsc>Accepts credentials from another IPC process</dsc>
    <code>#iA</code>
    <cmt>Will wait up to 10 seconds to receive credentials from another IPC process.</cmt>
  </macro>
  <macro>
    <name>IPC.cleanup</name>
    <act>Y</act>
    <stx/>
    <dsc>Cleans up structures used by IPC</dsc>
    <code>#iC</code>
    <cmt>Cleans up structures used by IPC, returns nothing.</cmt>
  </macro>
  <macro>
    <name>IPC.credentials</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns of process received credentials from another IPC registered process.</dsc>
    <code>#ic</code>
    <cmt/>
  </macro>
  <macro>
    <name>IPC.enumerate</name>
    <act>Y</act>
    <stx>@IPC.enumerate(memBuf)</stx>
    <dsc>Enumerate IPC sessions.</dsc>
    <code>#iE[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>IPC.focus</name>
    <act>Y</act>
    <stx>@IPC.focus(processID)</stx>
    <dsc>Transfer focus to the given process ID</dsc>
    <code>#iF[@1]</code>
    <cmt>Transfer focus to given process ID. Returns length of process ID if successful else nil.

For more information on IPC commands see: @Call.windows</cmt>
  </macro>
  <macro>
    <name>IPC.group</name>
    <act>Y</act>
    <stx>@IPC.group(memBuf)</stx>
    <dsc>Group information.</dsc>
    <code>#iG[@1]</code>
    <cmt>See IPC documentation for use.</cmt>
  </macro>
  <macro>
    <name>IPC.hang</name>
    <act>Y</act>
    <stx>@IPC.hang(processID)</stx>
    <dsc>Waits for a maximum of 10 seconds for a process to &quot;register&quot; by this ID</dsc>
    <code>#iH[@1]</code>
    <cmt>Waits for a maximum of 10 seconds for a process to &quot;register&quot; by this ID, returns length of process ID if successful else nil.

For more information on IPC commands see: @Call.windows</cmt>
  </macro>
  <macro>
    <name>IPC.initialize</name>
    <act>Y</act>
    <stx>@IPC.initialize(group,processID)</stx>
    <dsc>Allows a process to initialize and join an IPC group.</dsc>
    <code>#iI[{@1},{@2}]</code>
    <cmt/>
  </macro>
  <macro>
    <name>IPC.master.list</name>
    <act>Y</act>
    <stx>@IPC.master.list(memBuf)</stx>
    <dsc>Masterlist of IPC sessions.</dsc>
    <code>#iM[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>IPC.password</name>
    <act>Y</act>
    <stx>@IPC.password(processID)</stx>
    <dsc>Sends a password message to the process</dsc>
    <code>#iP[@1]</code>
    <cmt>Sends a password message to the process. Returns length of process ID if successful else nil.</cmt>
  </macro>
  <macro>
    <name>IPC.query</name>
    <act>Y</act>
    <stx>@IPC.query(processID)</stx>
    <dsc>Waits a maximum of 250 milliseconds for a process to &quot;register&quot; by this ID</dsc>
    <code>#iQ[@1]</code>
    <cmt>Waits a maximum of 250 milliseconds for a process to &quot;register&quot; by this ID. Returns length of process ID if successful else nil.</cmt>
  </macro>
  <macro>
    <name>IPC.read</name>
    <act>Y</act>
    <stx/>
    <dsc>Reads data sent to process</dsc>
    <code>#ir</code>
    <cmt>Reads data sent to process. Returns data or nil.</cmt>
  </macro>
  <macro>
    <name>IPC.read.buffer</name>
    <act>Y</act>
    <stx>@IPC.read.buffer(memBuf)</stx>
    <dsc>Buffer read.</dsc>
    <code>#iR[@1]</code>
    <cmt>Buffer read.  Starts at beginning of buffer thereby overwriting contents.  Will dynamically grow.</cmt>
  </macro>
  <macro>
    <name>IPC.size</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the amount of data to be read</dsc>
    <code>#iS</code>
    <cmt>Returns the amount of data to be read else nil.</cmt>
  </macro>
  <macro>
    <name>IPC.write</name>
    <act>Y</act>
    <stx>@IPC.write(D(1)_processID_D(3)_message_D(2))</stx>
    <dsc>Sends a message to process ID</dsc>
    <code>#iw[@1]</code>
    <cmt>Sends a message to process ID. Returns the length of data sent, including process ID else nil.</cmt>
  </macro>
  <macro>
    <name>IPC.write.buffer</name>
    <act>Y</act>
    <stx>@IPC.write.buffer(memBuf)</stx>
    <dsc>Buffer write.</dsc>
    <code>#iW[@1]</code>
    <cmt>Buffer write.  Writes from beginning of buffer to the high water mark regardless of cursor position.</cmt>
  </macro>
  <macro>
    <name>Icon.draw</name>
    <act>Y</act>
    <stx>@Icon.draw(row,column,bitmapName)</stx>
    <dsc>Draw the indicated [bitmapName] at [row] and [column].</dsc>
    <code>D(16,@1,@2,21,1)_{@3}</code>
    <cmt>NOTE:  This macro is inappropriately named as it actually draws bitmap resources, not icons, which must have been compiled into MagicCS.  See the list below:

check
down
left
right
up
ex
lineup
linedown
pageup
pagedown
top
bottom

See also @Draw.icon.
</cmt>
  </macro>
  <macro>
    <name>Icon.draw.cur.pos</name>
    <act>Y</act>
    <stx>@Icon.draw.cur.pos(bitmapName)</stx>
    <dsc>Draw the indicated [bitmapName] at the current cursor position.</dsc>
    <code>D(21,1)_{@1}</code>
    <cmt>NOTE:  This macro is inappropriately named as it actually draws bitmap resources, not icons, which must have been compiled into MagicCS.  See the list below:

check
down
left
right
up
ex
lineup
linedown
pageup
pagedown
top
bottom

See also @Draw.icon.
</cmt>
  </macro>
  <macro>
    <name>Icon.erase</name>
    <act>Y</act>
    <stx>@Icon.erase(row,column,bitmapName)</stx>
    <dsc>Erase the indicated [bitmapName] at [row] and [column].</dsc>
    <code>D(16,@1,@2,21,0)_{@3}</code>
    <cmt>NOTE:  This macro is inappropriately named as it actually erases bitmap resources, not icons, which must have been compiled into MagicCS.  See the list below:

check
down
left
right
up
ex
lineup
linedown
pageup
pagedown
top
bottom

See also @Draw.icon.
</cmt>
  </macro>
  <macro>
    <name>Icon.erase.cur.pos</name>
    <act>Y</act>
    <stx>@Icon.erase.cur.pos(row,column,bitmapName)</stx>
    <dsc>Erases the indicated bitmap resource at the current cursor position.</dsc>
    <code>D(21,0)_{@1}</code>
    <cmt>NOTE:  This macro is inappropriately named as it actually erases bitmap resources, not icons, which must have been compiled into MagicCS.  See the list below:

check
down
left
right
up
ex
lineup
linedown
pageup
pagedown
top
bottom

See also @Draw.icon.
</cmt>
  </macro>
  <macro>
    <name>Id</name>
    <act>Y</act>
    <stx>@Id(DPM,element)</stx>
    <dsc>Generates code to call the element&apos;s ID logic.</dsc>
    <code>&quot;_%(NPR)SEG..id.gen(S[1],S[2],{S[3],S[4],S[5],S[6],S[7]})_&quot;</code>
    <cmt>Example:  @Id(LAB.C.WL.STATS,sort.mnemonic) =&gt; %(Z)id(^&amp;(S1)SPARAM[&quot;WS&quot;],A,&quot;Mnemonic ....)

Includes the ID.TITLE, ID.ARG, ID.SEL, etc.  You may also append up to 5 optional arguments as overrides, e.g., @Id(DPM,ele,ID.ARG=AR,ID.TITLE=&quot;Title&quot;,...).
</cmt>
  </macro>
  <macro>
    <name>Init.page</name>
    <act>Y</act>
    <stx>@Init.page(page)^#</stx>
    <dsc>Initializes memory for page of a multi-page screen</dsc>
    <code>D(22,2,@1)</code>
    <cmt>Initializes memory for page of a multi-page screen, including any Windows objects such as buttons, etc.  This command is used in the object code each time the page is blanked and the labels (re)drawn.  See also @Read.page and @Write.page.
</cmt>
  </macro>
  <macro>
    <name>Internet.close</name>
    <act>Y</act>
    <stx>[fileHandle[.fileHandle]]@Internet.close</stx>
    <dsc>Closes files indicated by [fileHandle(s)].</dsc>
    <code>@IC</code>
    <cmt>Closes files indicated by [fileHandle(s)].  If no handles are indicated (i.e. NIL), close current open handles.  Returns [fileHandle(s)] for all files closed.
</cmt>
  </macro>
  <macro>
    <name>Internet.delete.file</name>
    <act>Y</act>
    <stx>remoteFilename@Internet.delete.file</stx>
    <dsc>Deletes (FTP) [remoteFilename].</dsc>
    <code>@ID</code>
    <cmt>Returns [remoteFilename] if OK, else NIL.

remoteFilename=(FTP:)//[username:password@]HOST[:port#]/PATH1/PATH2/...[/FILE]

</cmt>
  </macro>
  <macro>
    <name>Internet.error.info</name>
    <act>Y</act>
    <stx/>
    <dsc>Show error information.</dsc>
    <code>@IE</code>
    <cmt>If error occurred, returns CODE[.EXTEND.CODE.STRING], else NIL.

NOTE:  Executing this function resets the error information.
</cmt>
  </macro>
  <macro>
    <name>Internet.first.file</name>
    <act>Y</act>
    <stx>remoteFilename@Internet.first.file</stx>
    <dsc>Find the first FTP file beginning with [remoteFilename].</dsc>
    <code>@IF</code>
    <cmt>If an error occurs, returns {&quot;&quot;,errorcode},

Else returns:
{filename,attr,size,create.seconds,last.edit.seconds,last.access.seconds}

where [attr = attributes: &quot;D&quot; for directory, &quot;R&quot; for read-only, etc.]

See also @Internet.next.file.

</cmt>
  </macro>
  <macro>
    <name>Internet.get.file</name>
    <act>Y</act>
    <stx>{LocalFilename,remoteFilename}@Internet.get.file</stx>
    <dsc>Copies contents of (FTP) [remoteFilename] to [localFilename].</dsc>
    <code>@IG</code>
    <cmt>Returns {LocalFilename,remoteFilename} if OK, else NIL.

remoteFilename=(FTP:)//[username:password@]HOST[:port#]/PATH1/PATH2/...[/FILE]

</cmt>
  </macro>
  <macro>
    <name>Internet.handle</name>
    <act>Y</act>
    <stx>[fileHandle[.fileHandle]]@Internet.handle</stx>
    <dsc>Shows or establishes current handles.</dsc>
    <code>@IH</code>
    <cmt>If [fileHandle(s)] is NIL, shows the current handles; else establishes [fileHandle(s)] as the current handles.

In either case, returns [fileHandle(s)].
</cmt>
  </macro>
  <macro>
    <name>Internet.next.file</name>
    <act>Y</act>
    <stx/>
    <dsc>Find the next FTP file. (See @Internet.first.file)</dsc>
    <code>@IN</code>
    <cmt>If an error occurs, returns {&quot;&quot;,errorcode},

Else returns:
{filename,attr,size,create.seconds,last.edit.seconds,last.access.seconds}

where [attr = attributes: &quot;D&quot; for directory, &quot;R&quot; for read-only, etc.]
</cmt>
  </macro>
  <macro>
    <name>Internet.open.read</name>
    <act>Y</act>
    <stx>remoteName@Internet.open.read</stx>
    <dsc>Open a file for input.</dsc>
    <code>@II</code>
    <cmt>Returns [fileHandle] if OK else NIL.

remoteName=(HTTP:,FTP:)//[username:password@]HOST[:port#]/PATH1/PATH2/...[/FILE]

</cmt>
  </macro>
  <macro>
    <name>Internet.open.write</name>
    <act>Y</act>
    <stx>remoteFilename@Internet.open.write</stx>
    <dsc>Open an FTP file for output.</dsc>
    <code>@IO</code>
    <cmt>Returns [fileHandle] if OK else NIL.

remoteFilename=(FTP:)//[username:password@]HOST[:port#]/PATH1/PATH2/...[/FILE]

</cmt>
  </macro>
  <macro>
    <name>Internet.put.file</name>
    <act>Y</act>
    <stx>{localFilename,remoteFilename}@Internet.put.file</stx>
    <dsc>Copies contents of [localFilename] to (FTP) [remoteFilename].</dsc>
    <code>@IP</code>
    <cmt>Returns {[localFilename],[remoteFilename]} if OK, else NIL.

remoteFilename=(FTP:)//[username:password@]HOST[:port#]/PATH1/PATH2/...[/FILE]
</cmt>
  </macro>
  <macro>
    <name>Internet.read</name>
    <act>Y</act>
    <stx>numBytes@Internet.read</stx>
    <dsc>Read [numBytes] from file opened with @Internet.open.read.</dsc>
    <code>@IR</code>
    <cmt/>
  </macro>
  <macro>
    <name>Internet.write</name>
    <act>Y</act>
    <stx>data@Internet.write</stx>
    <dsc>Write [data] to file opened with @Internet.open.write.</dsc>
    <code>@IW</code>
    <cmt/>
  </macro>
  <macro>
    <name>Kill</name>
    <act>Y</act>
    <stx>@Kill(@segment.name)</stx>
    <dsc>Nils the node at [@segment.name] and all of its descendants.</dsc>
    <code>K(&quot;_IF{S&gt;1 DO{S&gt;1 S-1^S,S[S]_&quot;,&quot;_S[S+1]^S[S],&quot;&quot;^S[S+1]}}_&quot;@1)</code>
    <cmt>This should NOT be used when removing data from the database for the purposes of file maintenance, the macro Kill.fm should be used. </cmt>
  </macro>
  <macro>
    <name>Kill.fm</name>
    <act>Y</act>
    <stx>@Kill.fm(segment.name)</stx>
    <dsc>Nils the node at [@segment.name] and all of its descendants.</dsc>
    <code>k(&quot;_IF{S&gt;1 DO{S&gt;1 S-1^S,S[S]_&quot;,&quot;_S[S+1]^S[S],&quot;&quot;^S[S+1]}}_&quot;@1)</code>
    <cmt>This is similar to the @Kill except it should be used when applications are killing data for file maintenance purposes. Using this macro will prevent the deletions of data from being sent to SQL by use of the IPL data transfer method.</cmt>
  </macro>
  <macro>
    <name>Last</name>
    <act>Y</act>
    <stx>@Last(element.name[,segment.name])</stx>
    <dsc>Produces code that gets the last value for the subscript [element.name].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..nexting(^S)_&quot;</code>
    <cmt>If [segment.name]is specified, use it; else use @main.

@Last(@MIS.USER.abs.tape.svc)   -&amp;(G)GU[gu]A[&quot;&quot;]

For additional information and examples, see Looping Through Data Structures documentation on the Intranet.
</cmt>
  </macro>
  <macro>
    <name>Listbox.add.item</name>
    <act>Y</act>
    <stx>@Listbox.add.item(handle,String)</stx>
    <dsc>Adds the string to the Listbox</dsc>
    <code>#LA[@1,@2]</code>
    <cmt>If the Listbox does not have the SORT style, the string is added to the end of the list.  Otherwise the string is added and the list is sorted.
</cmt>
  </macro>
  <macro>
    <name>Listbox.buffer</name>
    <act>Y</act>
    <stx>@Listbox.buffer(handle,Function,MemoryID)</stx>
    <dsc>Buffer the Listbox</dsc>
    <code>#LB[@1,@2,@3]</code>
    <cmt>The buffer contains &lt;CRLF&gt; delimited strings.

Function:

 0 means Retreive all items into the buffer
    returns number of items retreived
 1 means Add all items to the list
    returns index of last item added
    items are added to the end, no items are removed
</cmt>
  </macro>
  <macro>
    <name>Listbox.create</name>
    <act>Y</act>
    <stx>@Listbox.create(Row,Col,Height,Width,Style)</stx>
    <dsc>Creates a listbox at Row &amp; Col</dsc>
    <code>#LC[@1,@2,@3,@4&quot;_IF{S[5] &quot;,&quot;_S[5]}_&quot;]</code>
    <cmt>Returns a handle.

Style is optional and may be one or more of the following:

 1 = NO_SELECTION - specifies that the list box contains items that can be viewed but not
     selected.

 2 = SORT - the items in the list are automatically sorted.  Items added will be placed in
     their correct position.  Items inserted will not be automatically sorted.

 3 = NO_SELECTION and SORT

 4 = MULTI_SELECT - turns string selection on or off each time the user clicks or
     double-clicks a string in the list box.  The user can select any number of strings.

NO_SELECTION and MULTI_SELECT cannot be used together.  If both are specified, NO_SELECTION will win.</cmt>
  </macro>
  <macro>
    <name>Listbox.delete.item</name>
    <act>Y</act>
    <stx>@Listbox.delete.item(handle,Item)</stx>
    <dsc>Deletes an item from a Listbox</dsc>
    <code>#LD[@1,@2]</code>
    <cmt>Item may have one or more of the following types:
  number means select by index
  string means select by (exact) string match
</cmt>
  </macro>
  <macro>
    <name>Listbox.destroy</name>
    <act>Y</act>
    <stx>@Listbox.destroy(handle)</stx>
    <dsc>Destroys the Listbox</dsc>
    <code>#LX[@1]</code>
    <cmt>Destrots the Listbox identified by handle.</cmt>
  </macro>
  <macro>
    <name>Listbox.focus</name>
    <act>Y</act>
    <stx>@Listbox.focus(handle)</stx>
    <dsc>Set focus to the Listbox</dsc>
    <code>#LF[@1]</code>
    <cmt>Sets focus to the Listbox identified by handle.</cmt>
  </macro>
  <macro>
    <name>Listbox.get.selection</name>
    <act>Y</act>
    <stx>@Listbox.get.selection(ListHandle,MemoryHandle)</stx>
    <dsc>Returns the currently selected string</dsc>
    <code>#LG[@1&quot;_IF{S[2] &quot;,&quot;_@2}_&quot;]</code>
    <cmt>Returns the currently selected string in the Listbox identified by handle.

In the case of a MULTI_SELECT ListBox, the MemoryHandle aregument is required, and the selected strings will be returned as &lt;CRLF&gt; delimited entried in the buffer.

in the case of a Single-select ListBox the MemoryHandle argument is optional, and the selected string will be returned as the value of the function call.</cmt>
  </macro>
  <macro>
    <name>Listbox.index</name>
    <act>Y</act>
    <stx>@Listbox.index(handle,Index,String)</stx>
    <dsc>Insert the String at Index</dsc>
    <code>#LI[@1,@2,@3]</code>
    <cmt>Insert the String at Index in the Listbox identified by handle.

Does not cause a list with the SORT style to be sorted.
</cmt>
  </macro>
  <macro>
    <name>Listbox.reset</name>
    <act>Y</act>
    <stx>@Listbox.reset(handle)</stx>
    <dsc>Clears all the items from the Listbox</dsc>
    <code>#LR[@1]</code>
    <cmt>Clears all the items from the Listbox identified by handle.</cmt>
  </macro>
  <macro>
    <name>Listbox.select.item</name>
    <act>Y</act>
    <stx>@Listbox.select.item(handle,Item)</stx>
    <dsc>Selects an item from the Listbox</dsc>
    <code>#LS[@1,@2]</code>
    <cmt>Items may have one of the following types:

  -1     means select nothing (clear the box)
  number means select by index
  string means select by (exact) string match
</cmt>
  </macro>
  <macro>
    <name>Lite</name>
    <act>Y</act>
    <stx>@Lite(arg1,arg2,arg3,...)</stx>
    <dsc>Takes arguments and creates a Lite list out of them.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..ui(^S)_&quot;</code>
    <cmt>This is a translateable version of @(...)

This will be able to be passed into another Macro unlike @().</cmt>
  </macro>
  <macro>
    <name>Local.memory.allocate</name>
    <act>Y</act>
    <stx>@Memory.allocate(numKbytes)</stx>
    <dsc>Allocates a memory object of [numKbytes].  Returns the memoryHandle.</dsc>
    <code>#(.LC)mA&quot;_IF{S[1]&apos;=D(34,34)&apos;=0 &quot;[@1]&quot;}_&quot;</code>
    <cmt>[numKbytes] specifies the number of 1024-byte chunks to be allocated as the base size of this object.  For example @Memory.allocate(1) will allocate a memory object of 1024 bytes. The argument is optional, and @Memory.alloc(&quot;&quot;) allocates 4K bytes (4096) as its base size.

This is the local version of Memory.allocate. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.beginning</name>
    <act>Y</act>
    <stx>@Local.memory.beginning(memoryHandle)</stx>
    <dsc>Moves the cursor to the beginning of the memory object.</dsc>
    <code>#(.LC)mB[@1]</code>
    <cmt>This is the local version of Memory.beginning. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.clear</name>
    <act>Y</act>
    <stx>@Local.memory.clear(memoryHandle)</stx>
    <dsc>Clears the specified memoryHandle</dsc>
    <code>#(.LC)mX[@1]</code>
    <cmt>Clears the specified memoryHandle buffer.

This is the local version of Memory.clear. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.compare</name>
    <act>Y</act>
    <stx>@Local.memory.compare(BufferID,BufferID)</stx>
    <dsc>Compare the two buffers byte-for-byte.</dsc>
    <code>#(.LC)mK[@1,@2]</code>
    <cmt>If there is a discrepancy, the function returns the byte offset where the difference appeared; otherwise it returns NIL.

This is the local version of Memory.compare. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.copy</name>
    <act>Y</act>
    <stx>@Local.memory.copy(bufferID,bufferID,toCopy,toReplace)</stx>
    <dsc>Copy from one buffer to another, at the cursor position(s).  No return.</dsc>
    <code>#(.LC)mc[@1,@2,@3,@4]</code>
    <cmt>[toCopy] indicates the number of bytes to copy; -1 means ToEndOfBuffer

[toReplace] indicates the number of bytes to replace; -1 means ToEndOfBuffer

@Memory.beginning(0),@Memory.beginning(1),
@Memory.copy(0,1,&quot;-1&quot;,&quot;-1&quot;) copies all the bytes from buffer 0 to buffer 1, replacing the entire contents.

This is the local version of Memory.copy. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.cursor.pos</name>
    <act>Y</act>
    <stx>@Local.memory.cursor.pos(memoryHandle)</stx>
    <dsc>Returns the current cursor position.</dsc>
    <code>#(.LC)mC[@1]</code>
    <cmt>This is the local version of Memory.cursor.pos. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.defined</name>
    <act>Y</act>
    <stx>@Local.memory.defined(memoryHandle)</stx>
    <dsc>Returns 0 if [memoryHandle] is an existing buffer, NIL if not.</dsc>
    <code>#(.LC)ma[@1]</code>
    <cmt>This is the local version of Memory.defined. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.end</name>
    <act>Y</act>
    <stx>@Local.memory.end(memoryHandle)</stx>
    <dsc>Moves the cursor to the end of the memory object.</dsc>
    <code>#(.LC)mE[@1]</code>
    <cmt>This is the local version of Memory.end. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.extract</name>
    <act>Y</act>
    <stx>@Local.memory.extract(Buffer,ListStartChar,Field)^{FieldStartChar,Length}</stx>
    <dsc>Finds the start character and length of a FS list field in a memory buffer</dsc>
    <code>#(.LC)me[@1,@2,@3]</code>
    <cmt>This is the local version of Memory.extract. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.


Buffer
     Handle to the #-based memory buffer containing the FS list of interest.

ListStartChar
     Character offset within Buffer (first character is 0) at which FS list of interest
     starts.  Can be a sublist at any nesting depth.

Field
     Offset of field of interest (first field is 0) within FS list defined by ListStartChar.

FieldStartChar
     Character offset within Buffer at which field of interest starts.

Length
     Length, in bytes, of field of interest.

Examples:  in the following FS list, contained within buffer MH...

{&quot;One&quot;|{&quot;TwoA&quot;|&quot;TwoB&quot;|&quot;TwoC&quot;}|&quot;Three&quot;}

@Memory.extract(MH,0,1) would return {5,16}, indicating that in the very outermost list (starting at character 0), field #1 starts at character #5 in the buffer, and extends for a length of 16.  Since the contents of this field are another sublist, the results of the first extraction can be used to target a field inside the nested list...

@Memory.extract(MH,0,1)^{SUB,LEN},
@Memory.extract(MH,SUB,2)^{FLD,LEN}

These returned values can then be used to extract the actual data value from field #2 of the sublist...

@Memory.set.cursor(MH,FLD),
@Memory.read.chars(MH,LEN)^VALUE</cmt>
  </macro>
  <macro>
    <name>Local.memory.free</name>
    <act>Y</act>
    <stx>@Local.memory.free(memoryHandle)</stx>
    <dsc>Deallocates (frees) a memory object.</dsc>
    <code>#(.LC)mF[@1]</code>
    <cmt>This is the local version of Memory.free. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.get</name>
    <act>Y</act>
    <stx>@Local.memory.get(memoryHandle,globalAddress,numBytes)</stx>
    <dsc>Copy [numBytes] bytes from [globalAddress] into the [memoryHandle].</dsc>
    <code>#(.LC)mG[@1,@2,@3]</code>
    <cmt>Copy [numBytes] bytes from [globalAddress] into the [memoryHandle] buffer at the current cursor position.  Returns [numBytes] if successful; NIL if not.

Resets the HighWaterMark and Cursor to the end of the new data.  [globalAddress] is based on the address returned by the @Global.alloc function.

This is the local version of Memory.get. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.get.bytes</name>
    <act>Y</act>
    <stx>@Local.memory.get.bytes(memoryHandle,start,length{,char})</stx>
    <dsc>Searches the [memoryHandle] buffer from the [start] byte for [char]</dsc>
    <code>#(.LC)mg[@1,@2,@3&quot;_IF{S[4] &quot;,@4&quot;}_&quot;]</code>
    <cmt>Searches the [memoryHandle] buffer from the [start] byte until it finds the specified [char] or reaches [length], whichever comes first.  Returns the bytes in between.

Behaves much like @Memory.read.field with the following exceptions:  The search begins at [start] byte rather than at the current MemCursor position.  The search length is not limited to the High Water Mark of the buffer, but instead is only bounded by the allocated size of the buffer.  If [char] is not specified, the search returns length bytes regardless of what they are.

NOTE: The return value from this function is NOT limited to 256 characters, so beware.

This is the local version of Memory.get.bytes. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.lite.locate</name>
    <act>Y</act>
    <stx>@Local.memory.lite.locate(membuff,list start,element)</stx>
    <dsc>Finds element pos and length in buffer</dsc>
    <code>#(.LC)me[@1,@2,@3]</code>
    <cmt>Returns {pos,length}

This function will find the beginning of a element in a lite list and return the length of it.

This is the local version of Memory.lite.locate. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.lite.to.bmp</name>
    <act>Y</act>
    <stx>@Local.memory.lite.to.bmp(memoryHandle)</stx>
    <dsc>Convert [memoryHandle] from EMR-style picture to a .bmp.</dsc>
    <code>#(.LC)mH[@1]</code>
    <cmt>Returns the number of bytes in the new format if successful; NIL if not.


This is the local version of Memory.lite.to.bmp. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.load.file</name>
    <act>Y</act>
    <stx>@Local.memory.load.file(memoryHandle,UNVName)</stx>
    <dsc>Loads a memory buffer with the file referenced by UNVName.</dsc>
    <code>#(.LC)mT[@1,@2]</code>
    <cmt>Return Values:
        &quot;&quot; = Ok.
     Value = ErrorLetter_ErrorNumber
             Value#0=&quot;C&quot; - Close File Failed.
             Value#0=&quot;M&quot; - Allocating Memory Failed.
             Value#0=&quot;O&quot; - Open Fail Failed.
             Value#0=&quot;R&quot; - Read File Failed.
             Value#0=&quot;S&quot; - Get File Size Failed.


This is the local version of Memory.load.file. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.more</name>
    <act>Y</act>
    <stx>@Local.memory.more(memoryHandle)</stx>
    <dsc>Is the cursor at the end of the memory object?  Returns D(127) or Nil.</dsc>
    <code>#(.LC)mM[@1]</code>
    <cmt>This is the local version of Memory.more. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.next.line</name>
    <act>Y</act>
    <stx>@Local.memory.next.line(memoryHandle[,WordWrapWidth])</stx>
    <dsc>Updates the cursor and returns the next beginning-of-line (BOL) position</dsc>
    <code>#(.LC)mN[@1,@2]</code>
    <cmt>Updates the cursor and returns the next beginning-of-line (BOL) position relative to the current position.

If the text is formatted with automatic word wrap, then the line width in characters must be provided as a second argument.  Otherwise, if hard carriage returns delineate the lines of text, then the nil string must be used as the second argument.  The cursor position remains unchanged when there is no next BOL.

This is the local version of Memory.next.line. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.prev.line</name>
    <act>Y</act>
    <stx>@Local.memory.prev.line(memoryHandle[,WordWrapWidth])</stx>
    <dsc>Updates the cursor and returns the previous beginning-of-line (BOL) position.</dsc>
    <code>#(.LC)mP[@1,@2]</code>
    <cmt>Updates the cursor and returns the previous beginning-of-line (BOL) position relative to the current cursor position.

If the text is formatted with automatic word wrap, then the line width in characters must be provided as a second argument.  Otherwise, if hard carriage returns delineate the lines of text, then the nil string must be used as the second argument.  The cursor position remains unchanged when there is no previous BOL.


This is the local version of Memory.prev.line. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.read.chars</name>
    <act>Y</act>
    <stx>@Local.memory.read.chars(memoryHandle,size)</stx>
    <dsc>Reads a string of the designated size from the memory object.</dsc>
    <code>#(.LC)mR[@1,@2]</code>
    <cmt>Reads a string of the designated size from the [memoryHandle] from the current cursor position.  The cursor is moved past the read.


This is the local version of Memory.read.chars. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.read.field</name>
    <act>Y</act>
    <stx>@Local.memory.read.field(memoryHandle,length{,char})</stx>
    <dsc>Searches [memoryHandle] until it finds specified [char] or reaches [length]</dsc>
    <code>#(.LC)mr[@1,@2&quot;_IF{S[3] &quot;,@3&quot;}_&quot;]</code>
    <cmt>Searches the [memoryHandle] buffer from the current MemCursor position until it finds the specified [char] or reaches [length], whichever comes first.  Returns the bytes in between.
If the [char] is found, the MemCursor is left pointing to it.  If length is 0, the search continues to the High Water Mark of the buffer.  If [char] is not specified, the search will stop at any character &lt;32 or &gt;127.

NOTE: The return value from this function is NOT limited to 256 characters, so beware.


This is the local version of Memory.read.field. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.read.line</name>
    <act>Y</act>
    <stx>@Local.memory.read.line(memoryHandle,maxLength)</stx>
    <dsc>Treats the contents of the memory object as a text stream and reads one line.</dsc>
    <code>#(.LC)mL[@1,@2]</code>
    <cmt>Formatted Line read:  treats the contents of the memory object as a text stream, and reads a line&apos;s worth of characters stopping on the space character closest to but not exceeding the [maxLength] parameter.

Carriage Return characters embedded in the text stream are treated as hard Line Breaks and are preserved.

This is the local version of Memory.read.line. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.read.text</name>
    <act>Y</act>
    <stx>@Local.memory.read.text(memoryHandle)</stx>
    <dsc>Treats the contents of the memory object as a .TXT file, and reads to next &lt;CR&gt;</dsc>
    <code>#(.LC)mQ[@1]</code>
    <cmt>Text read:  treats the contents of the memory object as a .TXT file, and reads up to the next CR character and returns the value stripped of control characters.


This is the local version of Memory.read.text. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.replace</name>
    <act>Y</act>
    <stx>@Local.memory.replace(memoryHandle,value,replNum)</stx>
    <dsc>Inserts [value] into [memoryHandle] replacing [replNum] existing characters</dsc>
    <code>@2^#(.LC)mI[@1,@3]</code>
    <cmt>Inserts the value into the memory object at the current cursor position, replacing [replNum] existing characters and shifting the contents at the current cursor position up to make room for a larger value or back to fill in after a smaller value, and moves the cursor to the end of the value.

If the memory object is too small to contain the new value, the memory object is expanded.
If [value] = NIL then delete [replNum] characters, inserting nothing.
If [replNum] = 0 then insert only, replacing nothing.



This is the local version of Memory.replace. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.search</name>
    <act>Y</act>
    <stx>@Local.memory.search(memoryHandle,csFlag,string)</stx>
    <dsc>Search for [string] in the memory object</dsc>
    <code>#(.LC)mS[@1,@2,@3]</code>
    <cmt>Search for [string] in the memory object, starting at the current cursor position, and return the new cursr position of the string if found.  If not found, return NIL and do not move the cursor.

If [csFlag] = 0 then A=a, else the search is case-sensitive.



This is the local version of Memory.search. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.set.cursor</name>
    <act>Y</act>
    <stx>@Local.memory.set.cursor(memoryHandle,number)</stx>
    <dsc>Sets the cursor position.</dsc>
    <code>#(.LC)mZ[@1,@2]</code>
    <cmt>This is the local version of Memory.set.cursor. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.store.file</name>
    <act>Y</act>
    <stx>@Local.memory.store.file(memoryHandle,UNCName)</stx>
    <dsc>Stores the contents of the buffer in the specified file.</dsc>
    <code>#(.LC)mt[@1,@2]</code>
    <cmt>This is symmetrical with @Memory.load.file which reads from a file.

Returns:
  &quot;&quot; - Success
  Oxxxx - unable to open the file, does not have to exist it will be created for you by #mt
  Wxxxx - unable to write file
  Cxxxx - unable to close file handle


This is the local version of Memory.store.file. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.strip.spaces</name>
    <act>Y</act>
    <stx>@Local.memory.strip.spaces(memoryHandle)</stx>
    <dsc>Strip leading and trailing spaces from &lt;CRLF&gt; delimited text in [memoryHandle]</dsc>
    <code>#(.LC)ms[@1]</code>
    <cmt>Strip leading and trailing spaces from the &lt;CRLF&gt; delimited text in the memory buffer.  No return.


This is the local version of Memory.strip.spaces. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.text.read</name>
    <act>Y</act>
    <stx>@Local.memory.text.read(memoryHandle,maxLength)</stx>
    <dsc>Treats the contents of the memory object as a text stream, and reads one line.</dsc>
    <code>#(.LC)mL[@1,@2]</code>
    <cmt>Formatted Line read:  treats the contents of the memory object as a text stream, and reads a line&apos;s worth of characters stopping on the space character closest to but not exceeding the maxLength parameter.

Carriage Return characters embedded in the text stream are treated as hard Line Breaks and are preserved.

NOTE:  This is identical to @Memory.read.line.

This is the local version of Memory.text.read. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.usage</name>
    <act>Y</act>
    <stx>@Local.memory.usage(memoryHandle)</stx>
    <dsc>Returns the number of bytes allocated and number of bytes used</dsc>
    <code>#(.LC)mU&quot;_IF{S[1] &quot;[@1]&quot;}_&quot;</code>
    <cmt>returns:
  {allocated bytes, used bytes}

If a specific memoryHandle is specificed then the information returned is specific to that memoryHandle.  Otherwise the information returned regards all memoryHandles.


This is the local version of Memory.usage. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Local.memory.write</name>
    <act>Y</act>
    <stx>@Local.memory.write(memoryHandle,value)</stx>
    <dsc>Writes the [value] to the memory object at the current cursor position.</dsc>
    <code>&quot;_IF{S[2] &quot;@2^&quot;}_&quot;#(.LC)mW[@1]</code>
    <cmt>Writes the value to the memory object at the current cursor position, and moves the cursor to the end of the value.  If the memory object is too small to contain the new value, the memory object is expanded.


This is the local version of Memory.write. In 3tier, the operation will execute on the app server. In 2tier, the operation will execute on the client.</cmt>
  </macro>
  <macro>
    <name>Lock</name>
    <act>Y</act>
    <stx>@Lock(node[,lockExists,lockIsMine,waitMessage,lockDuration])</stx>
    <dsc>Writes a lock for [node].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..locks(^S)_&quot;</code>
    <cmt>[node] = the node to lock

[lockExists] = NON-NIL -&gt; If the lock exists, do not check to see if the &quot;owner&quot; is alive                         (default is to check)

[lockIsMine] = NON-NIL -&gt; If the lock exists and belongs to this user, do not update the                          lock (default is to update)

[waitMessage] = 0 no &quot;waiting&quot; message
              = 1 Normal Message

[lockDuration] = Time in minutes that a lock can not expire since last update (default 30                     min).

%Z.lock only returns after the lock has been written successfully.  If it cannot write the lock, it will hang until it can.

Lock&apos;s value is: {@NN,job,date,seconds,user,job_table_urn,client_dx_thread_address}, which is returned by @Locked.

For general information on locks, see Locks document on the Intranet.

Z.lock.msg = Optional line near top of message.
The Z.lock.msg is only looked at by the locking system.  It will not modify it in anyway.

NOTE:  To write locks as was done in MAGIC, set [lockExists] and [lockIsMine] to NON-NIL and [waitMessage] equal to 0.
</cmt>
  </macro>
  <macro>
    <name>Lock.created</name>
    <act>Y</act>
    <stx>@Lock.created(node)</stx>
    <dsc>Checks to see if the process has a record of the lock.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..locks(^S)_&quot;</code>
    <cmt>Checks @locks to see if the lock was created by this process.

Returns the value of the lock if it is found in @locks.
</cmt>
  </macro>
  <macro>
    <name>Lock.is.not.mine</name>
    <act>Y</act>
    <stx>@Lock.is.not.mine(node)</stx>
    <dsc>Removes knowledge of lock from this process</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..locks(^S)_&quot;</code>
    <cmt>Returns value if the lock tracking was cleared.

Also changes the PID of the lock INFO to TAKEOVER.  This will be replaced by @Lock.takeover with the new jobs PID.</cmt>
  </macro>
  <macro>
    <name>Lock.takeover</name>
    <act>Y</act>
    <stx>@Lock.takeover(node,mac)</stx>
    <dsc>Takes over a lock from another process specified by arg B</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..locks(^S)_&quot;</code>
    <cmt>[node] = the node to takeover

mac =  Original Client that owned the lock.

Returns True if success, false if failure.  Failure can happen if the lock&apos;s original owner is not what is in Arg B.

Use @Lock.is.not.mine to setup a lock to be taken over by this macro.
Lock.takeover expects the PID node of the lock INFO to be TAKEOVER.
If a lock ends up in the MIS Error Log with TAKEOVER for PID then a job did not take over the lock.
</cmt>
  </macro>
  <macro>
    <name>Locked</name>
    <act>Y</act>
    <stx>@Locked(node[,lockExists,lockPreemptMode])</stx>
    <dsc>Checks to see if a lock exists on [node] and returns its value if it does.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..locks(^S)_&quot;</code>
    <cmt>[lockExists]  = Ignored   (default is to NOT check to see if a lock expired)

[lockPreemptMode] =  1   Then ask the user if they want to preempt a lock that
                        has expired.  (Perferred value)

                  =  2   Expired locks are preempted automaticly.

Lock is set by @Lock.

Z.lock.msg = Optional line near top of message.
The Z.lock.msg is only looked at by the locking system.  It will not modify it in anyway.


For general information on locks, see Locks document on the Intranet.

</cmt>
  </macro>
  <macro>
    <name>Locked.child</name>
    <act>Y</act>
    <stx>@Locked.child(node[,lockExists])</stx>
    <dsc>Checks to see if a lock exists on [node] or any subscripts below [node].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..locks(^S)_&quot;</code>
    <cmt>[lockExists] = NON-NIL -&gt;  Do not check to see if the job which owns the lock is alive                         (default is to check)

Checks to see if a lock exists on node or any subscripts below node and returns the value of the first such lock if any exist.

If there is a lock and the lock has expired, the user is asked if they want to preempt those locks, if so, the lock(s) are cleared (unless [lockExists] is NON-NIL, in which case the check is not made).

Lock is set by @Lock.  Similar to @Locked.

Z.lock.msg = Optional line near top of message.
The Z.lock.msg is only looked at by the locking system.  It will not modify it in anyway.

For general information on locks, see Locks document on the Intranet.

</cmt>
  </macro>
  <macro>
    <name>Locked.msg</name>
    <act>Y</act>
    <stx>@Locked.msg(@segment)</stx>
    <dsc>Translates to call to %Z.lock.msg which displays a message if @segment is locked</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..locks(^S)_&quot;</code>
    <cmt>Translates to a call to %Z.lock.msg which displays a message if [@segment] is locked. Returns TRUE if no lock (no message display); else NIL and message is displayed.

Z.lock.msg = Optional line near top of message.
The Z.lock.msg is only looked at by the locking system.  It will not modify it in anyway.
</cmt>
  </macro>
  <macro>
    <name>Locked.multi</name>
    <act>Y</act>
    <stx>@Locked.multi(listOfNodes[,lockExists])</stx>
    <dsc>Check to see if any locks in the list exist.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..locks(^S)_&quot;</code>
    <cmt>listOfNodes =  lock nodes to check (multiple by value)

[lockExists] = NON-NIL -&gt;  Do not check to see if the job which owns the lock is alive                         (default is to check)

If there is a lock and the lock has expired, the user is asked if they want to preempt those locks, if so, the lock(s) are cleared (unless [lockExists] is NON-NIL, in which case the check is not made).

Lock is set by @Lock.  Similar to @Locked.

Z.lock.msg = Optional line near top of message.
The Z.lock.msg is only looked at by the locking system.  It will not modify it in anyway.

For general information on locks, see Locks document on the Intranet.
 </cmt>
  </macro>
  <macro>
    <name>Locks.renew</name>
    <act>Y</act>
    <stx/>
    <dsc>Renews the time based locks if they are over 10 mins old.</dsc>
    <code>%(Z)lock.renew(&quot;_D(34,34)_&quot;)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Locks.validate</name>
    <act>Y</act>
    <stx/>
    <dsc>Validates that the locks the process owns it still has.</dsc>
    <code>%(Z)lock.validate(&quot;_D(34,34)_&quot;)</code>
    <cmt>Returns True if any locks are no longer owned.
</cmt>
  </macro>
  <macro>
    <name>Log.patient.event</name>
    <act>Y</act>
    <stx/>
    <dsc>Files one patient event to the Patient Activity Log</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..functions(^S)_&quot;</code>
    <cmt>A = MIS.AUDIT.REC DPM
B = MIS.AUDIT.REC URN
C = Action - (C)reated,(M)odified,(D)eleted,(P)rinted,(E)xported,(V)iewed
D = Description -  NOT USED in 5.x.
E = Description Override
F = Output Device/Path (Optional - used only for Print Actions)
G = Time Override
H = Application Argument for %Z.user.activity - can be packed data

Example:  @Log.patient(&quot;ADM.PAT&quot;,ADM.PAT.urn,&quot;M&quot;,DESC)</cmt>
  </macro>
  <macro>
    <name>Log.patient.event.bch.add</name>
    <act>Y</act>
    <stx/>
    <dsc>Adds an entry to a batch of patient events in @Z.patient.events</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..functions(^S)_&quot;</code>
    <cmt>A = MIS.AUDIT.REC DPM
B = MIS.AUDIT.REC URN
C = Action - (C)reated,(M)odified,(D)eleted,(P)rinted,(E)xported,(V)iewed
D = Description -  NOT USED in 5.x.
E = Description Override
F = Output Device/Path (Optional - used only for Print Actions)
G = Time Override
H = Application Argument for %Z.user.activity - can be packed data

Example:  @Log.patient.event.bch.add(&quot;ADM.PAT&quot;,ADM.PAT.urn,&quot;M&quot;,DESC)
</cmt>
  </macro>
  <macro>
    <name>Log.patient.event.bch.write</name>
    <act>Y</act>
    <stx/>
    <dsc>Writes a batch of patient events to the Patient Activity Log</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..functions(^S)_&quot;</code>
    <cmt>No arguments</cmt>
  </macro>
  <macro>
    <name>Logon.domain</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns logon user&apos;s domain</dsc>
    <code>#D[5]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Logon.user</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns current logon user</dsc>
    <code>#UN</code>
    <cmt/>
  </macro>
  <macro>
    <name>MAPI.address</name>
    <act>Y</act>
    <stx>@MAPI.address(sessionID,caption,editFields,label,recipients,memoryHandle)</stx>
    <dsc>Select recipients for MAPI messages.  Displays a DialogBox for the selection.</dsc>
    <code>#qA[@1,&quot;_IF{S[2];D(34,34)}_&quot;,&quot;_IF{S[3];D(34,34)}_&quot;,@4,@5,@6]</code>
    <cmt>[caption]
The Window title of the DialogBox.  May be NIL, in which case Windows supplies &quot;Address Book&quot;.

[editFields]
The number of boxes for recipient categories in the DialogBox:
  0      No recipients may be selected.  Use only for browsing the address list.
  1 - 2  Fields for the recipient classes (Primary,Copy,BlindCopy).
  4      A field for each recipient class supported by the underlying messaging system.

[label]
String to be used for the EditField if-and-only-if is one such field.

[recipients]
The number of RecipientDescription structures on entry.

[memoryHandle]
The handle of a buffer which contains initial RecipDesc entries upon calling the function and final entries upon return.  The size of this buffer is managed internally so it will be big enough to contain the answers.
</cmt>
  </macro>
  <macro>
    <name>MAPI.logoff</name>
    <act>Y</act>
    <stx>@MAPI.logoff(sessionID)</stx>
    <dsc>Log off the MAPI system.</dsc>
    <code>#qX[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>MAPI.logon</name>
    <act>Y</act>
    <stx>@MAPI.logon(name,password,flag)</stx>
    <dsc>Log on to the MAPI system. Returns a sessionID for use in other MAPI functions.</dsc>
    <code>#qL[@1,@2,@3]</code>
    <cmt>[flag] indicates whether a DialogBox should be displayed for ambiguous or incorrect names.</cmt>
  </macro>
  <macro>
    <name>MAPI.merge</name>
    <act>Y</act>
    <stx>@MAPI.merge(#recips,recipMemBuf1,#recips,recipMemBuf2)</stx>
    <dsc>Merge recipient lists in [recipMemBuf1] and [recipMemBuf2] into [recipMemBuf1]</dsc>
    <code>#qM[@1,@2,@3,@4]</code>
    <cmt>Merge the recipient lists in [recipMemBuf1] and [recipMemBuf2].  Put the merged list in [recipMemBuf1].  The return value is the number of recipients in the newly merged list.</cmt>
  </macro>
  <macro>
    <name>MAPI.resolve</name>
    <act>Y</act>
    <stx>@MAPI.resolve(sessionID,recipMemBuf,name)</stx>
    <dsc>Create a RecipDesc structure in the [recipMemBuf] from the [name] supplied</dsc>
    <code>#qR[@1,@2,@3]</code>
    <cmt>The return value is &quot;1&quot; if successful, else NIL.</cmt>
  </macro>
  <macro>
    <name>MAPI.send.mail</name>
    <act>Y</act>
    <stx>@MAPI.send.mail(sessionID,subj,recips,recipMemHandle,textMemHandle[,dialog])</stx>
    <dsc>Send MAPI mail.</dsc>
    <code>#qS[@1,@2,@3,@4,@5,@6]</code>
    <cmt>[dialog] - if = 0, do not display a dialog (if [recips] is empty, dialog always displays)
              &gt;0 display dialog box
</cmt>
  </macro>
  <macro>
    <name>MGUI.buffer.exec</name>
    <act>Y</act>
    <stx>@MGUI.buffer.exec(Memory buffer handle)</stx>
    <dsc>Takes a Memory buffer and passes it to MGUI.DLL to be displayed/executed</dsc>
    <code>#mx[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>MGUI.dll.unload</name>
    <act>Y</act>
    <stx/>
    <dsc>Unloads MGUI.DLL.  Returns True if the DLL is unloaded.</dsc>
    <code>#mu</code>
    <cmt/>
  </macro>
  <macro>
    <name>MGUI.execute</name>
    <act>Y</act>
    <stx>@MGUI.execute(Lite List)</stx>
    <dsc>Sends a lite list of commands to the MGUI.DLL</dsc>
    <code>#my[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>MGUI.get.error</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns error message if the MGUI.DLL caused a debugger event.</dsc>
    <code>#zE</code>
    <cmt/>
  </macro>
  <macro>
    <name>MGUI.is.open</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns True if MGUI.DLL has a window open.</dsc>
    <code>#zW</code>
    <cmt/>
  </macro>
  <macro>
    <name>MGUI.read</name>
    <act>Y</act>
    <stx/>
    <dsc>Reads results from MGUI.DLL functions that are queries.</dsc>
    <code>#z</code>
    <cmt/>
  </macro>
  <macro>
    <name>MSO.Connect</name>
    <act>Y</act>
    <stx/>
    <dsc>connect to mso server</dsc>
    <code>@Uc</code>
    <cmt/>
  </macro>
  <macro>
    <name>MSO.Disconnect</name>
    <act>Y</act>
    <stx/>
    <dsc>disconnect from mso server</dsc>
    <code>@Ud</code>
    <cmt/>
  </macro>
  <macro>
    <name>Machine</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the name of the machine to which the # prefix is pointed</dsc>
    <code>#NN</code>
    <cmt>Same as @.device/@.machine.
</cmt>
  </macro>
  <macro>
    <name>Macro</name>
    <act>Y</act>
    <stx>@Macro(macro.name)</stx>
    <dsc>Brings in the translated code of a macro into procedure logic.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..functions(^S)_&quot;</code>
    <cmt>@Macro(macro.name) or @Macro(proc.name.M.macro.name) or @Macro(dpm.name.proc.name.M.macro.name)

Use the arguments as follows:

*  If the macro you wish to call is in the same procedure as the procedure logic, simply        specify the macro name as the argument.

*  If the macro you wish to call is in a different procedure, but in the same DPM as the        procedure logic, specify procedure.name.M.macro.name as the argument.

*  If the macro you wish to call is in a different DPM, you must specify the                    DPM.proc.name.M.macro.name as the argument.
</cmt>
  </macro>
  <macro>
    <name>Magic.SSL</name>
    <act>Y</act>
    <stx/>
    <dsc>Return true if the csmagic.exe in use is the SSL encryption client.</dsc>
    <code>(@Tv&gt;104)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Magic.TCP</name>
    <act>Y</act>
    <stx/>
    <dsc>Return true if the vmagic.exe running is a TCP based executable.</dsc>
    <code>(@Tv&gt;100)</code>
    <cmt>Used for transition of thread code from UDP based vmagic.exe to TCP vmagic.exe.</cmt>
  </macro>
  <macro>
    <name>Magic.assembly.date</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the date/time stamp of the interpreter/database portion of VMagic.exe</dsc>
    <code>@VN</code>
    <cmt/>
  </macro>
  <macro>
    <name>Magic.server.alive</name>
    <act>Y</act>
    <stx/>
    <dsc>Tests to see if the VMagic service is running on a particular server.</dsc>
    <code>@MA</code>
    <cmt>Takes no argument, but by default it talks to the server you most recently talked to.

To test a specificserver, you must first use the @Net.to (@NT) function, i.e.address@NT,@MA returns the machine name if successful, nil otherwise.
</cmt>
  </macro>
  <macro>
    <name>Make.error</name>
    <act>Y</act>
    <stx/>
    <dsc>Induce a Magic error.</dsc>
    <code>@ME</code>
    <cmt/>
  </macro>
  <macro>
    <name>Make.long</name>
    <act>Y</act>
    <stx>@Make.long(low.word,high.word)</stx>
    <dsc>Makes a long word address out of word addresses [low.word] and [high.word].</dsc>
    <code>@2*65536+(@1)</code>
    <cmt>Used in graphing commands.</cmt>
  </macro>
  <macro>
    <name>Math.abs</name>
    <act>Y</act>
    <stx>@Math.abs(arg)</stx>
    <dsc>Calculate the absolute value of [arg].</dsc>
    <code>%(Z)math(&quot;_D(34)_&quot;ABS&quot;_D(34)_&quot;,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.alog</name>
    <act>Y</act>
    <stx>@Math.alog(arg)</stx>
    <dsc>Calculate the antilog of [arg].</dsc>
    <code>%(Z)math(&quot;_D(34)_&quot;ALOG&quot;_D(34)_&quot;,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.calc</name>
    <act>Y</act>
    <stx>@Math.calc(&quot;&quot;)</stx>
    <dsc>Invoke the Windows calculator.</dsc>
    <code>#C[&quot;_D(34)_&quot;CALC.EXE&quot;_D(34)_&quot;,1,1,0]&amp;&quot;_D(34,34)_&quot;</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.cos</name>
    <act>Y</act>
    <stx>@Math.cos(arg)</stx>
    <dsc>Calculate the cosine of [arg].</dsc>
    <code>%(Z)math(&quot;_D(34)_&quot;COS&quot;_D(34)_&quot;,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.cot</name>
    <act>Y</act>
    <stx>@Math.cot(arg)</stx>
    <dsc>Calculate the cotangent of arg.</dsc>
    <code>%(Z)math(&quot;_D(34)_&quot;COT&quot;_D(34)_&quot;,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.csc</name>
    <act>Y</act>
    <stx>@Math.csc(arg)</stx>
    <dsc>Calculate the cosecant of [arg].</dsc>
    <code>%(Z)math(&quot;_D(34)_&quot;CSC&quot;_D(34)_&quot;,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.deg</name>
    <act>Y</act>
    <stx>@Math.deg(radians)</stx>
    <dsc>Convert [radians] to degrees.</dsc>
    <code>(57.2958*@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.e</name>
    <act>Y</act>
    <stx/>
    <dsc>Translates to the value of e.</dsc>
    <code>2.71828182845906</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.exp</name>
    <act>Y</act>
    <stx>@Math.exp(arg)</stx>
    <dsc>Calculate the value of e to the power arg.</dsc>
    <code>%(Z)math(&quot;_D(34)_&quot;EXP&quot;_D(34)_&quot;,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.int</name>
    <act>Y</act>
    <stx>@Math.int(arg)</stx>
    <dsc>Calculate the integer portion of [arg].</dsc>
    <code>(@1+&quot;_D(34,34)_&quot;#.)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.ln</name>
    <act>Y</act>
    <stx>@Math.ln(arg)</stx>
    <dsc>Calculate the natural log of arg.</dsc>
    <code>%(Z)math(&quot;_D(34)_&quot;LN&quot;_D(34)_&quot;,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.log</name>
    <act>Y</act>
    <stx>@Math.log(arg)</stx>
    <dsc>Calculate the log of [arg].</dsc>
    <code>%(Z)math(&quot;_D(34)_&quot;LOG&quot;_D(34)_&quot;,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.pi</name>
    <act>Y</act>
    <stx>@Math.pi(&quot;&quot;)</stx>
    <dsc>Translates to the value of pi.</dsc>
    <code>3.14159265</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.power</name>
    <act>Y</act>
    <stx>@Math.power(arg1,arg2)</stx>
    <dsc>Calculate the value of [arg1] raised to the power of [arg2].</dsc>
    <code>%(Z)math(&quot;_D(34)_&quot;POWER&quot;_D(34)_&quot;,@1,@2)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.rad</name>
    <act>Y</act>
    <stx>@Math.rad(degrees)</stx>
    <dsc>Convert [degrees] to radians.</dsc>
    <code>(0.01745*@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.sec</name>
    <act>Y</act>
    <stx>@Math.sec(arg)</stx>
    <dsc>Calculate the secant of [arg].</dsc>
    <code>%(Z)math(&quot;_D(34)_&quot;SEC&quot;_D(34)_&quot;,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.sin</name>
    <act>Y</act>
    <stx>@Math.sin(arg)</stx>
    <dsc>Calculate the sin of [arg].</dsc>
    <code>%(Z)math(&quot;_D(34)_&quot;SIN&quot;_D(34)_&quot;,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.sqrt</name>
    <act>Y</act>
    <stx>@Math.sqrt(arg)</stx>
    <dsc>Calculate the square root of [arg].</dsc>
    <code>%(Z)math(&quot;_D(34)_&quot;SQRT&quot;_D(34)_&quot;,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Math.tan</name>
    <act>Y</act>
    <stx>@Math.tan(arg)</stx>
    <dsc>Calculate the tangent of [arg].</dsc>
    <code>%(Z)math(&quot;_D(34)_&quot;TAN&quot;_D(34)_&quot;,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Max</name>
    <act>Y</act>
    <stx>@Max(arg1,arg2)</stx>
    <dsc>Returns the maximum of [arg1] and [arg2].</dsc>
    <code>&quot;_IF{IF{S&apos;=2 %NPRLER(&quot;FN&quot;,S[0])},&quot;(@1!(@2))&quot;}_&quot;</code>
    <cmt/>
  </macro>
  <macro>
    <name>Memory.allocate</name>
    <act>Y</act>
    <stx>@Memory.allocate(numKbytes)</stx>
    <dsc>Allocates a memory object of [numKbytes].  Returns the memoryHandle.</dsc>
    <code>#mA&quot;_IF{S[1]&apos;=D(34,34)&apos;=0 &quot;[@1]&quot;}_&quot;</code>
    <cmt>[numKbytes] specifies the number of 1024-byte chunks to be allocated as the base size of this object.  For example @Memory.allocate(1) will allocate a memory object of 1024 bytes. The argument is optional, and @Memory.alloc(&quot;&quot;) allocates 4K bytes (4096) as its base size.</cmt>
  </macro>
  <macro>
    <name>Memory.beginning</name>
    <act>Y</act>
    <stx>@Memory.beginning(memoryHandle)</stx>
    <dsc>Moves the cursor to the beginning of the memory object.</dsc>
    <code>#mB[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Memory.clear</name>
    <act>Y</act>
    <stx>@Memory.clear(memoryHandle)</stx>
    <dsc>Clears the specified memoryHandle</dsc>
    <code>#mX[@1]</code>
    <cmt>Clears the specified memoryHandle buffer.</cmt>
  </macro>
  <macro>
    <name>Memory.compare</name>
    <act>Y</act>
    <stx>@Memory.compare(BufferID,BufferID)</stx>
    <dsc>Compare the two buffers byte-for-byte.</dsc>
    <code>#mK[@1,@2]</code>
    <cmt>If there is a discrepancy, the function returns the byte offset where the difference appeared; otherwise it returns NIL.</cmt>
  </macro>
  <macro>
    <name>Memory.copy</name>
    <act>Y</act>
    <stx>@Memory.copy(bufferID,bufferID,toCopy,toReplace)</stx>
    <dsc>Copy from one buffer to another, at the cursor position(s).  No return.</dsc>
    <code>#mc[@1,@2,@3,@4]</code>
    <cmt>[toCopy] indicates the number of bytes to copy; -1 means ToEndOfBuffer

[toReplace] indicates the number of bytes to replace; -1 means ToEndOfBuffer

@Memory.beginning(0),@Memory.beginning(1),
@Memory.copy(0,1,&quot;-1&quot;,&quot;-1&quot;) copies all the bytes from buffer 0 to buffer 1, replacing the entire contents.
</cmt>
  </macro>
  <macro>
    <name>Memory.cursor.pos</name>
    <act>Y</act>
    <stx>@Memory.cursor.pos(memoryHandle)</stx>
    <dsc>Returns the current cursor position.</dsc>
    <code>#mC[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Memory.defined</name>
    <act>Y</act>
    <stx>@Memory.defined(memoryHandle)</stx>
    <dsc>Returns 0 if [memoryHandle] is an existing buffer, NIL if not.</dsc>
    <code>#ma[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Memory.end</name>
    <act>Y</act>
    <stx>@Memory.end(memoryHandle)</stx>
    <dsc>Moves the cursor to the end of the memory object.</dsc>
    <code>#mE[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Memory.extract</name>
    <act>Y</act>
    <stx>@Memory.extract(Buffer,ListStartChar,Field)^{FieldStartChar,Length}</stx>
    <dsc>Finds the start character and length of a FS list field in a memory buffer</dsc>
    <code>#me[@1,@2,@3]</code>
    <cmt>Buffer
     Handle to the #-based memory buffer containing the FS list of interest.

ListStartChar
     Character offset within Buffer (first character is 0) at which FS list of interest
     starts.  Can be a sublist at any nesting depth.

Field
     Offset of field of interest (first field is 0) within FS list defined by ListStartChar.

FieldStartChar
     Character offset within Buffer at which field of interest starts.

Length
     Length, in bytes, of field of interest.

Examples:  in the following FS list, contained within buffer MH...

{&quot;One&quot;|{&quot;TwoA&quot;|&quot;TwoB&quot;|&quot;TwoC&quot;}|&quot;Three&quot;}

@Memory.extract(MH,0,1) would return {5,16}, indicating that in the very outermost list (starting at character 0), field #1 starts at character #5 in the buffer, and extends for a length of 16.  Since the contents of this field are another sublist, the results of the first extraction can be used to target a field inside the nested list...

@Memory.extract(MH,0,1)^{SUB,LEN},
@Memory.extract(MH,SUB,2)^{FLD,LEN}

These returned values can then be used to extract the actual data value from field #2 of the sublist...

@Memory.set.cursor(MH,FLD),
@Memory.read.chars(MH,LEN)^VALUE</cmt>
  </macro>
  <macro>
    <name>Memory.free</name>
    <act>Y</act>
    <stx>@Memory.free(memoryHandle)</stx>
    <dsc>Deallocates (frees) a memory object.</dsc>
    <code>#mF[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Memory.get</name>
    <act>Y</act>
    <stx>@Memory.get(memoryHandle,globalAddress,numBytes)</stx>
    <dsc>Copy [numBytes] bytes from [globalAddress] into the [memoryHandle].</dsc>
    <code>#mG[@1,@2,@3]</code>
    <cmt>Copy [numBytes] bytes from [globalAddress] into the [memoryHandle] buffer at the current cursor position.  Returns [numBytes] if successful; NIL if not.

Resets the HighWaterMark and Cursor to the end of the new data.  [globalAddress] is based on the address returned by the @Global.alloc function.
</cmt>
  </macro>
  <macro>
    <name>Memory.get.bytes</name>
    <act>Y</act>
    <stx>@Memory.get.bytes(memoryHandle,start,length{,char})</stx>
    <dsc>Searches the [memoryHandle] buffer from the [start] byte for [char]</dsc>
    <code>#mg[@1,@2,@3&quot;_IF{S[4] &quot;,@4&quot;}_&quot;]</code>
    <cmt>Searches the [memoryHandle] buffer from the [start] byte until it finds the specified [char] or reaches [length], whichever comes first.  Returns the bytes in between.

Behaves much like @Memory.read.field with the following exceptions:  The search begins at [start] byte rather than at the current MemCursor position.  The search length is not limited to the High Water Mark of the buffer, but instead is only bounded by the allocated size of the buffer.  If [char] is not specified, the search returns length bytes regardless of what they are.

NOTE: The return value from this function is NOT limited to 256 characters, so beware.

If [length] = 0, this function will return the entire contents of the allocated buffer, regardless of the high water mark.

</cmt>
  </macro>
  <macro>
    <name>Memory.lite.locate</name>
    <act>Y</act>
    <stx>@Memory.lite.locate(membuff,list start,element)</stx>
    <dsc>Finds element pos and length in buffer</dsc>
    <code>#me[@1,@2,@3]</code>
    <cmt>Returns {pos,length}

This function will find the beginning of a element in a lite list and return the length of it.
</cmt>
  </macro>
  <macro>
    <name>Memory.lite.to.bmp</name>
    <act>Y</act>
    <stx>@Memory.lite.to.bmp(memoryHandle)</stx>
    <dsc>Convert [memoryHandle] from EMR-style picture to a .bmp.</dsc>
    <code>#mH[@1]</code>
    <cmt>Returns the number of bytes in the new format if successful; NIL if not.</cmt>
  </macro>
  <macro>
    <name>Memory.load.file</name>
    <act>Y</act>
    <stx>@Memory.load.file(memoryHandle,UNVName)</stx>
    <dsc>Loads a memory buffer with the file referenced by UNVName.</dsc>
    <code>#mT[@1,@2]</code>
    <cmt>Return Values:
        &quot;&quot; = Ok.
     Value = ErrorLetter_ErrorNumber
             Value#0=&quot;C&quot; - Close File Failed.
             Value#0=&quot;M&quot; - Allocating Memory Failed.
             Value#0=&quot;O&quot; - Open Fail Failed.
             Value#0=&quot;R&quot; - Read File Failed.
             Value#0=&quot;S&quot; - Get File Size Failed.</cmt>
  </macro>
  <macro>
    <name>Memory.magicdll.to.buffer</name>
    <act>Y</act>
    <stx/>
    <dsc>Converts the magic dll or magic exe&apos;s data stack to a memory buffer</dsc>
    <code>#mJ[@JS#0P,@JS#1P]</code>
    <cmt>Returns a memory buffer number.

Do not do a Memory.free on this buffer.</cmt>
  </macro>
  <macro>
    <name>Memory.map.global.alloc</name>
    <act>Y</act>
    <stx>@Memory.map.global.alloc(point,extent)</stx>
    <dsc>Maps Global alloc memory to the TERM Memory commands</dsc>
    <code>#mJ[@1,@2]</code>
    <cmt>Returns memory buffer number.

@Memory.free will remove the memory buffer without affecting the Gobal.alloc buffer it was pointed to.</cmt>
  </macro>
  <macro>
    <name>Memory.more</name>
    <act>Y</act>
    <stx>@Memory.more(memoryHandle)</stx>
    <dsc>Is the cursor at the end of the memory object?  Returns D(127) or Nil.</dsc>
    <code>#mM[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Memory.next.line</name>
    <act>Y</act>
    <stx>@Memory.next.line(memoryHandle[,WordWrapWidth])</stx>
    <dsc>Updates the cursor and returns the next beginning-of-line (BOL) position</dsc>
    <code>#mN[@1,@2]</code>
    <cmt>Updates the cursor and returns the next beginning-of-line (BOL) position relative to the current position.

If the text is formatted with automatic word wrap, then the line width in characters must be provided as a second argument.  Otherwise, if hard carriage returns delineate the lines of text, then the nil string must be used as the second argument.  The cursor position remains unchanged when there is no next BOL.
</cmt>
  </macro>
  <macro>
    <name>Memory.prev.line</name>
    <act>Y</act>
    <stx>@Memory.prev.line(memoryHandle[,WordWrapWidth])</stx>
    <dsc>Updates the cursor and returns the previous beginning-of-line (BOL) position.</dsc>
    <code>#mP[@1,@2]</code>
    <cmt>Updates the cursor and returns the previous beginning-of-line (BOL) position relative to the current cursor position.

If the text is formatted with automatic word wrap, then the line width in characters must be provided as a second argument.  Otherwise, if hard carriage returns delineate the lines of text, then the nil string must be used as the second argument.  The cursor position remains unchanged when there is no previous BOL.
</cmt>
  </macro>
  <macro>
    <name>Memory.read.chars</name>
    <act>Y</act>
    <stx>@Memory.read.chars(memoryHandle,size)</stx>
    <dsc>Reads a string of the designated size from the memory object.</dsc>
    <code>#mR[@1,@2]</code>
    <cmt>Reads a string of the designated size from the [memoryHandle] from the current cursor position.  The cursor is moved past the read.</cmt>
  </macro>
  <macro>
    <name>Memory.read.field</name>
    <act>Y</act>
    <stx>@Memory.read.field(memoryHandle,length{,char})</stx>
    <dsc>Searches [memoryHandle] until it finds specified [char] or reaches [length]</dsc>
    <code>#mr[@1,@2&quot;_IF{S[3] &quot;,@3&quot;}_&quot;]</code>
    <cmt>Searches the [memoryHandle] buffer from the current MemCursor position until it finds the specified [char] or reaches [length], whichever comes first.  Returns the bytes in between.
If the [char] is found, the MemCursor is left pointing to it.  If length is 0, the search continues to the High Water Mark of the buffer.  If [char] is not specified, the search will stop at any character &lt;32 or &gt;127.

NOTE: The return value from this function is NOT limited to 256 characters, so beware.

</cmt>
  </macro>
  <macro>
    <name>Memory.read.line</name>
    <act>Y</act>
    <stx>@Memory.read.line(memoryHandle,maxLength)</stx>
    <dsc>Treats the contents of the memory object as a text stream and reads one line.</dsc>
    <code>#mL[@1,@2]</code>
    <cmt>Formatted Line read:  treats the contents of the memory object as a text stream, and reads a line&apos;s worth of characters stopping on the space character closest to but not exceeding the [maxLength] parameter.

Carriage Return characters embedded in the text stream are treated as hard Line Breaks and are preserved.
</cmt>
  </macro>
  <macro>
    <name>Memory.read.text</name>
    <act>Y</act>
    <stx>@Memory.read.text(memoryHandle)</stx>
    <dsc>Treats the contents of the memory object as a .TXT file, and reads to next &lt;CR&gt;</dsc>
    <code>#mQ[@1]</code>
    <cmt>Text read:  treats the contents of the memory object as a .TXT file, and reads up to the next CR character and returns the value stripped of control characters.</cmt>
  </macro>
  <macro>
    <name>Memory.replace</name>
    <act>Y</act>
    <stx>@Memory.replace(memoryHandle,value,replNum)</stx>
    <dsc>Inserts [value] into [memoryHandle] replacing [replNum] existing characters</dsc>
    <code>@2^#mI[@1,@3]</code>
    <cmt>Inserts the value into the memory object at the current cursor position, replacing [replNum] existing characters and shifting the contents at the current cursor position up to make room for a larger value or back to fill in after a smaller value, and moves the cursor to the end of the value.

If the memory object is too small to contain the new value, the memory object is expanded.
If [value] = NIL then delete [replNum] characters, inserting nothing.
If [replNum] = 0 then insert only, replacing nothing.
</cmt>
  </macro>
  <macro>
    <name>Memory.search</name>
    <act>Y</act>
    <stx>@Memory.search(memoryHandle,csFlag,string)</stx>
    <dsc>Search for [string] in the memory object</dsc>
    <code>#mS[@1,@2,@3]</code>
    <cmt>Search for [string] in the memory object, starting at the current cursor position, and return the new cursr position of the string if found.  If not found, return NIL and do not move the cursor.

If [csFlag] = 0 then A=a, else the search is case-sensitive.
</cmt>
  </macro>
  <macro>
    <name>Memory.set.cursor</name>
    <act>Y</act>
    <stx>@Memory.set.cursor(memoryHandle,number)</stx>
    <dsc>Sets the cursor position.</dsc>
    <code>#mZ[@1,@2]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Memory.set.highwater.mark</name>
    <act>Y</act>
    <stx>@Memory.set.highwater.mark(membuff,position)</stx>
    <dsc>Sets the High water mark and cursor of the memory buffer</dsc>
    <code>#mj[@1,@2]</code>
    <cmt>Should not exceed current size of buffer.</cmt>
  </macro>
  <macro>
    <name>Memory.store.file</name>
    <act>Y</act>
    <stx>@Memory.store.file(memoryHandle,UNCName)</stx>
    <dsc>Stores the contents of the buffer in the specified file.</dsc>
    <code>#mt[@1,@2]</code>
    <cmt>This is symmetrical with @Memory.load.file which reads from a file.

Returns:
  &quot;&quot; - Success
  Oxxxx - unable to open the file, does not have to exist it will be created for you by #mt
  Wxxxx - unable to write file
  Cxxxx - unable to close file handle</cmt>
  </macro>
  <macro>
    <name>Memory.strip.spaces</name>
    <act>Y</act>
    <stx>@Memory.strip.spaces(memoryHandle)</stx>
    <dsc>Strip leading and trailing spaces from &lt;CRLF&gt; delimited text in [memoryHandle]</dsc>
    <code>#ms[@1]</code>
    <cmt>Strip leading and trailing spaces from the &lt;CRLF&gt; delimited text in the memory buffer.  No return.</cmt>
  </macro>
  <macro>
    <name>Memory.text.read</name>
    <act>Y</act>
    <stx>@Memory.text.read(memoryHandle,maxLength)</stx>
    <dsc>Treats the contents of the memory object as a text stream, and reads one line.</dsc>
    <code>#mL[@1,@2]</code>
    <cmt>Formatted Line read:  treats the contents of the memory object as a text stream, and reads a line&apos;s worth of characters stopping on the space character closest to but not exceeding the maxLength parameter.

Carriage Return characters embedded in the text stream are treated as hard Line Breaks and are preserved.

NOTE:  This is identical to @Memory.read.line.

</cmt>
  </macro>
  <macro>
    <name>Memory.usage</name>
    <act>Y</act>
    <stx>@Memory.usage(memoryHandle)</stx>
    <dsc>Returns the number of bytes allocated and number of bytes used</dsc>
    <code>#mU&quot;_IF{S[1] &quot;[@1]&quot;}_&quot;</code>
    <cmt>returns:
  {allocated bytes, used bytes}

If a specific memoryHandle is specificed then the information returned is specific to that memoryHandle.  Otherwise the information returned regards all memoryHandles.</cmt>
  </macro>
  <macro>
    <name>Memory.write</name>
    <act>Y</act>
    <stx>@Memory.write(memoryHandle,value)</stx>
    <dsc>Writes the [value] to the memory object at the current cursor position.</dsc>
    <code>&quot;_IF{S[2] &quot;@2^&quot;}_&quot;#mW[@1]</code>
    <cmt>Writes the value to the memory object at the current cursor position, and moves the cursor to the end of the value.  If the memory object is too small to contain the new value, the memory object is expanded.
</cmt>
  </macro>
  <macro>
    <name>Menu.create</name>
    <act>Y</act>
    <stx>@Memory.create(memoryHandle)</stx>
    <dsc>Creates a popup menu from the specified memory buffer.  Returns a menuHandle.</dsc>
    <code>#MC[@1]</code>
    <cmt>The buffer may be loaded from a file or created on the fly.  One may create up to 256 menus in any given MAGIC session.  A menu in this context means the top-level only, as all sub-menus are included.  Menus are not window-specific; all menus are deleted ONLY when you exit MagicCS.  The arguments of an entry line are delimited by the semicolon(;).  Lines are &lt;CR&gt; delimited as in a standard .TXT file.  Entries are case INsensitive.

The general syntax for entries is as follows:
Keyword;&quot;Text&quot;;ID;State;UncheckedBitmap;CheckedBitmap;HelpFileName;HelpFileJumpPoint

[Keywords]
POPUP      this entry expands to a sub-menu, but is NOT the last item at its level.
ENDPOPUP   this entry expands to a sub-menu and IS the last item at this level.
ITEM       this is a command entry but is NOT the last entry at this level.
LASTITEM   this is a command entry and IS the last entry at this level.
SEPARATOR  a line will be inserted in the menu at this point.  No other arguments are                      necessary for a separator.
BREAK      the menu will be broken at this point, and the next item will begin a new column.

All entries following a POPUP or ENDPOPUP belong to the next lower level until a LASTITEM or ENDPOPUP is encountered.

[Text]
The text of an entry must be in quotes. The Windows rules apply for HotKeys and such.

[ID]
This is a number 0 - 255 by which this entry will be reported when the user selects it. Because there are only 256 IDs available for each menu it makes sense NOT to assign IDs to POPUP items (ie assign them an ID of 0) since they cannot be selected.

[State]
ENABLED   should be self explanatory.
DISABLED  items will be GRAYED as well.
CHECKED   means ENABLED, and a checkmark is placed to the left of the text.

[UncheckedBitmap]
This is a pictureHandle ( from#pM[] or #pC[] ) to be displayed to the left of the text when the item is not checked.

[CheckedBitmap]
This is a pictureHandle ( from#pM[] or #pC[] ) to be displayed to the left of the text when the item is checked.

[HelpFileName]
This is the full Path and Filename of a Help file to be displayed if the user types &lt;F1&gt; while this item is selected.

[HelpFileJumpPoint]
This is the index of an entry in the help file to jump to if the user types &lt;F1&gt; while this item is selected.

</cmt>
  </macro>
  <macro>
    <name>Menu.delete</name>
    <act>Y</act>
    <stx>@Menu.delete(menuHandle)</stx>
    <dsc>Deletes the specified menu.</dsc>
    <code>#MX[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Menu.display</name>
    <act>Y</act>
    <stx>@Menu.display(row,column,menuHandle)</stx>
    <dsc>Displays the specified menu at [row] and [column].  Returns ID of selected item.</dsc>
    <code>#MD[@1,@2,@3]</code>
    <cmt>Both the row and column arguments may have additional characters to indicate alternative placement:

  &quot;A&quot; preceding the row or column indicates that the placement should be relative to the       MagicCS window space as a whole (excluding the Toolbar), and not relative to the current     window.

  &quot;R&quot; following the column argument indicates that the column specified is where the RIGHT     edge of the menu will be placed.  Space permitting, the menu will appear to the left of      the indicated column.  Of course, sub-menus will be displayed according to Windows own       rules as always.

These new features may be combined.  So for example, if the application&apos;s current window is small and centered, one could write @Menu.display(menuHandle,0,&quot;A93R&quot;), and the menu would appear at relative row 0, but on the right, next to the toolbar.

Windows takes care of banking, so if you place your menu too far right or down it will pop up above or to the left of the specified position.
</cmt>
  </macro>
  <macro>
    <name>Menu.state</name>
    <act>Y</act>
    <stx>@Memory.state(menuHandle,item,state)</stx>
    <dsc>Changes the [item] to the specified [state].</dsc>
    <code>#MS[@1,@2,@3]</code>
    <cmt>[State]
ENABLED   should be self explanatory.
DISABLED  items will be GRAYED as well.
CHECKED   means ENABLED, and a checkmark is placed to the left of the text.
</cmt>
  </macro>
  <macro>
    <name>Message.read</name>
    <act>Y</act>
    <stx>@Message.read(&quot;&quot;)</stx>
    <dsc>Windows Events -- Retrieve the next incoming message from the queue.</dsc>
    <code>#E^MESSAGE</code>
    <cmt>@Message.read retrieves the next incoming message from the queue, returning        Q(Msg,Data1,Data2) if there is an Event message pending, otherwise NIL.  (Similar to @Read.mouse functions.)

        @Z.message = MESSAGE
     @Z.message.id = MESSAGE|0
  @Z.message.data1 = MESSAGE|1
  @Z.message.data2 = MESSAGE|2
</cmt>
  </macro>
  <macro>
    <name>Message.register</name>
    <act>Y</act>
    <stx>@Message.register(msg,flag)</stx>
    <dsc>Windows Events -- Register a message type that an application can receive.</dsc>
    <code>#E[@1,@2]</code>
    <cmt>Returns the message type.

[msg] is a number specifying the type of message:
 msg = 0 causes a unique message type to be generated by Windows
 msg = string causes a message type to be generated by Windows based  upon the string.  This        way, 2 or more processes may register a message type using the same string, and              Windows guarantees that they will both receive the same unique message type.  The            string may be up to 50 characters in length, and may not have a numeric as its first         character.
 msg &gt; 0 registers the literal message type specified.  Applications registering literal            messages should use numbers &gt;1024, as those &lt;1024 are reserved for use by Windows.

[flag] specifies actions to be taken relative to the MSG:
 flag = 0 means STOP receiving this message type
 flag = 1 means receive this message type, but do NOT interrupt any read but #S/#s
 flag = 2 means receive this message and DO interrupt any read

If a read is interrupted by the receipt of a registered message, #L returns Q(&quot;E&quot;,other stuff).  An application should use this return value only as an alert that there is at least one event message on the queue to be processed.  The additional information returned is not guaranteed.  The application should process the Event Queue by repeatedly executing #E until it returns NIL.
</cmt>
  </macro>
  <macro>
    <name>Message.send</name>
    <act>Y</act>
    <stx>@Message.send(hWnd,msg,data1,data2)</stx>
    <dsc>Windows Events -- Sends a message to to window specified by [hWnd]</dsc>
    <code>{@1,@2,@3,@4}^#E</code>
    <cmt>[hWnd] for a Magic session can be derived from @Window.handle.</cmt>
  </macro>
  <macro>
    <name>Message.send.self</name>
    <act>Y</act>
    <stx>@Message.send.self(msg,data1,data2)</stx>
    <dsc>Windows Events -- Send a message to the main Magic thread (from bkg thread)</dsc>
    <code>{@1,@2,@3}@SN</code>
    <cmt/>
  </macro>
  <macro>
    <name>Min</name>
    <act>Y</act>
    <stx>@Min(arg1,arg2)</stx>
    <dsc>Returns the minimum of [arg1] and [arg2].</dsc>
    <code>&quot;_IF{IF{S&apos;=2 %NPRLER(&quot;FN&quot;,S[0])},&quot;(@1&amp;(@2))&quot;}_&quot;</code>
    <cmt/>
  </macro>
  <macro>
    <name>Mirror.copy</name>
    <act>Y</act>
    <stx/>
    <dsc>This is a macro used solely for mirroring of MagicCS RAFs.</dsc>
    <code>@MC</code>
    <cmt>This is a macro used solely for mirroring of MagicCS RAFs and should not be used elsewhere.</cmt>
  </macro>
  <macro>
    <name>Mirror.file</name>
    <act>Y</act>
    <stx/>
    <dsc>This is a macro used solely for mirroring of MagicCS RAFs.</dsc>
    <code>@MF</code>
    <cmt>This is a macro used solely for mirroring of MagicCS RAFs and should not be used elsewhere.</cmt>
  </macro>
  <macro>
    <name>Mirror.flush</name>
    <act>Y</act>
    <stx/>
    <dsc>Flushes dirty buffers to disk</dsc>
    <code>@Mf</code>
    <cmt>This function is used to get the database on disk in a consistent state prior to a SAN based backup.

usage: &quot;&quot;@Mf
example: @Mf</cmt>
  </macro>
  <macro>
    <name>Mirror.flush.windows</name>
    <act>Y</act>
    <stx/>
    <dsc>Flushes the windows file cache for the volume</dsc>
    <code>@Mc</code>
    <cmt>Takes a drive as argument, e.g. &quot;E:&quot;@Mirror.flush.windows
Must be a fixed disk.</cmt>
  </macro>
  <macro>
    <name>Mirror.option</name>
    <act>Y</act>
    <stx/>
    <dsc>This is a macro used solely for mirroring of MagicCS RAFs,</dsc>
    <code>@MO</code>
    <cmt>This is a macro used solely for mirroring of MagicCS RAFs and should not be used elsewhere.</cmt>
  </macro>
  <macro>
    <name>Mirror.san.backup.complete</name>
    <act>Y</act>
    <stx/>
    <dsc>Signals the storage subsystem that the backup is complete</dsc>
    <code>@Mr</code>
    <cmt>usage: &lt;drivename&gt;@Mr

example: &quot;\\.\PHYSICALDRIVE3&quot;@Mr</cmt>
  </macro>
  <macro>
    <name>Mirror.san.backup.prepare</name>
    <act>Y</act>
    <stx/>
    <dsc>Signals the storage subsystem to prepare for backup</dsc>
    <code>@Ms</code>
    <cmt>usage: &lt;drivename&gt;@Ms
example: &quot;\\.\PHYSICALDRIVE2&quot;@Ms</cmt>
  </macro>
  <macro>
    <name>Mirror.san.config.dialog</name>
    <act>Y</act>
    <stx/>
    <dsc>Brings up a SAN-specific configuration dialog</dsc>
    <code>@Mn</code>
    <cmt>requires a SAN-specific MTSAN.DLL
</cmt>
  </macro>
  <macro>
    <name>Mirror.san.discover</name>
    <act>Y</act>
    <stx/>
    <dsc>Adds newly discovered disks to database, if applicable</dsc>
    <code>@Md</code>
    <cmt>Only supported on some SANs, e.g. Symmetrix</cmt>
  </macro>
  <macro>
    <name>Mirror.san.do.copy</name>
    <act>Y</act>
    <stx/>
    <dsc>do copy, type passed in to san dll</dsc>
    <code>@Mh</code>
    <cmt>{device,type,label}@Mirror.san.do.copy will return the resulting san identifier on success, or a plain numeric error code on failure.</cmt>
  </macro>
  <macro>
    <name>Mirror.san.do.diff</name>
    <act>Y</act>
    <stx/>
    <dsc>Create a diff copy</dsc>
    <code>@Mk</code>
    <cmt>{device,label}@Mirror.san.do.diff will return the resulting san identifier on success, or a plain numeric error code on failure.</cmt>
  </macro>
  <macro>
    <name>Mirror.san.do.plex</name>
    <act>Y</act>
    <stx/>
    <dsc>Create a plex copy</dsc>
    <code>@Mj</code>
    <cmt>{device,label}@Mirror.san.do.plex will return the resulting san identifier on success, or a plain numeric error code on failure.</cmt>
  </macro>
  <macro>
    <name>Mirror.san.enumdisks</name>
    <act>Y</act>
    <stx/>
    <dsc>lists the physical disks associated with a drive letter</dsc>
    <code>@Me</code>
    <cmt>usage: &lt;driveletter:&gt;@Me^{&quot;\\.\PHYSICALDRIVEn&quot;,&quot;\\.\PHYSICALDRIVEp&quot;,...}
e.g. &quot;C:&quot;@Me returns `\\.\PHYSICALDRIVE0&apos;

only works on fixed disks and on NT based operating systems, Win2K, WinXP, etc.</cmt>
  </macro>
  <macro>
    <name>Mirror.san.exit</name>
    <act>Y</act>
    <stx/>
    <dsc>Unloads SAN libraries</dsc>
    <code>@Mx</code>
    <cmt>usage: &quot;&quot;@Mx
example: &quot;&quot;@Mx</cmt>
  </macro>
  <macro>
    <name>Mirror.san.getlasterror</name>
    <act>Y</act>
    <stx/>
    <dsc>Retrieves last implementation specific error code</dsc>
    <code>@Ml</code>
    <cmt>Used for diagnostics.</cmt>
  </macro>
  <macro>
    <name>Mirror.san.getlasterrorstring</name>
    <act>Y</act>
    <stx/>
    <dsc>Retrieves last implementation specific error string</dsc>
    <code>@Mb</code>
    <cmt>diagnostic</cmt>
  </macro>
  <macro>
    <name>Mirror.san.init</name>
    <act>Y</act>
    <stx/>
    <dsc>Initialize SAN libraries, return SAN type</dsc>
    <code>@Mi</code>
    <cmt>usage: &quot;&quot;@Mi^SANTYPE
example: IF{@Mi=&quot;SYM&quot; @DO.SYMMETRIX.STUFF}

This function loads the mtsan.dll library, if present, which will in turn load any SAN specific libraries, so that VMAGIC can control the creation of backup copies of databases.</cmt>
  </macro>
  <macro>
    <name>Mirror.san.query</name>
    <act>Y</act>
    <stx/>
    <dsc>returns the state of the association between a standard device and its backup</dsc>
    <code>@Mq</code>
    <cmt>usage: &lt;drivename&gt;@Mq returns an integer representing the state of the relationship between the standard and backup devices associated with drivename. The possible results are as follows:

enum SAN_DISK_MODE
{
SAN_DISK_MODE_ERROR,
SAN_DISK_MODE_BACKUP,
SAN_DISK_MODE_NORMAL,
SAN_DISK_MODE_RESTORE,
SAN_DISK_MODE_OTHER,
};

example: IF{&quot;\\.\PHYSICALDRIVE2&quot;@Mq=1 @RESYNCH}</cmt>
  </macro>
  <macro>
    <name>Mirror.san.translate</name>
    <act>Y</act>
    <stx/>
    <dsc>Translate NT Physical disk names to names relevant to the underlying SAN</dsc>
    <code>@Mt</code>
    <cmt>usage: &lt;drivename&gt;@Mt returns a list of the standard name and the backup device name
example: &quot;\\.\PHYSICALDRIVE1&quot;@Mt^{std,backup}</cmt>
  </macro>
  <macro>
    <name>Mirror.san.undo.copy</name>
    <act>Y</act>
    <stx/>
    <dsc>Undoes a copy of a specific type</dsc>
    <code>@Mw</code>
    <cmt>{device,type,label}@Mirror.san.undo.copy will return nil on success, or a plain numeric error code on failure.</cmt>
  </macro>
  <macro>
    <name>Mirror.san.undo.diff</name>
    <act>Y</act>
    <stx/>
    <dsc>Undo a diff copy</dsc>
    <code>@Mz</code>
    <cmt>{device,label}@Mirror.san.undo.diff will return nil on success, or a plain numeric error code on failure.</cmt>
  </macro>
  <macro>
    <name>Mirror.san.undo.plex</name>
    <act>Y</act>
    <stx/>
    <dsc>undo a plex copy</dsc>
    <code>@My</code>
    <cmt>{device,label}@Mirror.san.undo.plex will return nil on success, or a plain numeric error code on failure.</cmt>
  </macro>
  <macro>
    <name>Mirror.suspend</name>
    <act>Y</act>
    <stx/>
    <dsc>Suspends database updates by acquiring the DKACT mutex</dsc>
    <code>@Mg</code>
    <cmt>NOTE: the mutex must not be held for very long. This function must (if successful) always be followed up with an @Md call

usage: &quot;&quot;@Mg
example: IF{@Mg @DO.STUFF,@Md}</cmt>
  </macro>
  <macro>
    <name>Mirror.unsuspend</name>
    <act>Y</act>
    <stx/>
    <dsc>Releases the DKACT mutex, thereby allowing database updates again</dsc>
    <code>@Ma</code>
    <cmt>usage: &quot;&quot;@Ma
example: IF{@Mg @DO.STUFF,@Ma}</cmt>
  </macro>
  <macro>
    <name>Mouse.ptr.arrow</name>
    <act>Y</act>
    <stx>@Mouse.ptr.arrow(&quot;&quot;)^#</stx>
    <dsc>Change mouse pointer to an arrow.</dsc>
    <code>D(3,0)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Mouse.ptr.hourglass</name>
    <act>Y</act>
    <stx>@Mouse.ptr.hourglass(&quot;&quot;)^#</stx>
    <dsc>Change mouse pointer to an hourglass.</dsc>
    <code>D(3,1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Move</name>
    <act>Y</act>
    <stx>@Move(source,target)</stx>
    <dsc>Move nodes at and below [target] with those at and below [source].</dsc>
    <code>M(@1,@2)</code>
    <cmt>See also @Replace.</cmt>
  </macro>
  <macro>
    <name>Mult.height</name>
    <act>Y</act>
    <stx>@Mult.height(element,screen.or.*)</stx>
    <dsc>Translates to height (# of rows) of a screen multiple.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..screen(^S)_&quot;</code>
    <cmt>Example:  @Mult.height(abs.tape.svc,MIS.USER.ee1)
Translates to:  3
</cmt>
  </macro>
  <macro>
    <name>Mult.info</name>
    <act>Y</act>
    <stx>@Mult.info(element,screen or *)^{@.itn,@.urn}</stx>
    <dsc>Returns the itn and urn for the current row of a multiple.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..screen(^S)_&quot;</code>
    <cmt/>
  </macro>
  <macro>
    <name>Mult.position</name>
    <act>N</act>
    <stx>@Mult.position(element,screen.or.*,itn)</stx>
    <dsc>Resets the starting point [itn] of a screen multiple</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..screen(^S)_&quot;</code>
    <cmt>Specifying a third argument will repoint the field multiples starting at that row.  Omitting the third argument will start repointing the field multiples from row 1.

Example:       @Mult.reset(@field.no,LAB.B.QUES.ee.field)
Translates to:
1^/(UI)ST[&quot;MULT&quot;,&quot;LAB.B.QUES.ee.field&quot;,2]|0

Example:       @Mult.reset(@field.no,LAB.B.QUES.ee.field,2)
Translates to:
2^/(UI)ST[&quot;MULT&quot;,&quot;LAB.B.QUES.ee.field&quot;,2]|0</cmt>
  </macro>
  <macro>
    <name>Mult.reset</name>
    <act>Y</act>
    <stx>@Mult.reset(element,screen.or.*,urn or &quot;B&quot;,no.nav.override)</stx>
    <dsc>Resets the urns stored in the state table for a multple &amp; positions the cursor</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..screen(^S)_&quot;</code>
    <cmt>If the third argument is blank the urns in the state table for the multple are reset to match the visible entries in the screen multiple starting at the beginning.

If a numeric is specified as the third argument, the intent is to reset the urns in the state table for the multiple starting at a particular point.  This would be used if screen multiple had more entries that could fit on a screen and the programmer wanted to start displaying the values at a specific point.

In either of the above cases the cursor is always positioned on the field specified, if it is accessible, in the first row of the multiple.

If &quot;B&quot; is specified as the third argument,  the intent is to reset the urns in the multple so the next available row is scrolled into view and the cursor is placed on the field specified, if it is accessible.

*Optional* If the no.nav.override flag is set, navigation will not automatically be forced into the multiple.  This is useful if the goal is to simply redisplay the multiple, but not move focus into it immediately.
</cmt>
  </macro>
  <macro>
    <name>Mutex.test</name>
    <act>Y</act>
    <stx/>
    <dsc>Gains and releases the MUTEX to simulate a disk reference.</dsc>
    <code>@PM</code>
    <cmt/>
  </macro>
  <macro>
    <name>Nameserver</name>
    <act>Y</act>
    <stx>name@Nameserver</stx>
    <dsc>Old macro used for opens</dsc>
    <code>@NS</code>
    <cmt/>
  </macro>
  <macro>
    <name>Namespace.clear</name>
    <act>Y</act>
    <stx>@Namespace.clear(segment.name)</stx>
    <dsc>Reverts the translation of [segment.name] back to its data definition.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.t.rec(^S)_&quot;</code>
    <cmt>See @Namespace.set.</cmt>
  </macro>
  <macro>
    <name>Namespace.set</name>
    <act>Y</act>
    <stx>@Namespace.set(root,segment.name)</stx>
    <dsc>Changes the translation of the root of [segment.name].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.t.rec(^S)_&quot;</code>
    <cmt>Changes the translation of the root of [segment.name] until a corresponding @Namespace.clear for segment.name is encountered.

Example:  @Namespace.set([B],@LAB.L.SPEC.main)
Translation of @LAB.L.SPEC.result yields: [B]T[slt]|0

</cmt>
  </macro>
  <macro>
    <name>Net.accept.tcp</name>
    <act>Y</act>
    <stx/>
    <dsc>Accepts a TCP open request and establishes the connection.</dsc>
    <code>@Na</code>
    <cmt/>
  </macro>
  <macro>
    <name>Net.close.tcp</name>
    <act>Y</act>
    <stx/>
    <dsc>Closes a TCP connection.  Should be done on both ends.</dsc>
    <code>@Nc</code>
    <cmt/>
  </macro>
  <macro>
    <name>Net.duplicate.source</name>
    <act>Y</act>
    <stx>{targetprocid,handle}@Net.duplicate.source(bufferaddress)</stx>
    <dsc>Creates a duplicate WSAPROTOCOL_INFO struct for target duplicate</dsc>
    <code>@Nd</code>
    <cmt>Returns numbers of bytes put into buffer at bufferaddress.

nil is returned on error.</cmt>
  </macro>
  <macro>
    <name>Net.duplicate.target</name>
    <act>Y</act>
    <stx>@Net.duplicate.target(bufferaddress)</stx>
    <dsc>Creates handle to duplicated WSAPROTOCOL_INFO.</dsc>
    <code>@Nj</code>
    <cmt>returns socket handle if success.
nil on error.</cmt>
  </macro>
  <macro>
    <name>Net.enc.client</name>
    <act>Y</act>
    <stx/>
    <dsc>Starts the client side of encryption</dsc>
    <code>@Nu</code>
    <cmt>TBA
</cmt>
  </macro>
  <macro>
    <name>Net.enc.server</name>
    <act>Y</act>
    <stx/>
    <dsc>Starts the server side of encryption</dsc>
    <code>@Nv</code>
    <cmt>If nil is passed, the function will attempt to use the Local Machines SSL certificate.
If . is passed, then the function will attempt to use the Current Users SSL Certificate.
</cmt>
  </macro>
  <macro>
    <name>Net.enc.status</name>
    <act>Y</act>
    <stx>[^prefix]@Net.enc.status</stx>
    <dsc>Returns state of the sockets encyption.</dsc>
    <code>@Nk</code>
    <cmt>If a ^prefix is passed, then the socket attached to the prefix encryption state is returned.  If nil is passed in, then the status of the current @Net tcp socket is returned.</cmt>
  </macro>
  <macro>
    <name>Net.end.listen</name>
    <act>Y</act>
    <stx/>
    <dsc>Done by the client who previously did @Net.get.listen.socket to release socket</dsc>
    <code>@Ne</code>
    <cmt/>
  </macro>
  <macro>
    <name>Net.error.flag</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the latest network error recorded.</dsc>
    <code>@NE</code>
    <cmt>0 means no error.

NOTE:  The network macros should not be used in combination with any other functions which would cause network traffic, as they rely on shared memory locations which can be overwritten by other functions.
</cmt>
  </macro>
  <macro>
    <name>Net.flush.tcp</name>
    <act>Y</act>
    <stx/>
    <dsc>Flush the TCP socket</dsc>
    <code>@Nf</code>
    <cmt/>
  </macro>
  <macro>
    <name>Net.from</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns 8 byteWinsock address data indicating source of the last received data.</dsc>
    <code>@NF</code>
    <cmt>This function can be used to set up the &quot;To&quot; address so that you can respond to the person who contacted you.

Example: @Net.from@Net.to

For description of the address, see @Net.to.

For more information, see NPR Network Macros.

NOTE:  The network macros should not be used in combination with any other functions which would cause network traffic, as they rely on shared memory locations which can be overwritten by other functions.
</cmt>
  </macro>
  <macro>
    <name>Net.get.listen.socket</name>
    <act>Y</act>
    <stx/>
    <dsc>Gets a listening socket which will be used to establish a TCP connection.</dsc>
    <code>@Nl</code>
    <cmt>This socket would be sent to another job which will request a TCP connection.  See @Net.open.tcp.</cmt>
  </macro>
  <macro>
    <name>Net.get.tcp</name>
    <act>Y</act>
    <stx/>
    <dsc>non-formatted read</dsc>
    <code>@Ng</code>
    <cmt/>
  </macro>
  <macro>
    <name>Net.handle.listen</name>
    <act>Y</act>
    <stx>handle@Net.handle.listen</stx>
    <dsc>Sets the current listening socket to be the one specified by [handle].</dsc>
    <code>@Nh</code>
    <cmt/>
  </macro>
  <macro>
    <name>Net.handle.tcp</name>
    <act>Y</act>
    <stx>handle@Net.handle.tcp</stx>
    <dsc>Sets the current TCP socket to the one specified by [handle].</dsc>
    <code>@Nt</code>
    <cmt/>
  </macro>
  <macro>
    <name>Net.handle.udp</name>
    <act>Y</act>
    <stx>handle@Net.handle.udp</stx>
    <dsc>Sets the current UDP socket to be the one specified by handle.</dsc>
    <code>@NH</code>
    <cmt/>
  </macro>
  <macro>
    <name>Net.interrogate</name>
    <act>Y</act>
    <stx>timeout@Net.interrogate</stx>
    <dsc>Sends an ICMP echo to the address specified by@Net.to and waits for [timeout] ms</dsc>
    <code>@NI</code>
    <cmt>Sends an ICMP echo to the address specified by@Net.to and waits timeout milliseconds for a response.  The timeout default is 1000.

NOTE: The network macros should not be used in combination with any other functions which would cause network traffic, as they rely on shared memory locations which can be overwritten by other functions.

</cmt>
  </macro>
  <macro>
    <name>Net.job.port</name>
    <act>Y</act>
    <stx>&quot;&quot;@Net.job.port</stx>
    <dsc>Returns the current UDP port for this job.</dsc>
    <code>@NA</code>
    <cmt/>
  </macro>
  <macro>
    <name>Net.nagle</name>
    <act>Y</act>
    <stx>setting@Net.nagle</stx>
    <dsc>Used to turn Nagle&apos;s Algorithm on or off for @Net socket connections</dsc>
    <code>@Nm</code>
    <cmt>Used to disable nagle for @Net connections.

Example:

   0@Net.nagle,
   IF{NET@Net.to@Net.open.tcp @SEND.DATA,@Net.close}
</cmt>
  </macro>
  <macro>
    <name>Net.open.tcp</name>
    <act>Y</act>
    <stx/>
    <dsc>Request to open a TCP connection to the address specified in the prev @Net.to.</dsc>
    <code>@No</code>
    <cmt>Request to open a TCP connection to the address specified in the previous @Net.to.  The address is derived from the listening socket that was sent by the other job.</cmt>
  </macro>
  <macro>
    <name>Net.open.tcp.nagle.off</name>
    <act>Y</act>
    <stx>address@Net.open.tcp.nagle.off</stx>
    <dsc>Open a TCP connection to &lt;address&gt; with Nagle&apos;s Alogrithm disabled</dsc>
    <code>@NT,0@Nm,.@No</code>
    <cmt>Opens up a tcp socket connection with Nagle&apos;s algorithm disabled. Returns &quot;.&quot; on success.</cmt>
  </macro>
  <macro>
    <name>Net.port.udp</name>
    <act>Y</act>
    <stx>port@Net.port.udp</stx>
    <dsc>Gets a UDP socket on [port].</dsc>
    <code>@NP</code>
    <cmt>Returns:
{handle,info} where handle is a 4-byte handle which can be passed into @Net.handle.udp, and info is 8 bytes of address info as specified in @Net.to and @Net.from.  If 0 is specified as port, this function gets a random port.
</cmt>
  </macro>
  <macro>
    <name>Net.put.tcp</name>
    <act>Y</act>
    <stx/>
    <dsc>non-formatted write</dsc>
    <code>@Np</code>
    <cmt/>
  </macro>
  <macro>
    <name>Net.read.tcp</name>
    <act>Y</act>
    <stx>timeout@Net.read.tcp</stx>
    <dsc>Reads a message via TCP and waits for optional [timeout] milliseconds.</dsc>
    <code>@Nr</code>
    <cmt/>
  </macro>
  <macro>
    <name>Net.read.udp</name>
    <act>Y</act>
    <stx>timeout@Net.read.udp</stx>
    <dsc>Read a UDP packet from the network.</dsc>
    <code>@NR</code>
    <cmt>[timeout] is in milliseconds and defaults to 1000.  A value of 0 means never timeout.
For more information, see NPR Network Macros on the Intranet.
</cmt>
  </macro>
  <macro>
    <name>Net.status.tcp</name>
    <act>Y</act>
    <stx/>
    <dsc>returns the status of the tcp socket</dsc>
    <code>@Ns</code>
    <cmt>returns &quot;&quot; if the socket isn&apos;t viable; passes through whatever was on the data stack if the socket hasn&apos;t been closed/reset. This function tends to the conservative, and will return nil in indeterminate cases.</cmt>
  </macro>
  <macro>
    <name>Net.synch.tcp</name>
    <act>Y</act>
    <stx/>
    <dsc>Used on both ends of a TCP connection to synchronize the connection</dsc>
    <code>@Nx</code>
    <cmt>This allows both end of the TCP connection to arrive at the same point before the next instruction.</cmt>
  </macro>
  <macro>
    <name>Net.to</name>
    <act>Y</act>
    <stx>address@Net.to</stx>
    <dsc>Specify the address to which data is sent via the @Net.write.udp function.</dsc>
    <code>@NT</code>
    <cmt>Stores the address in a special location for use by other functions.
[address] is D(address1,address2,port/256,port\256,ip1,ip2,ip3,ip4).

address1 and address2 indicate an &quot;address family&quot;. The value set remains in effect until you explicitly specify another (via @Net.to).

Example: D(2,0,11,173,172,30,7,1)@Net.to

D(2,0) indicates IP. Another example would be IPX, though Winsock 1.1 doesn&apos;t allow for anything but IP.

Sets up to be able to send UDP/IP packets to the VMagic service on servier with IP address 172.30.7.1. (2,0 = IP, 11,173 = port 2989, 172,30,7,1 = server IP address)

NOTE:  The network macros should not be used in combination with any other functions which would cause network traffic, as they rely on shared memory locations which can be overwritten by other functions.
</cmt>
  </macro>
  <macro>
    <name>Net.transfer.file</name>
    <act>Y</act>
    <stx/>
    <dsc>Takes a File opened via @File.open sends thru TCP socket.</dsc>
    <code>@Nq</code>
    <cmt>Currently used only by SERVER IPL.</cmt>
  </macro>
  <macro>
    <name>Net.unenc.client.table</name>
    <act>Y</act>
    <stx/>
    <dsc>activate table of allowed unencrypted clients</dsc>
    <code>@NU</code>
    <cmt/>
  </macro>
  <macro>
    <name>Net.write.tcp</name>
    <act>Y</act>
    <stx>data@Net.write.tcp</stx>
    <dsc>Send [data] via the current TCP socket.</dsc>
    <code>@Nw</code>
    <cmt/>
  </macro>
  <macro>
    <name>Net.write.udp</name>
    <act>Y</act>
    <stx>data@Net.write.udp</stx>
    <dsc>Send [data] as a UDP packet to address determined by the most recent @Net.to.</dsc>
    <code>@NW</code>
    <cmt/>
  </macro>
  <macro>
    <name>Network.buffer.size</name>
    <act>Y</act>
    <stx>size@Network.buffer.size</stx>
    <dsc>Determines what [size] (#bytes) packet to bundle data in when using TCP.</dsc>
    <code>@Nb</code>
    <cmt/>
  </macro>
  <macro>
    <name>Next</name>
    <act>Y</act>
    <stx>@Next(element.name[,segment.name])</stx>
    <dsc>Produces code that gets the next value for the subscript [element.name].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..nexting(^S)_&quot;</code>
    <cmt>If [segment.name] is specified, use it; else use @main.

Example: @Next(@MIS.USER.abs.tape.svc)   +&amp;(G)GU[gu]A[gsc]^gsc

For additional information and examples, see Looping Through Data Structures documentation on the Intranet.
</cmt>
  </macro>
  <macro>
    <name>Next.file</name>
    <act>Y</act>
    <stx/>
    <dsc>Return the next file matching the pattern specified in the last @First.file.</dsc>
    <code>@ZFN</code>
    <cmt>Returns:
{filename,attr,size,create.seconds,last.edit.seconds,last.access.seconds}

where [attr = attributes: &quot;D&quot; for directory, &quot;R&quot; for read-only, etc.]

</cmt>
  </macro>
  <macro>
    <name>Next.get</name>
    <act>Y</act>
    <stx>@Next.get(element.name[,segment.name],variable)</stx>
    <dsc>Get next value for subscript [element.name] and place node value in [variable]</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..nexting(^S)_&quot;</code>
    <cmt>Produces code that gets the next value for the subscript [element.name] and sets [variable] to the value of the node at that subscript.  If [segment.name] is specified, use it; else use @main.

Example: @Next.get(@MIS.USER.abs.tape.svc,X)   +(&amp;(G)GU[gu]A[gsc],X)^gsc

For additional information and examples, see Looping Through Data Structures documentation on the Intranet.
</cmt>
  </macro>
  <macro>
    <name>Next.prefix</name>
    <act>Y</act>
    <stx>prefix@Next.prefix</stx>
    <dsc>Get the next [prefix] in the prefix table. Returns internal name of the prefix.</dsc>
    <code>@ZNP</code>
    <cmt>Start with prefix equal to NIL.</cmt>
  </macro>
  <macro>
    <name>Normal.cell</name>
    <act>Y</act>
    <stx>@Normal.cell(row,column,height,width)</stx>
    <dsc>Unhighlights the cell at [row] and [column] of [height] and [width].</dsc>
    <code>D(16,@1,@2,24,13,@3,@4)</code>
    <cmt>Used with cells created with @Draw.cell.  See also @Highlight.cell.</cmt>
  </macro>
  <macro>
    <name>Normal.cell.cur.pos</name>
    <act>Y</act>
    <stx>@Normal.cell.cur.pos(height,width)</stx>
    <dsc>Unhighlights the cell at the current cursor position of [height] and [width].</dsc>
    <code>D(24,13,@1,@2)</code>
    <cmt>Used with cells created with @Draw.cell.  See also @Highlight.cell.cur.pos.</cmt>
  </macro>
  <macro>
    <name>Normal.field</name>
    <act>Y</act>
    <stx>@Normal.field(&quot;&quot;)</stx>
    <dsc>Unhighlights the text within the field in which the cursor is located.</dsc>
    <code>D(24,3)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Normal.panel.row</name>
    <act>Y</act>
    <stx>@Normal.panel.row(row,column,width)</stx>
    <dsc>Unhighlight a panel row located at [row] and [column] for [width] characters.</dsc>
    <code>D(16,@1,@2,24,5,@3)</code>
    <cmt>See @Draw.panel.</cmt>
  </macro>
  <macro>
    <name>Normal.panel.row.cur.pos</name>
    <act>Y</act>
    <stx>@Normal.panel.row.cur.pos(width)</stx>
    <dsc>Unhighlight a panel row located at the current cursor position for [width] chars</dsc>
    <code>D(24,5,@1)</code>
    <cmt>See @Draw.panel.</cmt>
  </macro>
  <macro>
    <name>Normal.pixel.region</name>
    <act>Y</act>
    <stx>@Normal.pixel.region(row,col,y-offset,x-offset,height,width)</stx>
    <dsc>Unhighlight area [x,y offset] pixels from [row],[column] w/[height],[width] pix</dsc>
    <code>D(16,@1,@2,28,1,@3,@4,@5,@6)</code>
    <cmt>See also @Highlight.pixel.region.</cmt>
  </macro>
  <macro>
    <name>Normal.pixel.region.cur.pos</name>
    <act>Y</act>
    <stx>@Normal.pixel.region.cur.pos(y-offset,x-offset,height,width)</stx>
    <dsc>Unhighlight area [x,y offset] pixels from current pos w/[height],[width] pixels</dsc>
    <code>D(28,1,@1,@2,@3,@4)</code>
    <cmt>See also @Normal.pixel.region.</cmt>
  </macro>
  <macro>
    <name>Normal.row</name>
    <act>Y</act>
    <stx>@Normal.row(row,column,width)</stx>
    <dsc>Unhighlight a row located at [row] and [column] for [width] characters.</dsc>
    <code>D(16,@1,@2,24,1,@3)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Normal.row.color</name>
    <act>Y</act>
    <stx>@Normal.row.color(row,column,width)</stx>
    <dsc>Unhighlight an answer box at [row] and [column] for [width] characters.</dsc>
    <code>D(16,@1,@2,24,11,@3)</code>
    <cmt>Unhighlight an answer box at [row] and [column] for [width] characters using the current foreground color. </cmt>
  </macro>
  <macro>
    <name>Normal.row.color.cur.pos</name>
    <act>Y</act>
    <stx>@Normal.row.color.cur.pos(width)</stx>
    <dsc>Unhighlight an answer box at the current cursor position for [width] characters.</dsc>
    <code>D(24,11,@1)</code>
    <cmt>Unhighlight an answer box at the current cursor position for [width] characters using the current foreground color. </cmt>
  </macro>
  <macro>
    <name>Normal.row.cur.pos</name>
    <act>Y</act>
    <stx>@Normal.row.cur.pos(width)</stx>
    <dsc>Unhighlight a row located at the current cursor position for [width] characters.</dsc>
    <code>D(24,1,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Not</name>
    <act>Y</act>
    <stx>@Not(arg)</stx>
    <dsc>Generates code to determine if the [arg] is not true.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..functions(^S)_&quot;</code>
    <cmt>The code varies as follows depending on arg:

* non-packed elements: &apos;arg
* packed elements: L(arg)=0
</cmt>
  </macro>
  <macro>
    <name>Object.delete</name>
    <act>Y</act>
    <stx>@Object.delete(targetID)</stx>
    <dsc>Delete the indicated mouse target.</dsc>
    <code>#oX[@1]</code>
    <cmt>The appearance of the targets in the screen does not change, but mouse clicks will no longer be processed.

@Object.delete(&quot;&quot;) means delete all objects.

See also @Object.enable and @Object.disable.
</cmt>
  </macro>
  <macro>
    <name>Object.disable</name>
    <act>Y</act>
    <stx>@Object.disable(targetID)</stx>
    <dsc>Disable the indicated mouse target.</dsc>
    <code>#oD[@1]</code>
    <cmt>The appearance will not change, but mouse clicks will not be processed.  See also @Object.enable and @Object.delete.</cmt>
  </macro>
  <macro>
    <name>Object.enable</name>
    <act>Y</act>
    <stx>@Object.enable(targetID)</stx>
    <dsc>Enable the indicated mouse target.</dsc>
    <code>#oE[@1]</code>
    <cmt>See also @Object.disable and @Object.delete.</cmt>
  </macro>
  <macro>
    <name>Object.wait</name>
    <act>Y</act>
    <stx>handle@Object.wait(timeout milliseconds)</stx>
    <dsc>Wait for Object</dsc>
    <code>@OW</code>
    <cmt>Used for Windows events and Semaphores.  Returns nil on error, &quot;.&quot; on timeout or handle on success.</cmt>
  </macro>
  <macro>
    <name>Object.wait.multi</name>
    <act>Y</act>
    <stx>{type,handle,handle,...}@Object.wait.multi(milliseconds)</stx>
    <dsc>Wait for Object multiple</dsc>
    <code>@OM</code>
    <cmt>Used for Windows events and Semaphores.  Returns nill on error, &quot;.&quot; on timeout or zero based count for the which handle in the queued string.
</cmt>
  </macro>
  <macro>
    <name>Performance.measure.begin</name>
    <act>Y</act>
    <stx/>
    <dsc>Remembers the current clock ticker</dsc>
    <code>@PB</code>
    <cmt>The @Performance... functions are used to time very short events.  If what you&apos;re measuring is on the order of seconds, you can use S(0) times.  To get the &quot;real&quot; time of an operation in seconds, the code should look like:

@Performance.measure.begin,
@DO.OPERATION,
@Performance.measure.end/@Performance.measure.factor

For milliseconds, substitute: @Performance.measure.end*1000/@Performance.measure.factor

</cmt>
  </macro>
  <macro>
    <name>Performance.measure.end</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the current clock ticker minus the remembered ticker.</dsc>
    <code>@PE</code>
    <cmt>The @Performance... functions are used to time very short events.  If what you&apos;re measuring is on the order of seconds, you can use S(0) times.  To get the &quot;real&quot; time of an operation in seconds, the code should look like:

@Performance.measure.begin,
@DO.OPERATION,
@Performance.measure.end/@Performance.measure.factor

For milliseconds, substitute: @Performance.measure.end*1000/@Performance.measure.factor

</cmt>
  </macro>
  <macro>
    <name>Performance.measure.factor</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns a performance factor used when calculating &quot;real&quot; times.</dsc>
    <code>@PF</code>
    <cmt>The @Performance... functions are used to time very short events.  If what you&apos;re measuring is on the order of seconds, you can use S(0) times.  To get the &quot;real&quot; time of an operation in seconds, the code should look like:

@Performance.measure.begin,
@DO.OPERATION,
@Performance.measure.end/@Performance.measure.factor

For milliseconds, substitute: @Performance.measure.end*1000/@Performance.measure.factor

</cmt>
  </macro>
  <macro>
    <name>Pfx.addr.local</name>
    <act>Y</act>
    <stx>^prefix@Pfx.addr.local</stx>
    <dsc>Extracts the local address portion from the internal form of the prefix.</dsc>
    <code>@PL</code>
    <cmt/>
  </macro>
  <macro>
    <name>Pfx.addr.remote</name>
    <act>Y</act>
    <stx>^prefix@Pfx.addr.remote</stx>
    <dsc>Extracts the remote address portion from the internal form of the prefix.</dsc>
    <code>@PR</code>
    <cmt/>
  </macro>
  <macro>
    <name>Pfx.info</name>
    <act>Y</act>
    <stx>pfx.number@ZPE</stx>
    <dsc>Returns raw prefix table information for the specified prefix number</dsc>
    <code>@ZPE</code>
    <cmt/>
  </macro>
  <macro>
    <name>Pfx.pstruct.size</name>
    <act>Y</act>
    <stx>^pfx@Pfx.pstruct.size</stx>
    <dsc>Pass ^ of P-structure prefix, returns size of P-Structure</dsc>
    <code>@Gz</code>
    <cmt/>
  </macro>
  <macro>
    <name>Pfx.update</name>
    <act>Y</act>
    <stx>{^prefix,prefix.data}@Pfx.update</stx>
    <dsc>Updates client prefix table.</dsc>
    <code>@PU</code>
    <cmt>Updates client prefix table after an @Execute.object.local (@XO) to a server.  @XO code must be written to return the appropriate prefix.data to the client for the client to use with @Pfx.update.</cmt>
  </macro>
  <macro>
    <name>Pgm</name>
    <act>Y</act>
    <stx>@Pgm(program.source.name[,screen.or.report.pgm,macro.name])</stx>
    <dsc>Produces call to Z.log.to.phys.proc.name which returns program.object.name</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..functions(^S)_&quot;</code>
    <cmt>Produces code to call the program Z.log.to.phys.proc.name which returns program.object.name at run-time.

Example: @Pgm(&quot;%MIS.USER.ee&quot;) yields %(Z)log.to.phys.proc.name(&quot;%MIS.USER.ee&quot;)

For screens and reports, screen.or.report.pgm must be &quot;S&quot;, &quot;S1&quot;,...,&quot;Sn&quot;, or &quot;R&quot; and this is appended blindly.  For macros, third argument must be macro name.  If supplied, this OVERRIDES the second argument, and what gets returned is the physical name of the object code of the macro.

</cmt>
  </macro>
  <macro>
    <name>Pgm.cache.interval</name>
    <act>Y</act>
    <stx>milliseconds@Pgm.cache.interval</stx>
    <dsc>Set the time in milliseconds for the client program cache</dsc>
    <code>@ZPS</code>
    <cmt>Set the time in milliseconds that programs can be in the client cache before checking time/date stamp on the server.</cmt>
  </macro>
  <macro>
    <name>Pgm.name</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the Procedure name</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..functions(^S)_&quot;</code>
    <cmt>If arg 1 is non-nil, &quot;zrepl&quot; will be stripped from the resulting procedure name.

Example -  When translated in NPR.DPM.zrepl.procedure.name:

            @Pgm.name(&quot;&quot;), @Pgm.name(0), @Pgm.name(&quot;1&quot;)   all translate to
            &quot;NPR.DPM.procedure.name&quot;

            @Pgm.name()  translates to &quot;NPR.DPM.zrepl.procedure.name&quot;</cmt>
  </macro>
  <macro>
    <name>Pgm.trans</name>
    <act>Y</act>
    <stx>@Pgm.trans(program.source.name)</stx>
    <dsc>Returns the object code for [program.source.name] at translation time.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..functions(^S)_&quot;</code>
    <cmt>Example:
@Pgm.trans(%MIS.USER.ee) yields %(MIS)USER..ee

If program.source.name does NOT have a leading &quot;%&quot;, the prefix ( %(application mnemonic) ) is not included.

Example:
@Pgm.trans(MIS.USER.ee) yields --&gt; USER..ee

If program.source.name is surrounded in quotes, the resultant object code will also contain quotes.

Example:
@Pgm(&quot;%MIS.USER.ee&quot;) yields --&gt; &quot;%(MIS)USER..ee&quot;

Either or both of the above techniques may be used to construct longer program file names at run-time.

</cmt>
  </macro>
  <macro>
    <name>Picture.convert.to.lite</name>
    <act>N</act>
    <stx>@Picture.convert.to.lite(pictureHandle,memoryHandle)</stx>
    <dsc>Converts a picture to 30-color EMR format and places result in [memoryHandle]</dsc>
    <code>#pH[@1,@2]</code>
    <cmt>Converts from either 8-bit or 24-bit images.</cmt>
  </macro>
  <macro>
    <name>Picture.create</name>
    <act>Y</act>
    <stx>@Picture.create(memoryHandle)</stx>
    <dsc>Create a picture using the data found in [memoryHandle]; returns pictureHandle</dsc>
    <code>#pC[@1]</code>
    <cmt>Create a picture using the bitmap data found in the memory structure referenced by the [memoryHandle]; returns a pictureHandle.

This macro is essentially obsolete.  Pictures are now created in other ways, most often with the @Picture.make and @Picture.make.palette macros which work directly from bitmap files and do not require an intermediate step of loading the imagine to a memory buffer.
</cmt>
  </macro>
  <macro>
    <name>Picture.delete</name>
    <act>Y</act>
    <stx>@Picture.delete(pictureHandle)</stx>
    <dsc>Delete the specified picture.</dsc>
    <code>#pX[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Picture.dimension</name>
    <act>Y</act>
    <stx>@Picture.dimension(path)</stx>
    <dsc>returns a queued string of the height and width pixels for .bmp and .jpg files</dsc>
    <code>#pD[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Picture.file</name>
    <act>Y</act>
    <stx>@Picture.file(pictureHandle,compressionFactor,UNVName)</stx>
    <dsc>Files the picture referenced by [pictureHandle] to the indicated file.</dsc>
    <code>#pF[@1,@2,@3]</code>
    <cmt>[compressionFactor] (0-255) is used only when filing jpeg (.jpg) images - the higher the factor, the smaller the size and the less sharp the image.  This function can be used to convert .bmp files to .jpg files.  Create pictureHandle to a .bmp file and then use this macro to file it as .jpg:

@Picture.make.palette(&lt;Path&gt;file.bmp)^pictureHandle
@Picture.file(pictureHandle,compressionFactor,&lt;path&gt;file.jpg)
</cmt>
  </macro>
  <macro>
    <name>Picture.get.twain</name>
    <act>Y</act>
    <stx>@Picture.get.twain(flag)</stx>
    <dsc>Allows access to TWAIN image sources.</dsc>
    <code>#pT[@1]</code>
    <cmt>[flag]=0 means Select a Source.  If only one source is present, it is automatically             selected.  If multiple sources exist, a dialog is presented for the user to choose.          Returns 0 if a source is selected, NIL if not.

[flag]=1 means Acquire an Image.  A dialog will be presented (generated by the device           software), and the user will be allowed to download an image.  If the download is            successful, a PictureID is returned, and may be used in all subsequent operations.  If       the download fails or the user cancels, NIL is returned.

</cmt>
  </macro>
  <macro>
    <name>Picture.make</name>
    <act>Y</act>
    <stx>@Picture.make(UNVName)</stx>
    <dsc>Create a picture using the bitmap data in UNVName; returns a pictureHandle.</dsc>
    <code>#pM[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Picture.make.palette</name>
    <act>Y</act>
    <stx>@Picture.make.palette(UNVName)</stx>
    <dsc>Create a picture using the bitmap data in UNVName; returns a pictureHandle.</dsc>
    <code>#pP[@1]</code>
    <cmt>Create a picture using the bitmap data found in the file referenced by UNVName; returns a pictureHandle.  Expand the color palette to include the colors in the bitmap.  Supports more colors than pictures made with @Picture.make.
</cmt>
  </macro>
  <macro>
    <name>Picture.rotate</name>
    <act>Y</act>
    <stx>@Picture.rotate(pictureHandle,(+/-)degrees)</stx>
    <dsc>Rotates a picture the specified number of [degrees].</dsc>
    <code>#pR[@1,@2]</code>
    <cmt>If [degrees] is negative (eg. -90), the picture is rotated to the left.  If [degrees] is positive (eg. 90), the picture is rotated to the right.</cmt>
  </macro>
  <macro>
    <name>Picture.select</name>
    <act>Y</act>
    <stx>@Picture.select(row,column,height,width,pictureHandle,stretchFlag)</stx>
    <dsc>Show the picture specified by pictureHandle in the specified region</dsc>
    <code>#pS[@1,@2,@3,@4,@5,&quot;_IF{S[6];0}_IF{S[7] &quot;,@7&quot;}_&quot;]</code>
    <cmt>Show the picture specified by [pictureHandle] in the region specified by [row], [column], [height] and [width].  If [stretchFlag] = 0 then display the picture actual size and centered in the region.  If [stretchFlag] &gt; 0 then stretch or shrink the picture to fit the region.
</cmt>
  </macro>
  <macro>
    <name>Picture.shrink</name>
    <act>Y</act>
    <stx>@Picture.shrink(memoryHandle)</stx>
    <dsc>Removes unused colors from a bitmap image (stored in a memory buffer).</dsc>
    <code>#pK[@1]</code>
    <cmt>Used in utility programs only.  Not intended for general use.</cmt>
  </macro>
  <macro>
    <name>Picture.size</name>
    <act>Y</act>
    <stx>@Picture.size(pictureHandle,height,width,flag)</stx>
    <dsc>Resizes the picture specified by [pictureHandle] to [height] rows &amp; [width] cols</dsc>
    <code>#ps[@1,@2,@3,@4]</code>
    <cmt>[flag] is binary, specifying whether or not to keep the aspect ratio of the image.  If [flag]=1, the longer side of the image will be fit exactly to the size specified and the shorter side will be calculated apropriately.  If [flag]=0, the image will be sized to fit exactly in both directions (possibly causing some distortion of the image).
</cmt>
  </macro>
  <macro>
    <name>Prefix.name</name>
    <act>Y</act>
    <stx>prefix@Prefix.name</stx>
    <dsc>Changes the internal name of a prefix to an external form.</dsc>
    <code>@ZPN</code>
    <cmt>Internal name as returned by @Next.prefix.</cmt>
  </macro>
  <macro>
    <name>Prev</name>
    <act>Y</act>
    <stx>@Prev(element.name[,segment.name])</stx>
    <dsc>Produces code that gets the previous value for the subscript [element.name].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..nexting(^S)_&quot;</code>
    <cmt>If [segment.name] is specified, use it; else use @main.

Example:  @Prev(@MIS.USER.abs.tape.svc)   -&amp;(G)GU[gu]A[gsc]^gsc

For additional information and examples, see Looping Through Data Structures documentation on the Intranet.
</cmt>
  </macro>
  <macro>
    <name>Prev.get</name>
    <act>Y</act>
    <stx>@Prev.get(element.name[,segment.name],variable)</stx>
    <dsc>Get previous value for subscript [element.name] and place node value in [var]</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..nexting(^S)_&quot;</code>
    <cmt>Produces code that gets the previous value for the subscript [element.name] and sets [variable] to the value of the node at that subscript.  If [segment.name] is specified, use it; else use @main.

Example:  @Prev.get(@MIS.USER.abs.tape.svc,X)   -(&amp;(G)GU[gu]A[gsc],X)^gsc

For additional information and examples, see Looping Through Data Structures documentation on the Intranet.
</cmt>
  </macro>
  <macro>
    <name>Principal.device</name>
    <act>Y</act>
    <stx>O(&lt;prefix&gt;)@Principal.device</stx>
    <dsc>Allow the MagicCS &quot;principal device&quot; to be redefined.</dsc>
    <code>@ZPD</code>
    <cmt>This defines what is known as the &quot;principal device&quot; internally, and changes the meaning of opening a prefix to 0T.  By default, opening to 0T opens to the local user interface.  This syntax is used in the debugger, and possibly other places.  For 3-Tier, we don&apos;t want the debugger to open to the &quot;local&quot; interface, since that&apos;s on the application server.  Instead, we want to open to the user&apos;s MagicCS interface.  Hence, the 3-Tier IPL program opens # to the remote (client) user interface, and then executes O(#)@ZPD.</cmt>
  </macro>
  <macro>
    <name>Process.child.end</name>
    <act>Y</act>
    <stx>Process handle@Process.child.end</stx>
    <dsc>Ends a child process</dsc>
    <code>@CK</code>
    <cmt>Used with Create.process.suspended
</cmt>
  </macro>
  <macro>
    <name>Process.get.filename</name>
    <act>Y</act>
    <stx>HPROCESS@Process.get.filename</stx>
    <dsc>Returns the executable name of a process specified by a process handle.</dsc>
    <code>@Cx</code>
    <cmt>This is used by Services programs
</cmt>
  </macro>
  <macro>
    <name>Process.info</name>
    <act>Y</act>
    <stx/>
    <dsc>Return PID, thread id, process handle, thread handle</dsc>
    <code>@PI</code>
    <cmt>Returns:

&lt;ProcID&gt;.&lt;ThreadID&gt;.&lt;ProcH&gt;.&lt;ThreadH&gt;
</cmt>
  </macro>
  <macro>
    <name>Quote</name>
    <act>Y</act>
    <stx>@Quote(name)</stx>
    <dsc>Produces the translated version of name in quotation marks.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..functions(^S)_&quot;</code>
    <cmt>Example: @Quote(@MIS.USER.active)
Results in: &quot;&amp;(G)GU[gu]|0&quot;
</cmt>
  </macro>
  <macro>
    <name>RTF.bitmap</name>
    <act>Y</act>
    <stx>@RTF.bitmap(pictureFile)</stx>
    <dsc>Insert image from [pictureFile] into VMagicRT document at the current cursor pos</dsc>
    <code>#rB[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>RTF.close</name>
    <act>Y</act>
    <stx>@RTF.close(&quot;&quot;)</stx>
    <dsc>Close and release the rich text editor created with @RTF.start.</dsc>
    <code>#rX</code>
    <cmt/>
  </macro>
  <macro>
    <name>RTF.copy</name>
    <act>Y</act>
    <stx>@RTF.copy(memoryHandle,RTFFlag)</stx>
    <dsc>Get the selected contents into the memory buffer.</dsc>
    <code>#rG[@1,0,@2]</code>
    <cmt>RTFFlag:  0 = Text
          1 = RTF</cmt>
  </macro>
  <macro>
    <name>RTF.copy.all</name>
    <act>Y</act>
    <stx>@RTF.copy.all(memoryHandle,RTFFlag)</stx>
    <dsc>Get the entire document contents into the memory buffer.</dsc>
    <code>#rG[@1,1,@2]</code>
    <cmt>RTFFlag:  0 = Text
          1 = RTF</cmt>
  </macro>
  <macro>
    <name>RTF.flags</name>
    <act>N</act>
    <stx>@RTF.flags(Flags,FaceName,PointSize)</stx>
    <dsc>Changes the font of the body, header and/or footer in the current RTF Document</dsc>
    <code>#rf[@1,@2,@3]</code>
    <cmt>Changes the font of the body, header and/or footer in the current VMagicRT document.

Flags : 1 = Body, 2 = SelectAll, 4 = Header, 8 = Footer
Add the flags together for multiple functionality</cmt>
  </macro>
  <macro>
    <name>RTF.focus</name>
    <act>Y</act>
    <stx>@RTF.focus(mode)</stx>
    <dsc>Set focus to the rich text editor.  Returns the ExitKey.</dsc>
    <code>#rK[@1]</code>
    <cmt>[mode] = 0 for edit mode
       = 1 for preview mode</cmt>
  </macro>
  <macro>
    <name>RTF.font</name>
    <act>Y</act>
    <stx>@RTF.font(Flags,FaceName,PointSize)</stx>
    <dsc>Changes the font of the body, header and/or footer in the current RTF Document</dsc>
    <code>#rf[@1,@2,@3]</code>
    <cmt>Changes the font of the body, header and/or footer in the current VMagicRT document.

Flags : 1 = Body, 2 = SelectAll, 4 = Header, 8 = Footer
Add the flags together for multiple functionality</cmt>
  </macro>
  <macro>
    <name>RTF.footer</name>
    <act>Y</act>
    <stx>@RTF.footer(flag,memoryHandle)</stx>
    <dsc>Set document footer to plain text in the memory buffer.</dsc>
    <code>#rF[@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;]</code>
    <cmt>Special character sequences:

&amp;c = center what follows
&amp;r = right justify what follows
&amp;n = new line
&amp;l = horizontal line
&amp;p = current page #
&amp;t = total page count
&amp;&amp; = print an &amp;

The [flag] = 0 for the page 1 footer, and &gt;0 for page &gt;1 footers
</cmt>
  </macro>
  <macro>
    <name>RTF.header</name>
    <act>Y</act>
    <stx>@RTF.header(flag,memoryHandle)</stx>
    <dsc>Set document header to plain text in the memory buffer.</dsc>
    <code>#rH[@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;]</code>
    <cmt>Special character sequences:

&amp;c = center what follows
&amp;r = right justify what follows
&amp;n = new line
&amp;l = horizontal line
&amp;p = current page #
&amp;t = total page count
&amp;&amp; = print an &amp;

The [flag] = 0 for the page 1 footer, and &gt;0 for page &gt;1 footers
</cmt>
  </macro>
  <macro>
    <name>RTF.help</name>
    <act>Y</act>
    <stx>@RTF.help(path)</stx>
    <dsc>Invoke the Windows help file specified by path.</dsc>
    <code>#rh[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>RTF.hide</name>
    <act>Y</act>
    <stx>@RTF.hide(&quot;&quot;)</stx>
    <dsc>Hide the current instance of the rich text editor.</dsc>
    <code>#rD[0]</code>
    <cmt/>
  </macro>
  <macro>
    <name>RTF.info</name>
    <act>Y</act>
    <stx>@RTF.info(&quot;&quot;)</stx>
    <dsc>Query the rich editor for information.</dsc>
    <code>#rQ</code>
    <cmt>Returns:

{LineCount,CharacterCount,SelectionBegin,SelectionEnd,DirtyFlagYN}
</cmt>
  </macro>
  <macro>
    <name>RTF.listbox</name>
    <act>Y</act>
    <stx>@RTF.listbox(memoryHandle)</stx>
    <dsc>Displays a Windows ListBox in the Rich Text window.</dsc>
    <code>#rL[@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;]</code>
    <cmt>[memoryHandle] should point to a buffer containing &lt;CR&gt;&lt;LF&gt; delimited strings which are displayed in the ListBox.  Returns: Q(index,keyCode) where [index] is the zero-based index of the item selected on exit and [keyCode] specificies the terminating key.

</cmt>
  </macro>
  <macro>
    <name>RTF.message</name>
    <act>Y</act>
    <stx>@RTF.message(style,title,message)</stx>
    <dsc>Display/Ask a [message] in a window with [title].</dsc>
    <code>#rM[@1,@2,@3]</code>
    <cmt>[style]   Add together button:
   0 = Ok
   1 = Ok/Cancel
   2 = Abort/Retry/Ignore
   3 = Yes/No/Cancel
   4 = Yes/No
   5 = Retry/Cancel

[icon]
  16 = Stop
  32 = Question
  48 = Exclamation
  64 = Asterisk

Returns:  1=Ok
          2=Cancel
          3=Abort
          4=Retry
          5=Ignore
          6=Yes
          7=No

</cmt>
  </macro>
  <macro>
    <name>RTF.options</name>
    <act>Y</act>
    <stx>@RTF.options(option,flag)</stx>
    <dsc>Set/Clear an option.</dsc>
    <code>#rO[@1,@2]</code>
    <cmt>[option]
   0 = Read-only
   1 = Print-disable
   2 = Maximize window
   3 = Format
       flag 0 = Left Justify
            1 = Right Justify
            2 = Center
   4 = DirtyFlag
       flag 0 = Clear the flag
            1= Set the flag

[button]
 245 = Unsign button
 246 = Unsign button
 247 = PreviousReport button
 248 = NextReport button
 249 = EditReport button
 250 = StopSigning button
 251 = SendMessage button
 252 = SpecialFunction button
 253 - 255 = Not Defined Yet

[flag] - when option &apos;= 3 or 4 AND button - 251 or 252
         for other buttons, option &gt;0 is same as option = 1
   0 = off
   1 = on
   2 = hide
</cmt>
  </macro>
  <macro>
    <name>RTF.paste</name>
    <act>Y</act>
    <stx>@RTF.paste(memoryHandle,RTFFlag,dirtyFlag)</stx>
    <dsc>Replace the selected contents from the buffer.</dsc>
    <code>#rP[@1,0,@2,@3]</code>
    <cmt>[RTFFlag]
  0 = Text
  1 = RTF

If the contents of the buffer are RichText format, [RTFFlag]=0 will not make it Text.
If the contents of the buffer are Text format, [RTFFlag]=1 will make it RichText.

[dirtyFlag]
  0 = Do Not set the dirty state
  1 = DO set it
</cmt>
  </macro>
  <macro>
    <name>RTF.paste.all</name>
    <act>Y</act>
    <stx>@RTF.paste.all(memoryHandle,RTFFlag,dirtyFlag)</stx>
    <dsc>Replace the entire contents from the buffer.</dsc>
    <code>#rP[@1,1,@2,@3]</code>
    <cmt>[RTFFlag]
  0 = Text
  1 = RTF

If the contents of the buffer are RichText format, [RTFFlag]=0 will not make it Text.
If the contents of the buffer are Text format, [RTFFlag]=1 will make it RichText.

[dirtyFlag]
  0 = Do Not set the dirty state
  1 = DO set it
</cmt>
  </macro>
  <macro>
    <name>RTF.print</name>
    <act>Y</act>
    <stx>@RTF.print(Windows.printer[,FilePath])</stx>
    <dsc>Print to Windows printer specified.</dsc>
    <code>#rp[@1&quot;_IF{S[2] &quot;,@2]&quot;;&quot;]&quot;}_&quot;</code>
    <cmt>&quot;&quot; = default Windows printer.

&quot;ARCHIVE&quot; = Archive to file specified in second argument.  The second argument is only used for &quot;ARCHIVE&quot;.</cmt>
  </macro>
  <macro>
    <name>RTF.quick.text</name>
    <act>Y</act>
    <stx>@RTF.quick.text(memoryHandle)</stx>
    <dsc>Associate canned text and text &quot;mnemonics&quot; from [memoryHandle] for quick replace</dsc>
    <code>#rV[3,@1]</code>
    <cmt>There is a Rich Text Editor function to support something like MSWord Auto-Text.  In the Rich Text Editor, when a space or puctuation character is typed, the preceding word can be checked for possible replacement with some canned text previously associated with it.  The
association is made with this macro.

The [memoryHandle] must contain a MagicFS list as follows:
       {{Word|ReplacementText}|,...{Word|ReplacementText}}
</cmt>
  </macro>
  <macro>
    <name>RTF.running</name>
    <act>Y</act>
    <stx>@RTF.running(&quot;&quot;)</stx>
    <dsc>Used to check if the RTF is running.</dsc>
    <code>#rc</code>
    <cmt>will return a 1 if the RTF editor is running else nil.</cmt>
  </macro>
  <macro>
    <name>RTF.search</name>
    <act>Y</act>
    <stx>@RTF.search(String, How)</stx>
    <dsc>Search from the current cursor position to the end of the document</dsc>
    <code>#rs[@1,@2]</code>
    <cmt>#rs (@RTF.search) has been enhanced to accept further text search parameters from CS. Prior to this change, #rs would always perform a case sensitive search and match whole words only. Case sensitivity and the ability to search parts of words has been added.

2nd Arg       Case Sensitive  Whole Word
0 (default)   TRUE            TRUE
1             TRUE            FALSE
2             FALSE           TRUE
3             FALSE           FALSE

Or, turn on the 1st bit and partial word search will be activated, turn on the 2nd bit and the search will not be case sensitive.

Returns {Beginning character,length} or Nil.
</cmt>
  </macro>
  <macro>
    <name>RTF.select</name>
    <act>Y</act>
    <stx>@RTF.select(begChar,numChars,hideFlag)</stx>
    <dsc>Set the selection, starting at [begChar] for [numChars].</dsc>
    <code>#rS[@1,@2,@3]</code>
    <cmt>[hideFlag] = &quot;S&quot; means Show the selection; else means Don&apos;t.</cmt>
  </macro>
  <macro>
    <name>RTF.set.timeout</name>
    <act>Y</act>
    <stx>@RTF.set.timeout(seconds)</stx>
    <dsc>Sets the timeout for an RTF session</dsc>
    <code>#rT[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>RTF.show</name>
    <act>Y</act>
    <stx>@RTF.show(&quot;&quot;)</stx>
    <dsc>Show the current instance of the rich text editor.</dsc>
    <code>#rD[1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>RTF.spell.add.custom</name>
    <act>Y</act>
    <stx>@RTF.spell.add.custom(flag)</stx>
    <dsc>Add-to-Custom button.</dsc>
    <code>#rV[2,@1]</code>
    <cmt>[flag]
  0 = Disable
  1 = Enable</cmt>
  </macro>
  <macro>
    <name>RTF.spell.check</name>
    <act>Y</act>
    <stx>@RTF.spell.check(&quot;&quot;)</stx>
    <dsc>Call the Spellchecker on highlighted text; if none, all text.</dsc>
    <code>#rV[0]</code>
    <cmt/>
  </macro>
  <macro>
    <name>RTF.spell.dict</name>
    <act>Y</act>
    <stx>@RTF.spell.dict(flag,path)</stx>
    <dsc>Include custom dictionary located at path.</dsc>
    <code>#rV[1,@1,@2]</code>
    <cmt>[flag]
  0 = No
  1 = Yes</cmt>
  </macro>
  <macro>
    <name>RTF.start</name>
    <act>Y</act>
    <stx>@RTF.start(left,top,right,bottom,title[,altFont,signFlag])</stx>
    <dsc>Create an instance of the MEDITECH rich text editor.</dsc>
    <code>#rC[&quot;_IF{S[2] &quot;@1,@2,@3,@4,@5&quot;_IF{S[6] &quot;,@6&quot;_IF{S[7] &quot;,@7&quot;}};&quot;720,&quot;:4_S[1]}_&quot;]</code>
    <cmt>Start if not started, else clear.

[left], [top], [right], [bottom] are margins in twips (1440/inch).  Defaults to 0.5 inches (720 twips).

Set Document title to [title]

[altFont] specifies a font other than Arial as the default

If [signFlag] is true, use the alternate Toolbar and Menus for Report signing.

</cmt>
  </macro>
  <macro>
    <name>RTF.status.message</name>
    <act>Y</act>
    <stx>@RTF.status.message(text)</stx>
    <dsc>Display [text] in the status bar.</dsc>
    <code>#rI[@1]</code>
    <cmt>[text] = &quot;&quot; to remove any existing message.</cmt>
  </macro>
  <macro>
    <name>Read.mouse</name>
    <act>Y</act>
    <stx>@Read.mouse(&quot;&quot;)</stx>
    <dsc>Produces code to retrieve information about the most recent mouse click.</dsc>
    <code>#L^MOUSE</code>
    <cmt>Produces code to retrieve information about the most recent mouse click and save to local variable MOUSE.  The #L function also resets the mouse click monitor.

#L returns a list {targetType,targetID,targetRow,mouseButton,clickType,keyState}, or nil if there has been no mouse event since the last time #L was evaluated.

Field Meaning:

[targetType]   B=Button
               O=MouseTarget
               T=ToolbarButton
               F=PageTab

[targetID]     The identifier assigned to the target: either a buttonHandle or toolbarHandle                or folderHandle or mouseTargetID.

[targetRow]    If the target is a multi-row screen region, the offset in character rows from                the top of the region; otherwise, NIL.

[mouseButton]  L=Left
               R=Right

[clickType]    S=Single
               D=Double
               R=Repeat

[keyState]     S=Shift
               C=Ctrl
               nil=none of the above

</cmt>
  </macro>
  <macro>
    <name>Read.page</name>
    <act>Y</act>
    <stx>@Read.page(page)^#</stx>
    <dsc>Reads and displays page of a multi-page screen.</dsc>
    <code>D(22,0,@1)</code>
    <cmt>Note: The current page is not explicitly saved.  See also @Init.page and @Write.page.</cmt>
  </macro>
  <macro>
    <name>Registry.set.dword</name>
    <act>Y</act>
    <stx>@Registry.set.dword(keyName,valueName,valueValue)</stx>
    <dsc>Sets Windows NT registry double word value to [valueValue].</dsc>
    <code>#RS[@1,@2,@3,4]</code>
    <cmt>[keyName] = keyname from left pane of regedit
[valueName] = name from right pane of regedit
[valueValue] = double word value
</cmt>
  </macro>
  <macro>
    <name>Registry.set.string</name>
    <act>Y</act>
    <stx>@Registry.set.string(keyName,valueName,valueValue)</stx>
    <dsc>Sets Windows NT registry double word value to [valueValue].</dsc>
    <code>#RS[@1,@2,@3,1]</code>
    <cmt>[keyName] = keyname from left pane of regedit
[valueName] = name from right pane of regedit
[valueValue] = string value
</cmt>
  </macro>
  <macro>
    <name>Registry.subkeys</name>
    <act>Y</act>
    <stx>@Registry.subkeys(memoryHandle,keyPath)</stx>
    <dsc>Put Registry subkey information in the memory buffer.</dsc>
    <code>#RG[0,@1,@2]</code>
    <cmt>Returns the length of the data if successful, else NIL.  In the memory buffer, each subkey name is followed by a &lt;CRLF&gt;.
</cmt>
  </macro>
  <macro>
    <name>Registry.values</name>
    <act>Y</act>
    <stx>@Registry.values(memoryHandle,keyPath)</stx>
    <dsc>Put Registry name/value pairs in the memory buffer.</dsc>
    <code>#RG[1,@1,@2]</code>
    <cmt>Returns the length of the data if successful, else NIL.  In the memory buffer, each entry consists of a ValueName/ValueData pair.  Each name and data value are followed by &lt;CRLF&gt;.
</cmt>
  </macro>
  <macro>
    <name>Replace</name>
    <act>Y</act>
    <stx>@Replace(source,target)</stx>
    <dsc>Replace nodes at and below [target] with those at and below [source].</dsc>
    <code>G(@1,@2)</code>
    <cmt>Equivalent to a K([target]),M([source],[target]).</cmt>
  </macro>
  <macro>
    <name>Res.prefix</name>
    <act>Y</act>
    <stx>@Res.prefix(dpm.name,prefix1)</stx>
    <dsc>Restores references to any data element or structure in the DPM dpm.name</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..chg.prefix(^S)_&quot;</code>
    <cmt>Restores references to any data element or structure in the DPM [dpm.name] that uses [prefix1], previously changed by a @Chg.prefix macro, to the data definition.

Translation time only - no code produced.
</cmt>
  </macro>
  <macro>
    <name>Rgb</name>
    <act>Y</act>
    <stx>@Rgb(redValue,greenValue,blueValue)</stx>
    <dsc>Computes color from a red byte, a green byte, and a blue byte (0-255).</dsc>
    <code>@3*65536+(@2*256)+@1</code>
    <cmt/>
  </macro>
  <macro>
    <name>Root</name>
    <act>Y</act>
    <stx>@Root(@segment.name)</stx>
    <dsc>Translates to the root of the physical address of the specified [segment.name].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..nexting(^S)_&quot;</code>
    <cmt>Translates to the root of the physical address of the specified [segment.name].  The root is the physical address up to, but not including, the subscripts.

Example:  Let&apos;s say we had a segment called @events with the following physical address and subscripts:  *JA[ja]E[je]

The following use of the macro:
  @Root(@events) would produce: *JA[JA]E

This macro is useful for killing all occurrences of the same segment (eg., @Kill(@Root(@events)) would produce K(*JA[ja]E).

</cmt>
  </macro>
  <macro>
    <name>Row</name>
    <act>Y</act>
    <stx>@Row(field.name,screen or *)</stx>
    <dsc>Translates to the row number of [field.name] on [screen].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..screen(^S)_&quot;</code>
    <cmt>If the screen is part of the same procedure as the procedure logic, use *.</cmt>
  </macro>
  <macro>
    <name>SSL.acquire</name>
    <act>Y</act>
    <stx>{options,NonZeroIfServer}@SSL.acquire(buf)^Index</stx>
    <dsc>Generates a new SSL connection, assigns it a unique ID (Index)</dsc>
    <code>@WA</code>
    <cmt>options
     This decimal number is the sum of the decimal values for this connection&apos;s options,
     selected from the following list:

             2 SCH_CRED_NO_SYSTEM_MAPPER (server-side only)
               Prevent Schannel from using the built-in system certificate mapping functions
               to map client certificates to a Windows NT/2000 user account.
             4 SCH_CRED_NO_SERVERNAME_CHECK (client-side only)
               Prevent Schannel from comparing the supplied target name with the subject
               names in server certificates.
             8 SCH_CRED_MANUAL_CRED_VALIDATION (client-side only)
               Prevent Schannel from validating the received server certificate chain.
            16 SCH_CRED_NO_DEFAULT_CREDS (client-side only)
               Prevent Schannel from attempting to automatically supply a certificate chain
               for client authentication.
            32 SCH_CRED_AUTO_CRED_VALIDATION (client-side only)
               This flag is the opposite of SCH_CRED_MANUAL_CRED_VALIDATION and is part of
               the default behavior of Schannel.
            64 SCH_CRED_USE_DEFAULT_CREDS (client-side only)
               Schannel attempts to automatically supply a certificate chain for client
               authentication. Opposite of SCH_CRED_NO_DEFAULT_CREDS.
           128 SCH_CRED_DISABLE_RECONNECTS
           256 SCH_CRED_REVOCATION_CHECK_END_CERT
               When validating a certificate chain, check only the last certificate for
               revocation.
           512 SCH_CRED_REVOCATION_CHECK_CHAIN
               When validating a certificate chain, check all certificates for revocation.
          1024 SCH_CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT
               When validating a certificate chain, do not check the root for revocation.
          2048 SCH_CRED_IGNORE_NO_REVOCATION_CHECK
               When checking for revoked certificates, ignore CRYPT_E_NO_REVOCATION_CHECK
               errors.
          4096 SCH_CRED_IGNORE_REVOCATION_OFFLINE
               When checking for revoked certificates, ignore CRYPT_E_REVOCATION_OFFLINE
               errors.

     For example, if you want to enable only the following 2 options...

            16 SCH_CRED_NO_DEFAULT_CREDS (client-side only)
           256 SCH_CRED_REVOCATION_CHECK_END_CERT

     ...your value for the &quot;options&quot; argument would be 16+256 or 272.

NonZeroIfServer
     0 - client is establishing connection
     1 - server is establishing connection

buf
     address of SSL buffer&apos;s leading byte, returned by @Global.alloc

Index
     Unique identifier for this SSL connection.  1st connection from this session will be
     assigned 0, 2nd will be assigned 1, 3rd will be assigned 2, etc.</cmt>
  </macro>
  <macro>
    <name>SSL.close</name>
    <act>Y</act>
    <stx>{Index,bytecount}@SSL.close(buf)^Result</stx>
    <dsc>Closes the SSL connection referenced by Index</dsc>
    <code>@WC</code>
    <cmt>Index
     The unique ID of the SSL connection of interest, generated by the original @SSL.acquire

bytecount
     Since the connection is being closed, 0 can be used here

buf
     address of SSL buffer&apos;s leading byte, returned by @Global.alloc

Result
     |0 = result code
          0 - receipt of data is finished
          590615 - context expired
          other value - continue reading data
     |1 = length of data</cmt>
  </macro>
  <macro>
    <name>SSL.decrypt</name>
    <act>Y</act>
    <stx>{Index,bytecount}@SSL.decrypt(buf)^Result</stx>
    <dsc>Processes specified number of encrypted bytes in buf into decrypted data in buf</dsc>
    <code>@WD</code>
    <cmt>Index
     The unique ID of the SSL connection of interest, generated by the original @SSL.acquire

bytecount
     Number of bytes in buf to decrypt

buf
     address of SSL buffer&apos;s leading byte, returned by @Global.alloc

Result
     |0 = result code
          0 - no more data
          590625 - renegotiate requested
          590615 - context expired
          other value - more data to process
     |1 = length of data
     |2 = location of any extra data
     |3 = length of any extra data</cmt>
  </macro>
  <macro>
    <name>SSL.encrypt</name>
    <act>Y</act>
    <stx>{Index,bytecount}@SSL.encrypt(buf)^Result</stx>
    <dsc>Encrypts specified number of bytes from buf back into buf for transmission</dsc>
    <code>@WN</code>
    <cmt>Index
     The unique ID of the SSL connection of interest, generated by the original @SSL.acquire

bytecount
     Number of bytes in buf to encrypt

buf
     address of SSL buffer&apos;s leading byte, returned by @Global.alloc

Result
     |0 = result code
          0 - no more data
          other value - more data to process</cmt>
  </macro>
  <macro>
    <name>SSL.init</name>
    <act>Y</act>
    <stx>{Index,HOSTNAME}@SSL.init(buf)^Result</stx>
    <dsc>Initialize specified SSL connection on HOSTNAME</dsc>
    <code>@WI</code>
    <cmt>Index
     The unique ID of the SSL connection of interest, generated by the original @SSL.acquire

HOSTNAME
     The network name of the resource to which the SSL connection of interest has been made

buf
     address of SSL buffer&apos;s leading byte, returned by @Global.alloc

Result
     |0 = result code
          &gt;2147483648 - init failed
          other value - init successful</cmt>
  </macro>
  <macro>
    <name>SSL.negotiate</name>
    <act>Y</act>
    <stx>{Index,bytecount}@SSL.negotiate(buf)^Result</stx>
    <dsc>Allows machines at either end of SSL connection to establish encryption level</dsc>
    <code>@WG</code>
    <cmt>Index
     The unique ID of the SSL connection of interest, generated by the original @SSL.acquire

bytecount
     # of bytes of handshaking data to be sent

buf
     address of SSL buffer&apos;s leading byte, returned by @Global.alloc

Result
     |0 = result code
     |1 = length of data
     |2 = location of any extra data
     |3 = length of any extra data</cmt>
  </macro>
  <macro>
    <name>SSL.query</name>
    <act>Y</act>
    <stx>{Index,options}@SSL.query(buf)^Result</stx>
    <dsc>Polls SSL connection to return information about requested attribute(s)</dsc>
    <code>@WQ</code>
    <cmt>Index
     The unique ID of the SSL connection of interest, generated by the original @SSL.acquire

options
       1 SEC_PKG_NAMES
       2 SEC_PKG_LIFESPAN
       4 SEC_PKG_ATTR_SIZES
      90 SEC_PKG_CONN_INFO
     101 SEC_LOC_CERT_NAME
     201 SEC_REM_CERT_NAME

buf
     address of SSL buffer&apos;s leading byte, returned by @Global.alloc

Result
     |0 = result code
          0 - receipt of data is finished
     |1 = length of data</cmt>
  </macro>
  <macro>
    <name>SSL.uuidgen</name>
    <act>Y</act>
    <stx>@SSL.uuidgen^UUID</stx>
    <dsc/>
    <code>&quot;_D(34,34)_&quot;@WU&quot;_&quot;</code>
    <cmt/>
  </macro>
  <macro>
    <name>Screen.mult</name>
    <act>Y</act>
    <stx>@Screen.mult(element,screen or *)</stx>
    <dsc>Translates to temp array used for the multiple for which [element] is key field</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..screen(^S)_&quot;</code>
    <cmt>Translates to the temp array used for the multiple for which [element] is the key field.  If the screen is part of the same procedure as the procedure logic, use *.

In EP, this was /Tn (n=1..99).
</cmt>
  </macro>
  <macro>
    <name>Script.object.global</name>
    <act>Y</act>
    <stx>&quot;Code&quot;@Script.object.global(Arguments)</stx>
    <dsc>Allows VBScript or JScript code to be passed to VMagic and run</dsc>
    <code>@OG</code>
    <cmt>Allows VBScript or JScript code to be passed to VMagic and run.  Optional arguments become variables A, B, C ... in the script itself.

Code can be code or a handle to a file containing the code.

Use &quot;&quot;@Script.object.global to terminate the script.</cmt>
  </macro>
  <macro>
    <name>Script.object.key</name>
    <act>Y</act>
    <stx>A@Script.object.key</stx>
    <dsc>Returns the key for a licensed ActiveX control</dsc>
    <code>@1@OK</code>
    <cmt>Returns the key for a licensed ActiveX control where:

A = ProgId or CLSID</cmt>
  </macro>
  <macro>
    <name>Script.object.local</name>
    <act>Y</act>
    <stx>&quot;Code&quot;@Script.object.local(Arguments)</stx>
    <dsc>Allows VBScript or JScript code to be passed to VMagic and run</dsc>
    <code>@OL</code>
    <cmt>Allows VBScript or JScript code to be passed to VMagic and run.  Optional arguments become variables A, B, C ... in the script itself.

Code can be code or a handle to a file containing the code.

Use &quot;&quot;@Script.object.local to terminate the script.</cmt>
  </macro>
  <macro>
    <name>Scroll.bar.create</name>
    <act>Y</act>
    <stx>@Scroll.bar.create(scrollType,row,column,extent)</stx>
    <dsc>Creates a Scrollbar at the specified [row] and [column]; returns scrollHandle</dsc>
    <code>#sC[@1,@2,@3,@4]</code>
    <cmt>[scrollType]   &quot;H&quot; = Horizontal
               &quot;V&quot; = Vertical

[extent]       Number of columns if scrollType=H, number of rows if scrollType=V

If the user clicks the scrollbar the current read will be terminated.  #L returns a list:                                                                                                         {targetType,targetID,scrollPosition,mouseButton,clickEvent,newPosition}

[targetType]   B=Button
               O=MouseTarget
               T=ToolbarButton
               F=PageTab
               S=ScrollBar

[targetID]     The identifier assigned to the target: buttonHandle or toolbarHandle or                      folderHandle or mouseTargetID or scrollHandle.

[scrollPosition]   The position of the button prior to the event. This will always be a                         number 0 - 100.

[mouseButton]  L=Left
               R=Right

[clickEvent]   0 = Line Up/Left -- User clicked on of the arrows at the ends.
               1 = Line Down/Right -- User clicked on of the arrows at the ends.
               2 = Page Up/Left -- User clicked between the button and the arrows.
               3 = Page Down/Right -- User clicked between the button and the arrows.
               4 = Thumb Position -- User dragged the button and released it.

[newPosition]   The position at which the user left the button iff the clickEvent = 4.
</cmt>
  </macro>
  <macro>
    <name>Scroll.bar.delete</name>
    <act>Y</act>
    <stx>@Scroll.bar.delete(scrollHandle)</stx>
    <dsc>Delete the specified Scrollbar.</dsc>
    <code>#sX[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Scroll.bar.disable</name>
    <act>Y</act>
    <stx>@Scroll.bar.disable(scrollHandle)</stx>
    <dsc>Disable the specified Scrollbar.</dsc>
    <code>#sD[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Scroll.bar.enable</name>
    <act>Y</act>
    <stx>@Scroll.bar.enable(scrollHandle)</stx>
    <dsc>Enable the specified Scrollbar.</dsc>
    <code>#sE[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Scroll.bar.position</name>
    <act>Y</act>
    <stx>@Scroll.bar.position(scrollHandle,position)</stx>
    <dsc>Place the thumb button along the scrollbar at [position].</dsc>
    <code>#sP[@1,@2]</code>
    <cmt>When the user drags the button and deposits it somewhere along the bar, the scrollPosition piece of #L indicates where it was dropped, but Windows does not actually place the button there.  Similarly when any other scrollbar event takes place Windows does not actually move the button.  This function is to visually place the button and to set the internal scrollPosition value.</cmt>
  </macro>
  <macro>
    <name>Scroll.bar.thumb.size</name>
    <act>Y</act>
    <stx>@Scroll.bar.thumb.size(scrollHandle,thumbSize)</stx>
    <dsc>In Windows 95 ONLY, set the scrollbar &apos;thumb&apos; to the specified size.</dsc>
    <code>#sT[@1,@2]</code>
    <cmt>[thumbSize] may be a number 1 - 100 inclusive and should indicate what percentage of the data represented by the scrollbar is visible.  The `range&apos; of the scrollbar is affected by the thumb size; ie. if the thumb size is set to 20 then the appropriate positions are 0 - 80.
</cmt>
  </macro>
  <macro>
    <name>Scroll.both.down</name>
    <act>Y</act>
    <stx>@Scroll.both.down(row,column,height,width,num)</stx>
    <dsc>Scroll down [num] rows, atts/data at [row] and [column] of [height] and [width].</dsc>
    <code>D(16,@1,@2,19,10,@3,@4,@5)</code>
    <cmt>Scroll down [num] rows, the attributes and data (characters) in the region with left-hand corner at [row] and [column] of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Scroll.both.down.cur.pos</name>
    <act>Y</act>
    <stx>@Scroll.both.down.cur.pos(height,width,num)</stx>
    <dsc>Scroll down [num] rows, atts/data at current position of [height] and [width].</dsc>
    <code>D(19,10,@1,@2,@3)</code>
    <cmt>Scroll down [num] rows, the attributes and data (characters) in the region with left-hand corner at the current cursor position of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Scroll.both.left</name>
    <act>Y</act>
    <stx>@Scroll.both.left(row,column,height,width,num)</stx>
    <dsc>Scroll left [num] rows, atts/data at [row] and [column] of [height] and [width].</dsc>
    <code>D(16,@1,@2,19,11,@3,@4,@5)</code>
    <cmt>Scroll left [num] columns, the attributes and data (characters) in the region with left-hand corner at [row] and [column] of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Scroll.both.left.cur.pos</name>
    <act>Y</act>
    <stx>@Scroll.both.left.cur.pos(height,width,num)</stx>
    <dsc>Scroll left [num] rows, atts/data at current position of [height] and [width].</dsc>
    <code>D(19,11,@1,@2,@3)</code>
    <cmt>Scroll left [num] columns, the attributes and data (characters) in the region with left-hand corner at the current cursor position of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Scroll.both.right</name>
    <act>Y</act>
    <stx>@Scroll.both.right(row,column,height,width,num)</stx>
    <dsc>Scroll right [num] rows, atts/data at [row] and [column] of [height] and [width]</dsc>
    <code>D(16,@1,@2,19,9,@3,@4,@5)</code>
    <cmt>Scroll right [num] columns, the attributes and data (characters) in the region with left-hand corner at [row] and [column] of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Scroll.both.right.cur.pos</name>
    <act>Y</act>
    <stx>@Scroll.both.right.cur.pos(height,width,num)</stx>
    <dsc>Scroll right [num] rows, atts/data at current position of [height] and [width].</dsc>
    <code>D(19,9,@1,@2,@3)</code>
    <cmt>Scroll right [num] columns, the attributes and data (characters) in the region with left-hand corner at the current cursor position of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Scroll.both.up</name>
    <act>Y</act>
    <stx>@Scroll.both.up(row,column,height,width,num)</stx>
    <dsc>Scroll up [num] rows, atts/data at [row] and [column] of [height] and [width].</dsc>
    <code>D(16,@1,@2,19,8,@3,@4,@5)</code>
    <cmt>Scroll up [num] rows, the attributes and data (characters) in the region with left-hand corner at [row] and [column] of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Scroll.both.up.cur.pos</name>
    <act>Y</act>
    <stx>@Scroll.both.up.cur.pos(height,width,num)</stx>
    <dsc>Scroll up [num] rows, atts/data at current position of [height] and [width].</dsc>
    <code>D(19,8,@1,@2,@3)</code>
    <cmt>Scroll up [num] rows, the attributes and data (characters) in the region with left-hand corner at the current cursor position of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Scroll.down</name>
    <act>Y</act>
    <stx>@Scroll.down(row,column,height,width,num)</stx>
    <dsc>Scroll down [num] rows, data at [row] and [column] of [height] and [width].</dsc>
    <code>D(16,@1,@2,19,2,@3,@4,@5)</code>
    <cmt>Scroll down [num] rows, the data (characters) in the region with left-hand corner at [row] and [column] of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Scroll.down.cur.pos</name>
    <act>Y</act>
    <stx>@Scroll.down.cur.pos(height,width,num)</stx>
    <dsc>Scroll down [num] rows, data at current position of [height] and [width].</dsc>
    <code>D(19,2,@1,@2,@3)</code>
    <cmt>Scroll down [num] rows, the data (characters) in the region with left-hand corner at the current cursor position of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Scroll.left</name>
    <act>Y</act>
    <stx>@Scroll.left(row,column,height,width,num)</stx>
    <dsc>Scroll left [num] rows, data at [row] and [column] of [height] and [width].</dsc>
    <code>D(16,@1,@2,19,3,@3,@4,@5)</code>
    <cmt>Scroll left [num] columns, the data (characters) in the region with left-hand corner at [row] and [column] of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Scroll.left.cur.pos</name>
    <act>Y</act>
    <stx>@Scroll.left.cur.pos(height,width,num)</stx>
    <dsc>Scroll left [num] rows, data at current position of [height] and [width].</dsc>
    <code>D(19,3,@1,@2,@3)</code>
    <cmt>Scroll left [num] columns, the data (characters) in the region with left-hand corner at the current cursor position of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Scroll.right</name>
    <act>Y</act>
    <stx>@Scroll.right(row,column,height,width,num)</stx>
    <dsc>Scroll right [num] rows, data at [row] and [column] of [height] and [width].</dsc>
    <code>D(16,@1,@2,19,1,@3,@4,@5)</code>
    <cmt>Scroll right [num] columns, the data (characters) in the region with left-hand corner at [row] and [column] of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Scroll.right.cur.pos</name>
    <act>Y</act>
    <stx>@Scroll.right.cur.pos(height,width,num)</stx>
    <dsc>Scroll right [num] rows, data at current position of [height] and [width].</dsc>
    <code>D(19,1,@1,@2,@3)</code>
    <cmt>Scroll right [num] columns, the data (characters) in the region with left-hand corner at the current cursor position of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Scroll.up</name>
    <act>Y</act>
    <stx>@Scroll.up(row,column,height,width,num)</stx>
    <dsc>Scroll up [num] rows, data at [row] and [column] of [height] and [width].</dsc>
    <code>D(16,@1,@2,19,0,@3,@4,@5)</code>
    <cmt>Scroll up [num] rows, the data (characters) in the region with left-hand corner at [row] and [column] of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Scroll.up.cur.pos</name>
    <act>Y</act>
    <stx>@Scroll.up.cur.pos(height,width,num)</stx>
    <dsc>Scroll up [num] rows, data at current position of [height] and [width].</dsc>
    <code>D(19,0,@1,@2,@3)</code>
    <cmt>Scroll up [num] rows, the data (characters) in the region with left-hand corner at the current cursor position of [height] and [width].</cmt>
  </macro>
  <macro>
    <name>Semaphore.create</name>
    <act>Y</act>
    <stx>NAME@Semaphore.create(max)</stx>
    <dsc>Creates a optionally named semaphore with a maximum count of max and min of zero</dsc>
    <code>@SC</code>
    <cmt>Used for Windows events and Semaphores.  Returns nil on error, or handle on success.</cmt>
  </macro>
  <macro>
    <name>Semaphore.open</name>
    <act>Y</act>
    <stx>NAME@Semaphore.open</stx>
    <dsc>Opens to named semaphore.</dsc>
    <code>@SO</code>
    <cmt>Used for Windows events and Semaphores.  Returns nil on error, or handle on success.
</cmt>
  </macro>
  <macro>
    <name>Semaphore.release</name>
    <act>Y</act>
    <stx>NAME@Semaphore.release(count)</stx>
    <dsc>Releases one or more(count) resources from the semaphore.</dsc>
    <code>@SR</code>
    <cmt>Used for Windows events and Semaphores.</cmt>
  </macro>
  <macro>
    <name>Server.accept.conn.tcp</name>
    <act>Y</act>
    <stx/>
    <dsc>Accepts a new connection on TCP server</dsc>
    <code>@SD</code>
    <cmt>Used by Server IPL.</cmt>
  </macro>
  <macro>
    <name>Server.allocate</name>
    <act>Y</act>
    <stx>bytes@Server.allocate</stx>
    <dsc>Determines how many bytes the server will allocate for each client.</dsc>
    <code>@SA</code>
    <cmt>This allocation is used to remember the answer to the last question for that client.</cmt>
  </macro>
  <macro>
    <name>Server.delete</name>
    <act>Y</act>
    <stx>name@Server.delete</stx>
    <dsc>Removes the service</dsc>
    <code>@Sd</code>
    <cmt/>
  </macro>
  <macro>
    <name>Server.function</name>
    <act>Y</act>
    <stx/>
    <dsc>Special func that takes a raw packet read in from the network and pre-processes</dsc>
    <code>@SF</code>
    <cmt>This is a special purpose function that takes a raw packet read in from the network and does any pre-processing required before handing off the work to a worker thread.</cmt>
  </macro>
  <macro>
    <name>Server.init.tcp</name>
    <act>Y</act>
    <stx/>
    <dsc>Initialize the TCP service on a server.</dsc>
    <code>@SI</code>
    <cmt>Used by Server IPL.</cmt>
  </macro>
  <macro>
    <name>Server.install</name>
    <act>Y</act>
    <stx/>
    <dsc>This installs the running version of VMagic.exe as an NT service on the client.</dsc>
    <code>@Si</code>
    <cmt/>
  </macro>
  <macro>
    <name>Server.install.bbp</name>
    <act>Y</act>
    <stx/>
    <dsc>Installs the service with Big Buffer Pool switch on</dsc>
    <code>@Sj</code>
    <cmt>.
</cmt>
  </macro>
  <macro>
    <name>Server.listen.tcp</name>
    <act>Y</act>
    <stx/>
    <dsc>Listen for TCP connections on server</dsc>
    <code>@SL</code>
    <cmt>Used by server IPL.</cmt>
  </macro>
  <macro>
    <name>Server.mso</name>
    <act>Y</act>
    <stx/>
    <dsc>Sets MSO server</dsc>
    <code>@Sy</code>
    <cmt/>
  </macro>
  <macro>
    <name>Server.mso.port</name>
    <act>Y</act>
    <stx/>
    <dsc>Sets mso port</dsc>
    <code>@Sz</code>
    <cmt/>
  </macro>
  <macro>
    <name>Server.set.tcp</name>
    <act>Y</act>
    <stx>port@Server.set.tcp</stx>
    <dsc>Sets the TCP port the Service will listen on</dsc>
    <code>@Sl</code>
    <cmt>Use by the Server program.</cmt>
  </macro>
  <macro>
    <name>Service.install.bbp</name>
    <act></act>
    <stx></stx>
    <dsc/>
    <code></code>
    <cmt/>
  </macro>
  <macro>
    <name>Service.set.shutdown</name>
    <act>Y</act>
    <stx/>
    <dsc>Sets delay on acting upon Service Control Applet shutdown request</dsc>
    <code>@Ss</code>
    <cmt>This is used by Services programs.

SECONDS@Ss ==&gt; sets the delay time. Nil return indicates error. (don&apos;t pass in &gt;30)
&quot;&quot;@Ss ==&gt; returns the current value
</cmt>
  </macro>
  <macro>
    <name>Service.status.flag</name>
    <act>Y</act>
    <stx/>
    <dsc>Reads the status of the service.</dsc>
    <code>@Sf</code>
    <cmt>A value of 2 means that the service has been &quot;paused&quot;.  This function is used in the main loop of the server program to test whether the service has been asked to pause, and if so, hang for 1 second.
</cmt>
  </macro>
  <macro>
    <name>Session.state</name>
    <act>Y</act>
    <stx/>
    <dsc>Retrives font info ,max rows, and max cols of the current session</dsc>
    <code>#Us</code>
    <cmt>The #Us function will now return the max number of rows and
   columns for the current frame size:

          {height of current font in pixels,
          width of current font in pixels,
          color depth in bits,
          (R)egular or (L)arge size font,
          State of caps lock key 0 = off 1 = on,
          Maximum number of rows,
          Maximum number of columns}
 </cmt>
  </macro>
  <macro>
    <name>Set.font</name>
    <act>Y</act>
    <stx>@Set.font(font)</stx>
    <dsc>Set the current font.</dsc>
    <code>D(2,@1)</code>
    <cmt>[font]
  0 = Normal body font for the window, with descenders
  1 = Times New Roman Bold
  2 = MS Sans Serif Bold (proportional)
  3 = MS Sans Serif Light (proportional)
  4 = Windows&apos; System (proportional)
  5 = not used
  6 = MS Serif Bold (proportional)
  7 = Courier New Bold
  8 = Arial Bold
  9 = Swis721 Medium Bold
 10 = not used
 11 = not used
 12 = not used
 13 = not used
 14 = not used
 15 = Century Schoolbook


</cmt>
  </macro>
  <macro>
    <name>Set.font.size</name>
    <act>Y</act>
    <stx>@Set.font.size(font,face,charset,height,gap,extra,skip,weight,windowSizedepend)</stx>
    <dsc>Alters the default values for [font].</dsc>
    <code>D(17,@1,@2,@3,@4,@5,@6,@7,@8,@9)</code>
    <cmt>[face]
  0 = Meditech&apos;s GreatStone
  1 = Microsoft&apos;s Arial
  2 = Microsoft&apos;s Arial Bold
  3 = Windows&apos; System
  4 = Microsoft&apos;s Sans Serif
  5 = Microsoft&apos;s Times New Roman
  6 = Microsoft&apos;s Times New Roman
  7 = Microsoft&apos;s Serif
  8 = Courier New
  9 = Swis721 Md Bt
 10 = Century Schoolbook

The value of [charset] should be 0 unless dealing with a Meditech font; for that case, you should talk to a systems programmer.
</cmt>
  </macro>
  <macro>
    <name>Share.name</name>
    <act>Y</act>
    <stx>^prefix@Share.name</stx>
    <dsc>Returns the share name for a prefix.</dsc>
    <code>@ZSN</code>
    <cmt>Example: ^%@ZSN might return &quot;\\Genesis\E\VMagicPrograms\MTUNV.Universe\S52.Ring&quot;.</cmt>
  </macro>
  <macro>
    <name>Shell.execute</name>
    <act>Y</act>
    <stx>@Shell.execute(UNCName)</stx>
    <dsc>Invokes the ShellExecute function.</dsc>
    <code>#SE[@1]</code>
    <cmt>If [UNCName] points to an executable, such as Notepad.exe, the executable is invoked.  If [UNCName] points to a document, such as ABC.TXT, the associated program is executed and the document given as the in-line argument.  So, if Notepad is associated with .TXT files, this command is equivalent to running NOTEPAD.EXE ABC.TXT.  If no association exists for the document type, Windows displays the Open With dialog in an attempt to resolve the problem.</cmt>
  </macro>
  <macro>
    <name>Sleep</name>
    <act>Y</act>
    <stx>milliseconds@Sleep</stx>
    <dsc>Calls the Windows API to sleep for [milliseconds].</dsc>
    <code>@So</code>
    <cmt/>
  </macro>
  <macro>
    <name>Stack.pull.longword</name>
    <act>Y</act>
    <stx/>
    <dsc>Not for general use.  Used in server program only.</dsc>
    <code>@SP</code>
    <cmt/>
  </macro>
  <macro>
    <name>Sub</name>
    <act>Y</act>
    <stx>@Sub(arg1,arg2)</stx>
    <dsc>Subtracts [arg1] from [arg2] and places the result in [arg2].</dsc>
    <code>&quot;_IF{IF{S&apos;=2 %NPRLER(&quot;FN&quot;,S[0])},/ARG1.PARTS&lt;2 &quot;@2-@1^@2&quot;;&quot;@2-(@1)^@2&quot;}_&quot;</code>
    <cmt/>
  </macro>
  <macro>
    <name>Sub0</name>
    <act>Y</act>
    <stx>@Sub0(arg1,arg2)</stx>
    <dsc>Subtracts [arg1] from [arg2] and places the greater of 0 or the result in [arg2]</dsc>
    <code>&quot;_IF{IF{S&apos;=2 %NPRLER(&quot;FN&quot;,S[0])},/ARG1.PARTS&lt;2 &quot;@2-@1!0^@2&quot;;&quot;@2-(@1)!0^@2&quot;}_&quot;</code>
    <cmt/>
  </macro>
  <macro>
    <name>Suspend.main.thread</name>
    <act>Y</act>
    <stx/>
    <dsc>Suspends the main thread of a program.</dsc>
    <code>@ST</code>
    <cmt>Used by a secondary thread to temporarily suspend the main thread, while the secondary thread gathers information about it.  Repeating the command unsuspends the thread.</cmt>
  </macro>
  <macro>
    <name>Suspend.main.thread.conditional</name>
    <act>Y</act>
    <stx>arg@Suspend.main.thread.conditional</stx>
    <dsc>Threadsafe way to suspend the main thread</dsc>
    <code>@St</code>
    <cmt>The function has two forms: &lt;arg&gt;@St and &quot;&quot;@St. The first form is the request to suspend the main thread, and the argument is used as a flag to determine whether to &quot;force&quot; the suspension, regardless of whether the thread was in a good state to suspend. If 0 is supplied as the argument, the function will only suspend the main thread if the main thread gets to a &quot;good state&quot; to be suspended within a second. If a non-zero argument is supplied, the function will also wait up to a second, but will then suspend the main thread regardless of whether it has gotten to a good state. For the purposes of this discussion, a &quot;good state&quot; for suspension is either when the main thread has reached &quot;SWPCK&quot; (swap check) or is in a # read.

The function returns one of the following:
0: it was not a good time to suspend the main thread;
1: the main thread has been suspended, but *only* because the &quot;force&quot; flag was specified
2: the main thread reached SWPCK and is now suspended
&gt;1000: the main thread is waiting on the msg thread to complete a read and is now suspended

If the thread was suspended, it must subsequently be resumed by the same XO thread, via a call to @St with no argument. &quot;&quot;@St returns the previous suspend count on the main thread. If the previous suspend count was 1 then the thread was suspended and is now running.</cmt>
  </macro>
  <macro>
    <name>System.directory</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the Windows System directory, generally, C:\WINDOWS\SYSTEM.</dsc>
    <code>@DS</code>
    <cmt/>
  </macro>
  <macro>
    <name>Tape.close</name>
    <act>Y</act>
    <stx/>
    <dsc>Close mag tape drive.</dsc>
    <code>@ZTC</code>
    <cmt>Tape functions only work under Windows NT.</cmt>
  </macro>
  <macro>
    <name>Tape.open</name>
    <act>Y</act>
    <stx>drive@Tape.open</stx>
    <dsc>Open to tape [drive] and position at the beginning.</dsc>
    <code>@ZTO</code>
    <cmt>Tape functions only work under Windows NT.</cmt>
  </macro>
  <macro>
    <name>Tape.position</name>
    <act>Y</act>
    <stx>num@Tape.position</stx>
    <dsc>Advance until [num] end-of-file marks are found.</dsc>
    <code>@ZTP</code>
    <cmt>Tape functions only work under Windows NT.</cmt>
  </macro>
  <macro>
    <name>Tape.read</name>
    <act>Y</act>
    <stx>num@Tape.read</stx>
    <dsc>Read [num] bytes from tape.</dsc>
    <code>@ZTR</code>
    <cmt>Tape functions only work under Windows NT.</cmt>
  </macro>
  <macro>
    <name>Tape.set.block.size</name>
    <act>Y</act>
    <stx>blksz@Tape.set.block.size</stx>
    <dsc>Set tape block size.</dsc>
    <code>@ZTB</code>
    <cmt>Tape functions only work under Windows NT.</cmt>
  </macro>
  <macro>
    <name>Tape.status</name>
    <act>Y</act>
    <stx/>
    <dsc>Return the tape status which is set by all the tape functions.</dsc>
    <code>@ZTS</code>
    <cmt>Returns (this is a partial list):
    0 = No error
 1100 = End of media
 1101 = Filemark detected
 1104 = No data detected
 1110 = Media changed (normal after a @Tape.open)

Tape functions only work under Windows NT.
</cmt>
  </macro>
  <macro>
    <name>Tape.write</name>
    <act>Y</act>
    <stx>data@Tape.write</stx>
    <dsc>Write data to tape.</dsc>
    <code>@ZTW</code>
    <cmt>Returns bytes successfully written:  data$count.written.

Tape functions only work under Windows NT.</cmt>
  </macro>
  <macro>
    <name>Tape.write.filemark</name>
    <act>Y</act>
    <stx/>
    <dsc>Write an END OF FILE mark.</dsc>
    <code>@ZTM</code>
    <cmt>Tape functions only work under Windows NT.</cmt>
  </macro>
  <macro>
    <name>Temp.record</name>
    <act>Y</act>
    <stx>@Temp.record(letter,segment)</stx>
    <dsc>Translates all [segment] references to the syntaxes used by @Est.t.rec.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.t.rec(^S)_&quot;</code>
    <cmt>Example:  @Temp.record(A,@ADM.PAT.main) translates to /(.TA)AA[aa].
</cmt>
  </macro>
  <macro>
    <name>Temp.record.prefix</name>
    <act>Y</act>
    <stx>@Temp.record.prefix(letter)</stx>
    <dsc>Translates to the prefix syntax for [letter] used by @Est.t.rec.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.t.rec(^S)_&quot;</code>
    <cmt>Examples:  @Temp.record.prefix(A) translates to /(.TA)
           @Move(@ADM.PAT.main,@Temp.record.prefix(A)) --&gt; M($(A)AA[aa],/(.TA))
</cmt>
  </macro>
  <macro>
    <name>Temp.structure.size</name>
    <act>Y</act>
    <stx>^prefix@Temp.structure.size</stx>
    <dsc>Returns size of p-structure</dsc>
    <code>@Gz</code>
    <cmt>Prefix must be open to a p-structure or the macro will return nil.</cmt>
  </macro>
  <macro>
    <name>Term.assembly.date</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the date/time stamp of the user interface portion of VMagic.exe</dsc>
    <code>#VN</code>
    <cmt/>
  </macro>
  <macro>
    <name>Term.desktop.res.horz</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns current desktop horizontal resolution in pixels.</dsc>
    <code>#Q[9]|0</code>
    <cmt/>
  </macro>
  <macro>
    <name>Term.desktop.res.vert</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns current desktop vertical resolution in pixels.</dsc>
    <code>#Q[9]|1</code>
    <cmt/>
  </macro>
  <macro>
    <name>Term.mode</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns what mode TERM is in regards to the creation of a Window.</dsc>
    <code>#Uh</code>
    <cmt>{Headless mode,crash/no-op}

Headless mode means that there is no Window so no ^# or # reads can be done.  Many # functions will still work.

Crash/no-op is what TERM will do when it runs into a function when in headless mode.

@Term.mode[1 or 0] will set the crash/no-op mode.
</cmt>
  </macro>
  <macro>
    <name>Term.window.size</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the size of the current term window.</dsc>
    <code>#Q[9]|2</code>
    <cmt>Returns 1 character, either &quot;R&quot; for regular or &quot;L&quot; for large.</cmt>
  </macro>
  <macro>
    <name>Text.create</name>
    <act>Y</act>
    <stx>@Text.create(row,column,height,width,memoryHandle,ww)</stx>
    <dsc>Creates an edit region and returns a handle to that region.</dsc>
    <code>#eC[@1,@2,@3,@4,@5,@6]</code>
    <cmt>This macro does not cause the display of data.  The word wrap parameter, [ww], is required and must be set to non-nil to cause automatic word wrapping of text.  A nil value forces a requirement that carriage returns break the lines within the region.  Designed for a multiline edit capability, this function requires the height parameter be greater than 1.

The [memoryHandle] is returned from @Memory.allocate function.

Edit regions are stacked/unstacked with window opens/closes.  Their buffer spaces are unaffected by windows.
</cmt>
  </macro>
  <macro>
    <name>Text.cursor.pos</name>
    <act>Y</act>
    <stx>@Text.cursor.pos(editHandle)</stx>
    <dsc>Returns Q(Row,Column) as character positions relative to the ULHC of edit region</dsc>
    <code>#eP[@1]</code>
    <cmt>UHLC = Upper-left-hand-corner</cmt>
  </macro>
  <macro>
    <name>Text.delete</name>
    <act>Y</act>
    <stx>@Text.delete(editHandle)</stx>
    <dsc>Deletes an edit region.</dsc>
    <code>#eX[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Text.disp</name>
    <act>Y</act>
    <stx>@Text.disp(editHandle)</stx>
    <dsc>Displays the memory buffer&apos;s contents.</dsc>
    <code>#eS[@1]</code>
    <cmt>The display function returns a two piece list, {ulhc, cursor}, where &apos;ulhc&apos; stands for &quot;upper left-hand corner&quot; of the region.</cmt>
  </macro>
  <macro>
    <name>Text.edit</name>
    <act>Y</act>
    <stx>@Text.edit(editHandle)</stx>
    <dsc>Displays the memory buffer&apos;s contents and allows it to be edited.</dsc>
    <code>#eE[@1]</code>
    <cmt>This multi-line edit function is mouse active.  It returns a two piece list, {ulhc, cursor}, where ulhc is the character position displayed in the upper left-hand corner of the edit region and cursor is the cursor postion at the time the edit function terminates.</cmt>
  </macro>
  <macro>
    <name>Text.highlight</name>
    <act>Y</act>
    <stx>@Text.highlight(editHandle,length)</stx>
    <dsc>Highlights the string starting at the current cursor position for [length] bytes</dsc>
    <code>#eH[@1,@2]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Text.length</name>
    <act>Y</act>
    <stx>@Text.length(font,string)</stx>
    <dsc>Returns the length of the [string] in the specified [font].</dsc>
    <code>#l[@1,@2]</code>
    <cmt>If [font] is NIL, return the length in the current font.  &quot;H&quot; may be used as [font] for Header (Title Bar) font. </cmt>
  </macro>
  <macro>
    <name>Text.mult</name>
    <act>Y</act>
    <stx>@Text.mult(element,screen or *)</stx>
    <dsc>Temp array used for the multi-line text editor for which [element] is key field</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..screen(^S)_&quot;</code>
    <cmt>Translates to the temp array used for the multi-line text editor for which [element] is the key field.  If the [screen] is part of the same procedure as the procedure logic, use *.</cmt>
  </macro>
  <macro>
    <name>Text.opaque</name>
    <act>Y</act>
    <stx>@Text.opaque(&quot;&quot;)</stx>
    <dsc>Changes display mode to opaque - display both background and foreground colors.</dsc>
    <code>D(25,2,0)</code>
    <cmt>This is the &quot;normal&quot; mode.</cmt>
  </macro>
  <macro>
    <name>Text.out</name>
    <act>Y</act>
    <stx>@Text.out(text)</stx>
    <dsc>Changes control chars to spaces and strips terminal control chars from [text]</dsc>
    <code>(._@1:0XS%0)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Text.transparent</name>
    <act>Y</act>
    <stx>@Text.transparent(&quot;&quot;)</stx>
    <dsc>Changes display mode to transparent - display only foreground color.</dsc>
    <code>D(25,2,1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Text.view</name>
    <act>Y</act>
    <stx>@Text.view(editHandle)</stx>
    <dsc>Displays the memory buffer&apos;s contents and allows it to be read only.</dsc>
    <code>#eR[@1]</code>
    <cmt>The region can be scrolled up and down one line or a page at a time.  The view can also be moved to the beginning or the end of the memory buffer&apos;s contents.  There is no visible cursor.  This read function returns a two piece list, {ulhc, cursor}, where ulhc is the character position displayed in the upper left-hand corner of the edit region and cursor is the cursor postion at the time the edit function terminates.</cmt>
  </macro>
  <macro>
    <name>Thread.critical.write</name>
    <act>Y</act>
    <stx/>
    <dsc>Changes or displays the thread&apos;s critical write mode</dsc>
    <code>@CT</code>
    <cmt>&quot;&quot;@Thread.critical.write will reset the thread&apos;s critical write mode to the process&apos; default mode. value@Thread.critical.write will establish a new CW mode for the thread. When a thread is newly dispatched, it starts with the process default value. This function allows the programmer to temporarily change that mode.</cmt>
  </macro>
  <macro>
    <name>Thread.error.code</name>
    <act>Y</act>
    <stx>code@Thread.error.code</stx>
    <dsc>Code that provides a worker thread code to &quot;clean up&quot; if unexpected error occurs</dsc>
    <code>@XE</code>
    <cmt>This is very much like X() for programs.  Worker threads, however, run a simpler dialect of the language, have smaller amounts of code to execute, and don&apos;t make program calls. </cmt>
  </macro>
  <macro>
    <name>Thread.resume</name>
    <act>Y</act>
    <stx>threadhandle@Thread.resume</stx>
    <dsc>Resumes the process started by Create.process.extra</dsc>
    <code>@TR</code>
    <cmt>used by windows thread code.</cmt>
  </macro>
  <macro>
    <name>Thread.vector.type</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns thread protocol version</dsc>
    <code>@Tv</code>
    <cmt>Used by system programs.</cmt>
  </macro>
  <macro>
    <name>Timeserver.code</name>
    <act>N</act>
    <stx/>
    <dsc>This is code is used with an @Execute.object.udp (@XU) to get a server&apos;s time</dsc>
    <code>&quot;_D(34)_&quot;B@NT,S(0)_C@GW(A)@NW;&quot;_D(34)_&quot;</code>
    <cmt>Example:   O(?S,&quot;S&quot;),@Execute.object.udp(@Timeserver.code,%(Z))^?S,C(?U)
This would set your session&apos;s time to the server time pointed to by %(Z).
</cmt>
  </macro>
  <macro>
    <name>Timeserver.port</name>
    <act>Y</act>
    <stx>ip1.ip2.ip3.ip4.port@Timeserver.port</stx>
    <dsc>Defines your &quot;timeserver&quot; for S(0) values</dsc>
    <code>@ZTK</code>
    <cmt>If a timeserver is defined, S(0) queries are redirected to the server at that address.

Example: &quot;Genesis&quot;@.machine.ip_.2989@Timeserver.port to use Genesis as the timeserver.

Currently, the only valid MagicCS port number is 2989.

</cmt>
  </macro>
  <macro>
    <name>Title</name>
    <act>Y</act>
    <stx>@Title(arg1,arg2,...,argn)</stx>
    <dsc>Performs internal-to-external conversions on arguments; returns arg string</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt/>
  </macro>
  <macro>
    <name>Tool.button.bitmap</name>
    <act>Y</act>
    <stx>@Tool.button.bitmap(handle,UNCName)</stx>
    <dsc>Change the picture for the tool button specified by [handle].</dsc>
    <code>#tB[@1,@2]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Tool.button.delete</name>
    <act>Y</act>
    <stx>@Tool.button.delete(toolbarHandle)</stx>
    <dsc>Delete the toolbar button.</dsc>
    <code>#tX[@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Tool.button.disable</name>
    <act>Y</act>
    <stx>@Tool.button.disable(toolbarHandle)</stx>
    <dsc>Disable the toolbar button.</dsc>
    <code>#tD[@1]</code>
    <cmt>The image will be &quot;greyed&quot; and no mouse clicks will be processed for the button.</cmt>
  </macro>
  <macro>
    <name>Tool.button.enable</name>
    <act>Y</act>
    <stx>@Tool.button.enable(toolbarHandle)</stx>
    <dsc>Enable the toolbar button.</dsc>
    <code>#tE[@1]</code>
    <cmt>The image will return to its &apos;unpressed&apos; state and mouse clicks will again be processed for the button.</cmt>
  </macro>
  <macro>
    <name>Tool.button.insert</name>
    <act>Y</act>
    <stx>@Tool.button.insert(section,position,handle,UNCName)</stx>
    <dsc>Inserts a tool at the specified [position]</dsc>
    <code>#tI[@1,@2,@3,@4]</code>
    <cmt>[section] may be either &quot;T&quot; (tool) or &quot;S&quot; (separator).  [position] is a zero-based index from the top of the toolbar, indicating the position the new tool should occupy.  The tool currently occupying that position and all tools `south&apos; of there are moved down.  If a position larger than that of the last tool is specified, the new tool is appended at the end.
</cmt>
  </macro>
  <macro>
    <name>Tool.button.make</name>
    <act>Y</act>
    <stx>@Tool.button.make(toolbarSection,slot#,pictureHandle,UNCName)</stx>
    <dsc>Create a toolbar button using the picture contained in [UNCName].</dsc>
    <code>#tM[@1,@2,@3,@4]</code>
    <cmt>[toolbarSection] and [slot#] are obsolete arguments.  New tool buttons are appended to the end of the toolbar.</cmt>
  </macro>
  <macro>
    <name>Tool.button.tip</name>
    <act>Y</act>
    <stx>@Tool.button.tip(toolbarHandle,text)</stx>
    <dsc>Create a tooltip with the specified [text] for the specified toolbar button.</dsc>
    <code>#tT[@1,@2]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Toolbar.create</name>
    <act>Y</act>
    <stx>@Toolbar.create(memoryHandle)</stx>
    <dsc>Loads the toolbar from the contents of the memory buffer.</dsc>
    <code>#tL[@1]</code>
    <cmt>The buffer must contain one &lt;CRLF&gt; delimited entry for each tool.  Each entry must be a semicolon(;) delimited string with the following format:

section(&quot;T&quot; or &quot;S&quot;);slot#;handle;&lt;Path&gt;filename(where the picture is);tooltipText

[section]  &quot;T&quot; indicates that this is a tool button.
           &quot;S&quot; indicates that the tool is a separator... all susequent args are ignored for                   separators.
           &quot;B&quot; was the indicator for bottom... no longer allowed.
[handle] is the value to be returned when the button is clicked.
</cmt>
  </macro>
  <macro>
    <name>Toolbar.destroy</name>
    <act>Y</act>
    <stx>@Toolbar.destroy(&quot;&quot;)</stx>
    <dsc>Unloads the toolbar; deletes all toolbar buttons at once.</dsc>
    <code>#tU</code>
    <cmt/>
  </macro>
  <macro>
    <name>Tr.b2h</name>
    <act>Y</act>
    <stx/>
    <dsc/>
    <code>@BH</code>
    <cmt/>
  </macro>
  <macro>
    <name>Tr.b2s</name>
    <act>Y</act>
    <stx>arg@Tr.b2s</stx>
    <dsc>Converts a four byte binary value [arg] to an integer in 0 to 2**32 range</dsc>
    <code>@BS</code>
    <cmt/>
  </macro>
  <macro>
    <name>Tr.h2b</name>
    <act>Y</act>
    <stx/>
    <dsc/>
    <code>@HB</code>
    <cmt/>
  </macro>
  <macro>
    <name>Tr.h2s</name>
    <act>Y</act>
    <stx/>
    <dsc>Converts hex to a string</dsc>
    <code>@HS</code>
    <cmt>Converts hex to a string</cmt>
  </macro>
  <macro>
    <name>Tr.l2u</name>
    <act>Y</act>
    <stx>string@Tr.l2u</stx>
    <dsc>Convert (translate) [string] from lower to upper case.</dsc>
    <code>@LU</code>
    <cmt/>
  </macro>
  <macro>
    <name>Tr.s2b</name>
    <act>Y</act>
    <stx>arg@Tr.s2b</stx>
    <dsc>Converts an integer [arg] in the 0 to 2**32 range to 4 byte binary value.</dsc>
    <code>@SB</code>
    <cmt/>
  </macro>
  <macro>
    <name>Tr.s2h</name>
    <act>Y</act>
    <stx/>
    <dsc>Converts a string to Hex representation</dsc>
    <code>@SH</code>
    <cmt>Converts a string to Hex representation</cmt>
  </macro>
  <macro>
    <name>Tr.u2l</name>
    <act>Y</act>
    <stx>string@Tr.u2l</stx>
    <dsc>Convert (translate) [string] from upper to lower case.</dsc>
    <code>@UL</code>
    <cmt/>
  </macro>
  <macro>
    <name>Translation.message</name>
    <act>Y</act>
    <stx>@Translation.message(msg)</stx>
    <dsc>Displays a message on the device to which the translation output is directed.</dsc>
    <code>&quot;_IF{N(&quot;*** TRANSLATION MSG:&quot;,S[1])^!,D(34)_&quot;trans. msg&quot;_D(34)}_&quot;</code>
    <cmt>For example, the following use of the macro:
     @Translation.message(&quot;This calculates earnings.&quot;)

would result in the following message during translation:
     *** TRANSLATION MSG: &quot;This calculates earnings.&quot;

Also, the macro places the following string directly in the object code:
     &quot;trans. msg&quot;

</cmt>
  </macro>
  <macro>
    <name>Try.to.lock</name>
    <act>Y</act>
    <stx>@Try.to.lock(node[,waitMessage,lockFails,lockIsMine,lockExists,lockduration])</stx>
    <dsc>Attempts to write a lock for a record.  Returns 1 if lock written, else NIL.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..locks(^S)_&quot;</code>
    <cmt>[waitMessage]  Ignored.

[lockFails]    &quot;MSG&quot;= If lock fails, write message and return
                  0 = If lock fails, no message, and return
                n&gt;0 = If lock fails, &quot;waiting&quot; messages, loop n times before failing and                             return
                NIL = If lock fails, ask to wait. (If background job, set lockFails to a                               positive number.)

[lockIsMine]   NON-NIL = If the lock exists and belongs to this user, do not update the lock                             (default is to update)

[lockExists]   NON-NIL = If the lock exists, do not check to see if the lock has expired                             (default is to check)
                   NIL = If the lock exists, do check and if lock as expired, ask the user                            if they want to preempt the lock, if they do, clear it.

[lockDuration]    Time in minutes that a lock should not expire.

Z.lock.msg = Optional line near top of message.
The Z.lock.msg is only looked at by the locking system.  It will not modify it in anyway.

Unlike the @Lock macro, which always waits until the lock can be written, this macro provides several options in the case that a lock already exists for the record.  For general information on locks, see Locks documentation on the Intranet.
</cmt>
  </macro>
  <macro>
    <name>Try.to.lock.for.ui</name>
    <act>Y</act>
    <stx>@Try.to.lock(node[,waitMessage,lockFails,lockIsMine,lockExists,lockduration])</stx>
    <dsc>Attempts to write a lock for a record, this lock is same user preemptable.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..locks(^S)_&quot;</code>
    <cmt>[waitMessage]   Ignored.

[lockFails]    &quot;MSG&quot;= If lock fails, write message and return
                  0 = If lock fails, no message, and return
                n&gt;0 = If lock fails, &quot;waiting&quot; messages, loop n times before failing and                             return
                NIL = If lock fails, ask to wait. (If background job, set lockFails to a                               positive number.)

[lockIsMine]   NON-NIL = If the lock exists and belongs to this user, do not update the lock                             (default is to update)

[lockExists]   NON-NIL = If the lock exists, do not check to see if the &quot;owner&quot; is alive                                 (default is to check)
                   NIL = If the lock exists, do check and if job is dead, reset the lock for                             this user.
[lockDuration]  Time in minutes that a lock should not expire.
Z.lock.msg = Optional line near top of message.
The Z.lock.msg is only looked at by the locking system.  It will not modify it in anyway.

Unlike the @Lock macro, which always waits until the lock can be written, this macro provides several options in the case that a lock already exists for the record.  For general information on locks, see Locks documentation on the Intranet.
</cmt>
  </macro>
  <macro>
    <name>Txn.mode</name>
    <act>Y</act>
    <stx/>
    <dsc>enable/disable processing structure changes transactionally</dsc>
    <code>@TX</code>
    <cmt>This function should only be used in the server IPL program, and generally only in a clustered environment.</cmt>
  </macro>
  <macro>
    <name>UI.ChgTitle</name>
    <act>N</act>
    <stx>@UI.ChgTitle(Title)</stx>
    <dsc>Changes the window title</dsc>
    <code>%(NPR)UI..window(&quot;_D(34)_&quot;TITLE&quot;_D(34)_&quot;,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.Initialize</name>
    <act>N</act>
    <stx>@UI.Initialize(Title,Function WT,Footer HT,Header HT)</stx>
    <dsc>Initializes the new User Interface</dsc>
    <code>%(NPR)UI..initialize</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.ade.date.entry</name>
    <act>Y</act>
    <stx>@UI.ade.date.entry(&quot;&quot;)</stx>
    <dsc>Opens a new window with the Assisted Data Entry - Date Entry tool loaded</dsc>
    <code>%(NPR)Z.UI..assisted.data.entry(&quot;_D(34,34)_&quot;,&quot;_D(34)_&quot;DE&quot;_D(34)_&quot;)</code>
    <cmt>User preferences that can be specified for this tool:

  -  @NPR.Z.UI.ade.title
  -  @NPR.Z.UI.ade.de.start.date
  -  @NPR.Z.UI.ade.de.earliest.date
  -  @NPR.Z.UI.ade.de.latest.date
  -  @NPR.Z.UI.ade.dte.ok.enable


Returns &quot;OK&quot; if the Assisted Data Entry window was closed due to the user clicking the OK button or hitting the &lt;F12&gt; key.  Otherwise nil is returned.  This is necessary to differentiate between getting nil results because the user cancelled vs. getting nil because the user chose nil and hit OK.</cmt>
  </macro>
  <macro>
    <name>UI.ade.date.time.entry</name>
    <act>Y</act>
    <stx>@UI.ade.date.time.entry(&quot;&quot;)</stx>
    <dsc>Opens a new window with the Assisted Data Entry - Date / Time Entry tool loaded</dsc>
    <code>%(NPR)Z.UI..assisted.data.entry(&quot;_D(34,34)_&quot;,&quot;_D(34)_&quot;DTE&quot;_D(34)_&quot;)</code>
    <cmt>User preferences that can be specified for this tool:

  -  @NPR.Z.UI.ade.title
  -  @NPR.Z.UI.ade.de.start.date
  -  @NPR.Z.UI.ade.de.earliest.date
  -  @NPR.Z.UI.ade.de.latest.date
  -  @NPR.Z.UI.ade.te.start.time
  -  @NPR.Z.UI.ade.te.earliest.time
  -  @NPR.Z.UI.ade.te.latest.time
  -  @NPR.Z.UI.ade.dte.time.not.req
  -  @NPR.Z.UI.ade.dte.ok.enable


Returns &quot;OK&quot; if the Assisted Data Entry window was closed due to the user clicking the OK button or hitting the &lt;F12&gt; key.  Otherwise nil is returned.  This is necessary to differentiate between getting nil results because the user cancelled vs. getting nil because the user chose nil and hit OK.
</cmt>
  </macro>
  <macro>
    <name>UI.ade.numeric.keypad</name>
    <act>Y</act>
    <stx>@UI.ade.numeric.keypad(&quot;&quot;)</stx>
    <dsc>Opens a new window with the Assisted Data Entry - Numeric Keypad tool loaded</dsc>
    <code>%(NPR)Z.UI..assisted.data.entry(&quot;_D(34,34)_&quot;,&quot;_D(34)_&quot;NKP&quot;_D(34)_&quot;)</code>
    <cmt>User preferences that can be specified for this tool:

  -  @NPR.Z.UI.ade.title
  -  @NPR.Z.UI.ade.nkp.normal.range
  -  @NPR.Z.UI.ade.nkp.units
  -  @NPR.Z.UI.ade.nkp.inc.dec.btn
  -  @NPR.Z.UI.ade.nkp.inc.pos.neg.btn
  -  @NPR.Z.UI.ade.nkp.input.range.low
  -  @NPR.Z.UI.ade.nkp.input.range.high
  -  @NPR.Z.UI.ade.nkp.result.max.length
  -  @NPR.Z.UI.ade.nkp.start.entry
  -  @NPR.Z.UI.ade.nkp.ok.enable


Returns &quot;OK&quot; if the Assisted Data Entry window was closed due to the user clicking the OK button or hitting the &lt;F12&gt; key.  Otherwise nil is returned.  This is necessary to differentiate between getting nil results because the user cancelled vs. getting nil because the user chose nil and hit OK.</cmt>
  </macro>
  <macro>
    <name>UI.ade.time.entry</name>
    <act>Y</act>
    <stx>@UI.ade.time.entry(&quot;&quot;)</stx>
    <dsc>Opens a new window with the Assisted Data Entry - Time Entry tool loaded</dsc>
    <code>%(NPR)Z.UI..assisted.data.entry(&quot;_D(34,34)_&quot;,&quot;_D(34)_&quot;TE&quot;_D(34)_&quot;)</code>
    <cmt>User preferences that can be specified for this tool:

  -  @NPR.Z.UI.ade.title
  -  @NPR.Z.UI.ade.te.start.time
  -  @NPR.Z.UI.ade.te.earliest.time
  -  @NPR.Z.UI.ade.te.latest.time
  -  @NPR.Z.UI.ade.dte.ok.enable


Returns &quot;OK&quot; if the Assisted Data Entry window was closed due to the user clicking the OK button or hitting the &lt;F12&gt; key.  Otherwise nil is returned.  This is necessary to differentiate between getting nil results because the user cancelled vs. getting nil because the user chose nil and hit OK.
</cmt>
  </macro>
  <macro>
    <name>UI.button.get.state</name>
    <act>Y</act>
    <stx>@UI.button.get.state(BtnGroupID,ButtonAppId)</stx>
    <dsc>Check and returns state of a single or list of buttons.</dsc>
    <code>%(NPR)UI..m.btn.state(@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;)</code>
    <cmt>BtnGroupID is the id that was passed in when the buttons were created.  If the buttons were created on either the Function Bar or Footer, than the Group id is @UI.r.func.bar &amp; @UI.r.footer, respectively.

If only GroupID is passed in, then all the buttons that are contained in that group are returned. It is returned into the @NPR.Z.UI.tmp.button.states structure. The macro returns nil.

If both the GroupID and a ButtonAppId are passed in, then the macro will return that button&apos;s state.</cmt>
  </macro>
  <macro>
    <name>UI.button.grp.exists</name>
    <act>Y</act>
    <stx>@UI.button.grp.exists(BtnGroupId)</stx>
    <dsc>Determines if the Button Group Exists on the Screen</dsc>
    <code>%(NPR)UI..m.button(.BGE,{@1})</code>
    <cmt>ButtonGroupId
    This is the unique button group identifier supplied when the @UI.buttons.create macro
    was originally called.

This macro will assist in knowing whether an update command can be successfully sent to a group of buttons.

Returns True if the Group has been created, false otherwise.</cmt>
  </macro>
  <macro>
    <name>UI.button.grp.remove</name>
    <act>Y</act>
    <stx>@UI.button.grp.remove(BtnGroupId)</stx>
    <dsc>Removes an Entire Button Group</dsc>
    <code>%(NPR)UI..m.button(.BGR,{@1})</code>
    <cmt>ButtonGroupId
    This is the unique button group identifier supplied when the @UI.buttons.create macro
    was originally called.</cmt>
  </macro>
  <macro>
    <name>UI.button.remove</name>
    <act>Y</act>
    <stx>@UI.button.remove(ButtonGroupId,ButtonAppIdOrText)</stx>
    <dsc>Removes specified button from designated group</dsc>
    <code>%(NPR)UI..m.button(.BR,{@1,@2})</code>
    <cmt>ButtonGroupId
     This is the unique button group identifier supplied when the @UI.buttons.create macro
     was originally called.

ButtonAppIdOrText
     This is the unique identifier for the button to be removed, as defined and supplied by
     the application that created the button in the first place.  If this ID has not been
     defined, the text of the button to be removed can be used instead.</cmt>
  </macro>
  <macro>
    <name>UI.button.set.state</name>
    <act>Y</act>
    <stx>@UI.button.set.state(GroupID,ButtonID,State)</stx>
    <dsc>Set the state for a single button</dsc>
    <code>%(NPR)UI..m.button.M..state.single(@1,@2,@3)</code>
    <cmt>GroupID
     This is the unique identifier for the group containing the single button that is to be
     updated:

     Footer:        @UI.r.footer
     Function bar:  @UI.r.func.bar
     Body:          App-defined button group ID

ButtonID
     This is the unique identifier for the button within the specified group that is to be
     updated.

State
     Pushbutton:  0 = disabled
                  1 = enabled, not sticky
                  2 = enabled, sticky</cmt>
  </macro>
  <macro>
    <name>UI.button.sp.ftr.create</name>
    <act>Y</act>
    <stx>@UI.button.sp.ftr.create([BtnSet,NextBtn,EMRBtn])</stx>
    <dsc>Creates the Special Footer Buttons</dsc>
    <code>%(NPR)UI..m.button.spf(.C,{&quot;_IF{S[1] &quot;@1&quot;;.}_IF{S[2] &quot;,@2&quot;}_IF{S[3] &quot;,@3&quot;}_&quot;})</code>
    <cmt>Draws the Special Footer buttons onto the screen.

If neither argument is passed in, then .SC with no Next is the default.

BtnSet =   .OC  - Ok/Cancel
           .SC  - Save/Cancel (Optional Next)
           .C   - Close

NextBtn =  If set to true when doing the .SC set, the Next button will be drawn.

EMRBtn =  If set to true, the EMR button will be drawn.


In order for the buttons to be drawn, the structure @NPR.Z.UI.tmp.button.sp.footer segment must be setup.

To aid in setting up the segment, users may send a packed peice to the following elements to set up the appropriate nodes.
{Procedure Urn, Arguments, Macro}
@NPR.Z.UI.tmp.button.spf.cc      -- Close/Cancel Button
@NPR.Z.UI.tmp.button.spf.ok      -- Ok/Save Button
@NPR.Z.UI.tmp.button.spf.next    -- Next Button
@NPR.Z.UI.tmp.button.spf.emr     -- EMR Button

Once the special footers are on the screen the following macros may be used to modify them.
@UI.button.sp.ftr.update
@UI.button.sp.ftr.remove
</cmt>
  </macro>
  <macro>
    <name>UI.button.sp.ftr.remove</name>
    <act>Y</act>
    <stx/>
    <dsc>Removes the Special Footer Buttons</dsc>
    <code>%(NPR)UI..m.button.spf(.R)</code>
    <cmt>
This will remove the special footer buttons from the screen while leaving the other footer buttons intact.</cmt>
  </macro>
  <macro>
    <name>UI.button.sp.ftr.update</name>
    <act>Y</act>
    <stx/>
    <dsc>Updates the Special Footer Buttons</dsc>
    <code>%(NPR)UI..m.button.spf(.U)</code>
    <cmt>
Set up the appropriate elements within the @NPR.Z.UI.tmp.button.sp.footer segment that you want to update.  Leave elements blank for no change.  If you wish to nil out a value pass in a D(34,34).
</cmt>
  </macro>
  <macro>
    <name>UI.button.util.email.update</name>
    <act>Y</act>
    <stx>@UI.button.util.email.update(Procedure,[Args,Macro])</stx>
    <dsc>Sets up Program for the Email Utility Button</dsc>
    <code>%(NPR)UI..m.button(.BUTL,{24,@1&quot;_IF{S[3] &quot;,@2,@3&quot;;S[2] &quot;,@2&quot;}_&quot;})</code>
    <cmt>Sets up a program hook to be called when a user presses the Email Utility Button.
The hook is called after any system level programs.

Procedure - NPR Procedure Urn
Args - Arguments to pass in as Argument A
Macro - Executes a macro of the defined procedure</cmt>
  </macro>
  <macro>
    <name>UI.button.util.help.update</name>
    <act>Y</act>
    <stx>@UI.button.util.help.update(Procedure,[Args,Macro])</stx>
    <dsc>Sets up Program for the Help Utility Button</dsc>
    <code>%(NPR)UI..m.button(.BUTL,{20,@1&quot;_IF{S[3] &quot;,@2,@3&quot;;S[2] &quot;,@2&quot;}_&quot;})</code>
    <cmt>Sets up a program hook to be called when a user presses the Help Utility Button.
The hook is called after any system level programs.

Procedure - NPR Procedure Urn
Args - Arguments to pass in as Argument A
Macro - Executes a macro of the defined procedure</cmt>
  </macro>
  <macro>
    <name>UI.button.util.print.update</name>
    <act>Y</act>
    <stx>@UI.button.util.print.update(Procedure,[Args,Macro])</stx>
    <dsc>Sets up Program for the Print Utility Button</dsc>
    <code>%(NPR)UI..m.button(.BUTL,{22,@1&quot;_IF{S[3] &quot;,@2,@3&quot;;S[2] &quot;,@2&quot;}_&quot;})</code>
    <cmt>Sets up a program hook to be called when a user presses the Print Utility Button.
The hook is called after any system level programs.

Procedure - NPR Procedure Urn
Args - Arguments to pass in as Argument A
Macro - Executes a macro of the defined procedure</cmt>
  </macro>
  <macro>
    <name>UI.button.util.reference.update</name>
    <act>Y</act>
    <stx>@UI.button.util.reference.update(Procedure,[Args,Macro])</stx>
    <dsc>Sets up Program for the Reference Utility Button</dsc>
    <code>%(NPR)UI..m.button(.BUTL,{21,@1&quot;_IF{S[3] &quot;,@2,@3&quot;;S[2] &quot;,@2&quot;}_&quot;})</code>
    <cmt>Sets up a program hook to be called when a user presses the Reference Utility Button.
The hook is called after any system level programs.

Procedure - NPR Procedure Urn
Args - Arguments to pass in as Argument A
Macro - Executes a macro of the defined procedure</cmt>
  </macro>
  <macro>
    <name>UI.button.util.suspend.update</name>
    <act>Y</act>
    <stx>@UI.button.util.suspend.update(Procedure,[Args,Macro])</stx>
    <dsc>Sets up Program for the Suspend Utility Button</dsc>
    <code>%(NPR)UI..m.button(.BUTL,{23,@1&quot;_IF{S[3] &quot;,@2,@3&quot;;S[2] &quot;,@2&quot;}_&quot;})</code>
    <cmt>Sets up a program hook to be called when a user presses the Suspend Utility Button.
The hook is called after any system level programs.

Procedure - NPR Procedure Urn
Args - Arguments to pass in as Argument A
Macro - Executes a macro of the defined procedure</cmt>
  </macro>
  <macro>
    <name>UI.buttons.add</name>
    <act>Y</act>
    <stx>@UI.buttons.add(ButtonGroupId)</stx>
    <dsc>Adds button(s) to specified group</dsc>
    <code>%(NPR)UI..m.button(.BA,{@1})</code>
    <cmt>ButtonGroupId
     This is the unique button group identifier supplied when the @UI.buttons.create macro
     was originally called.

It is assumed that the list of buttons to be added is contained in data segment @NPR.Z.UI.tmp.buttons.  Please note that specific buttons are identified by element @NPR.Z.UI.tmp.button.app.id; therefore, the button(s) to be added should not have the same value in this field as any of the existing buttons.  Buttons added by this macro will appear at the end of the list of existing buttons.

If the first button in the list of buttons to be added is a spacer (i.e., no button text or image defined), then the button immediately following it will start a new cluster.</cmt>
  </macro>
  <macro>
    <name>UI.buttons.create</name>
    <act>Y</act>
    <stx>@UI.buttons.create(RegionOrPanel,[ButtonGroupID])</stx>
    <dsc>Draws button(s) on specified region/panel</dsc>
    <code>%(NPR)UI..m.button(.BC,{@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;})</code>
    <cmt>ButtonGroupId
     This is a unique identifier for the group of buttons being created.  In subsequent
     macro calls which add, remove, or modify buttons to/from/in this group, this identifier
     is passed in as the initial argument.

RegionOrPanel
     This is the identity of the region or panel on which this button group should be
     placed, for example:

     Region               Identifier
     ======               ==========
     Body                 @UI.r.body
     Function bar         @UI.r.func.bar
     Footer               @UI.r.footer
     etc.

It is assumed that the list of buttons to be created is contained in data segment @NPR.Z.UI.tmp.buttons, and any override scalar values that apply to the entire group are contained in @NPR.Z.UI.tmp.button.scalars.</cmt>
  </macro>
  <macro>
    <name>UI.buttons.disable</name>
    <act>Y</act>
    <stx>@UI.buttons.disable(BtnGroupId,BtnAppId,[BtnList])</stx>
    <dsc>Disables a Single or List of Buttons within a Specified Group</dsc>
    <code>%(NPR)UI..m.button.chg.state(.BSD,@1,{@2&quot;_IF{S[3] &quot;,@3&quot;}_&quot;})</code>
    <cmt>
BtnGroupId is the Group Id passed in when the buttons were created.

BtnAppId is the unique AppId for the Button to Disable.  If the BtnAppId is &quot;ALL&quot; then all the buttons in the group will be Disabled.

BtnList is a group of buttons to Disable.  It should be passed in as a NameOf Structure. the subscripts of which are the BtnAppId&apos;s.</cmt>
  </macro>
  <macro>
    <name>UI.buttons.enable</name>
    <act>Y</act>
    <stx>@UI.buttons.enable(BtnGroupId,BtnAppId,[BtnList])</stx>
    <dsc>Enables a Single or List of Buttons within a Specified Group</dsc>
    <code>%(NPR)UI..m.button.chg.state(.BSE,@1,{@2&quot;_IF{S[3] &quot;,@3&quot;}_&quot;})</code>
    <cmt>
BtnGroupId is the Group Id passed in when the buttons were created.

BtnAppId is the unique AppId for the Button to Enable.  If the BtnAppId is &quot;ALL&quot; then all the buttons in the group will be Enabled.

BtnList is a group of buttons to Enable.  It should be passed in as a NameOf Structure. the subscripts of which are the BtnAppId&apos;s.
</cmt>
  </macro>
  <macro>
    <name>UI.buttons.remove</name>
    <act>Y</act>
    <stx>@UI.buttons.remove(ButtonGroupId)</stx>
    <dsc>Removes button(s) from specified group</dsc>
    <code>%(NPR)UI..m.button(.BR,{@1})</code>
    <cmt>ButtonGroupId
     This is the unique button group identifier supplied when the @UI.buttons.create macro
     was originally called.

It is assumed that the list of buttons to be removed is contained in data segment @NPR.Z.UI.tmp.buttons.  Please note that specific buttons are identified by element @NPR.Z.UI.tmp.button.app.id.</cmt>
  </macro>
  <macro>
    <name>UI.buttons.update</name>
    <act>Y</act>
    <stx>@UI.buttons.update(ButtonGroupId)</stx>
    <dsc>Makes changes to one or more buttons in the specified group</dsc>
    <code>%(NPR)UI..m.button(.BU,{@1})</code>
    <cmt>ButtonGroupId
     This is the unique button group identifier supplied when the @UI.buttons.create macro
     was originally called.

It is assumed that the list of buttons to be updated is supplied in data segment @NPR.Z.UI.tmp.buttons, and any scalar values that apply to the entire group are in @NPR.Z.UI.tmp.button.scalars.  Please note that specific buttons are identified by element @NPR.Z.UI.tmp.button.app.id.  Any buttons successfully identified using this field will be modified to use the new information contained in @NPR.Z.UI.tmp.buttons.</cmt>
  </macro>
  <macro>
    <name>UI.cds.populate</name>
    <act>Y</act>
    <stx>@UI.cds.populate(field.name,screen or *)</stx>
    <dsc>Redisplays all the values in a CDS</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..ui(^S)_&quot;</code>
    <cmt>This macro translates to a call to %NPR.UI.cds.kernel.populate which will repopulate all of the fields on a CDS.

Arguments:

   field.name - The name of the field (panel) which contains the CDS.
   screen or * - The name of the screen which contains the CDS panel. * may be used if the      screen is in the current procedure</cmt>
  </macro>
  <macro>
    <name>UI.child.exit</name>
    <act>Y</act>
    <stx/>
    <dsc>Sets up UI exit current child.</dsc>
    <code>%(NPR)UI..m.misc(.WC)</code>
    <cmt>This command is not executed until the driver is returned to.  This will exit the current driver layer.

There is 1 driver call per window layer.</cmt>
  </macro>
  <macro>
    <name>UI.child.exit.flag</name>
    <act>Y</act>
    <stx/>
    <dsc>Stores how a child window was exited.</dsc>
    <code>/(UIT)CHILD.EXIT</code>
    <cmt>This flag can have the following &quot;tools defined state&quot;

CANCEL  This will be set if Close/Cancel was hit.
OK   This will be set if OK/Save was hit

If the user hit one of those buttons and the action was taken, the tool could automaticly set UI.child.exit.flag to the button that was clicked to exit the window.  The Special footer buttons will also close the window if the programmer does not assign a program to it.

So by adding the following UI macro:

@UI.button.sp.ftr.create(.OC),

Cancel/Ok buttons will be added.  By not assigning a program to the buttons, the tools will do the following:  If a user clicks on one, then the user will asked for verification according to the standard Style, and if they confirm, then @UI.child.exit.flag will be set and a close child event will be queued.

@UI.button.sp.ftr.create(.OS),  Same as above but Save instead of Ok.

If a program is assigned then we will not set the flag and will not close the window.

This macro can also be used as a standard place for applications to set for flagging other code as to the child window exit state.</cmt>
  </macro>
  <macro>
    <name>UI.child.open</name>
    <act>Y</act>
    <stx>@UI.child.open(`proc.urn,proc.type,proc.macro&apos;,`win open args&apos;,`arg1,...argn&apos;)</stx>
    <dsc>Opens a new window for the proc urn to fill.  Does not exit until window close.</dsc>
    <code>%(NPR)UI..driver(@1&quot;_IF{S[2] &quot;,@2&quot;_IF{S[3] &quot;,@3&quot;}}_&quot;)</code>
    <cmt>Argument set A:
proc.urn - this procedure will be called before entering the input loop.
proc.type - this can be nil or &quot;S&quot;.  A setting of &quot;S&quot; will cause the .S logic
             of this procedure to be called.
proc.macro - macro will be used to translate in to a .M.macro type call.

Argument set B:
{window.size,`override.header,override.functionbar,util.button.string&apos;}
window.size - a window of this size will be opened before entering the input loop.
override.header - For Medium, Large, XLarge windows put in the header region.  Note: this will shrink the body area.
override.functionbar - For Large,XLarge windows, will remove the function region.  Note: this will NOT increase the body region, but make the window smaller.
** not coded yet **
util.button.string - Letters designating which util buttons to show for windows without a function bar.  Letters in string mean show button

H - help
R - References
P - Print
S - Suspend
E - Email

Argument set C:
This is an argument list to pass to the procedure urn.  &quot;STARTUP&quot; will be passed as
 argument A.  The rest of the list will be passed as arguments B through K.

Example: @UI.child.open(`NPR.UI.test&apos;,`LARGE&apos;)

The above code would open a LARGE window and call %(NPR)UI..test(&quot;&quot;).  We would then enter the input loop.
</cmt>
  </macro>
  <macro>
    <name>UI.execute</name>
    <act>N</act>
    <stx/>
    <dsc>Tells the client to execute the UI commands in the membuffer</dsc>
    <code>#mx[/(.S).UI|4]</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.exit</name>
    <act>Y</act>
    <stx/>
    <dsc>Exits the UI system</dsc>
    <code>%(NPR)UI..m.misc(.X)</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.exit.program</name>
    <act>Y</act>
    <stx>@UI.exit.program(procedure,macro,args)</stx>
    <dsc>Sets the program to be called when the user closes the window with the &quot;X&quot;</dsc>
    <code>%(NPR)UI..m.misc(.XP,{@1&quot;_IF{S[2] &quot;,@2&quot;_IF{S[3] &quot;,@3&quot;}}_&quot;})</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.exit.prompt</name>
    <act>Y</act>
    <stx>@UI.exit.prompt(Text to display on exit)</stx>
    <dsc>Changes the default exit prompt.</dsc>
    <code>@1^/(.S)UI.EXIT.PROMPT</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.field.add.scrn</name>
    <act>Y</act>
    <stx>@UI.field.add.scrn(handle,proc,element num,ctlrep,edit[,snum,stype,root,offset])</stx>
    <dsc>Sets up the field with screen information for the driver program.</dsc>
    <code>%(NPR)UI..m.text(.FAS,{@1,@2,@3,@4,@5&quot;_IF{S[6] &quot;,@6,@7,&quot;_D(34,34)_&quot;,@8,@9&quot;}_&quot;})</code>
    <cmt>Handle:      the handle of the  field to setup.

Proc:        urn of the procedure whose logic or screen from which this field originated.

Element Num: field&apos;s element number within the screen.

Ctl Rep:     yes/no setting that says whether the field is a repeating control field.

Edit:        yes/no setting that says whether the field is editable.

Snum:        an internal urn to use for referring to the field.  This argument is optional.
             This value is synonomous with the s variable in old style screen object code.

Stype:       describes the type of field.  &quot;S&quot; for non-control scalars, &quot;C&quot; for control
             fields, and an iteration number for a line in a multiple.

Root:        structural root where data should be stored.

Offset:      offset within the root where the data is stored.</cmt>
  </macro>
  <macro>
    <name>UI.field.erase</name>
    <act>Y</act>
    <stx>@UI.field.erase(handle)</stx>
    <dsc>Places a request to erase the contents of a field object on the UI queue.</dsc>
    <code>%(NPR)UI..m.text(.FE,{@1})</code>
    <cmt>Handle: handle of the object whose contents should be erased.

Note: The object will be erased with its current attribute.</cmt>
  </macro>
  <macro>
    <name>UI.field.focus</name>
    <act>Y</act>
    <stx>@UI.field.focus(field.name,screen or *,{itn})</stx>
    <dsc>Sets a field in a screen as the focus object</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..ui(^S)_&quot;</code>
    <cmt>This macro will take a field specified in field.name for screen or * set focus to it.

If the field is a multiple then a row can be specified.  If none is specified the row 1 will default in.  If a invalid row is specified, then the macro will not report a error, but it will not work.

This macro works similar to @Display.
</cmt>
  </macro>
  <macro>
    <name>UI.field.help.procedure.set</name>
    <act>Y</act>
    <stx>@UI.field.help.procedure.set(procedure urn)</stx>
    <dsc>sets up field help program - for documentation jump points</dsc>
    <code>@1^/(UI)STFLHLPGM</code>
    <cmt>This macro is used for editable for the ability to re-direct the current field help procedure when the user presses SHIFT-F1. It can be used in situations where there is a field read that is not on a screen, such as an editable table. It is the programmers responsibility to restore the help procedure when it is no longer appropriate.</cmt>
  </macro>
  <macro>
    <name>UI.field.highlight</name>
    <act>Y</act>
    <stx>@UI.field.highlight(handle)</stx>
    <dsc>Places a request to highlight the contents of a field object on the UI queue.</dsc>
    <code>%(NPR)UI..m.text(.FH,{@1})</code>
    <cmt>Handle: handle of the object whose contents should be highlighted.

Note: The contents are highlighted in an attribute other than the field object&apos;s attribute.</cmt>
  </macro>
  <macro>
    <name>UI.field.normal</name>
    <act>Y</act>
    <stx>@UI.field.normal(handle)</stx>
    <dsc>Places a request to normalize the contents of a field on the UI queue.</dsc>
    <code>%(NPR)UI..m.text(.FN,{@1})</code>
    <cmt>Handle: handle of the object whose contents should be normalized.

Note: Normalizing a field&apos;s contents effectively undoes the effect of highlighting.</cmt>
  </macro>
  <macro>
    <name>UI.field.read</name>
    <act>N</act>
    <stx>@UI.field.read(handle)</stx>
    <dsc>Control transfers to the field and user input will be read.</dsc>
    <code>%(NPR)UI..m.text(.FR,{@1})</code>
    <cmt>Returns the handle of the Editable Text region.

The result of the read will be available upon processing the UI queue.
</cmt>
  </macro>
  <macro>
    <name>UI.field.read.set</name>
    <act>N</act>
    <stx>@UI.field.read.set(handle,text)</stx>
    <dsc>Control transfers to the field and user input will be read.</dsc>
    <code>%(NPR)UI..m.text(.FRS,{@1,@2})</code>
    <cmt>The text specified will be displayed in the field.

Returns the handle of the Editable Text region.

The result of the read will be available upon processing the UI queue.</cmt>
  </macro>
  <macro>
    <name>UI.field.remove.nav</name>
    <act>Y</act>
    <stx>@UI.field.remove.nav(handle)</stx>
    <dsc>Destroys the navigation nodes for handle immediately.</dsc>
    <code>%(NPR)UI..m.text(.FRN,{@1})</code>
    <cmt>Handle: this can be a field handle or the handle of a container.  In the case of a
        container, all navigation nodes that belong to objects within that container and any
        sub-containers will be removed.  In doing so, all handles pointed to by the
        navigation will have their nodes properly redirected, thereby updating the doubly
        linked list.  If the handle belongs to a single field, only it&apos;s navigation node
        will be removed, but the same pointer redirection will occur.

NOTE: This operation is performed automatically as part of the clearing or destruction of a
      container when such a command is processed on the queue.  This macro is meant to
      facilitate immediate deletion of navigation nodes, as opposed to having to wait for
      the queue to be processed.</cmt>
  </macro>
  <macro>
    <name>UI.field.set.attr</name>
    <act>Y</act>
    <stx>@UI.field.set.attr(handle,attribute)</stx>
    <dsc>Changes the attribute of the specified field.</dsc>
    <code>%(NPR)UI..m.text(.FSA,{@1,@2})</code>
    <cmt>Handle: handle of the object whose attribute should change.

Text:   the new attribute for the object.

Note: The current font and text for the field will be used in the display.</cmt>
  </macro>
  <macro>
    <name>UI.field.set.font.attr</name>
    <act>N</act>
    <stx>@UI.field.set.font.attr(handle,font[,attribute])</stx>
    <dsc>Changes the font and attribute of the specified field.</dsc>
    <code>%(NPR)UI..m.text(.FSFA,{@1,@2&quot;_IF{S[3] &quot;,@3&quot;}_&quot;})</code>
    <cmt>If an attribute is not specified, the current attribute of the field will be used. Otherwise, the new attribute will be used.

Returns the handle of the Editable Text region.</cmt>
  </macro>
  <macro>
    <name>UI.field.set.nav</name>
    <act>N</act>
    <stx>@UI.field.set.nav(handle,next,previous{,next section,previous section,top})</stx>
    <dsc>Adds the field object into the navigation structure.</dsc>
    <code>%(NPR)UI..m.text(.FSN,{@1,@2,@3&quot;_IF{S[4] &quot;,@4,@5,@6&quot;}_&quot;})</code>
    <cmt>Handle:           handle of the object to be added into the navigation structure.

Next:             handle of the next object to navigate to.

Previous:         handle of the previous object to navigate to.

Next Section:     handle of the first field in the next section.

Previous Section: handle of the first field in the previous section.

Top:              handle of the first field in the current section.

Note: The Navigation structure is a doubly-linked list, so each field object is aware of the
      next and previous fields in the list.
</cmt>
  </macro>
  <macro>
    <name>UI.field.set.text</name>
    <act>Y</act>
    <stx>@UI.field.set.text(handle,text)</stx>
    <dsc>Places a request to set the text of a field object on the UI queue.</dsc>
    <code>%(NPR)UI..m.text(.FST,{@1,@2})</code>
    <cmt>Handle: handle of the object that the text should be displayed in.

Text:   text to display within the object.

Note: The current font and attribute for the field will be used to display the text.
</cmt>
  </macro>
  <macro>
    <name>UI.focus</name>
    <act>Y</act>
    <stx>@UI.focus(appl.id)</stx>
    <dsc>Sets focus to the object specified by Applicaton ID</dsc>
    <code>%(NPR)UI..m.focus(@1)</code>
    <cmt>This macro will set the input focus to any object specified with a application id.

This list can include Tables, rows, cells, and buttons.  Fields are using UI.field.focus

Tables, can be set focus to also.  For now cells and rows can not be specified.

Buttons will have @NPR.Z.UI.tmp.button.app.id node indexed in the Applicaiton ID index, so whatever names are put into this field are used to point to a button.</cmt>
  </macro>
  <macro>
    <name>UI.font.normal</name>
    <act>N</act>
    <stx/>
    <dsc>Standard sized font</dsc>
    <code>1</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.graphic.path.set</name>
    <act>Y</act>
    <stx>@UI.graphic.path.set(Path)</stx>
    <dsc>Sets base path for images</dsc>
    <code>%(NPR)UI..m.misc(.GP,@1)</code>
    <cmt>Once a base path has been set, subsequent path references to image files need only include Folder\Filename.bmp, and the base portion is assumed.

Note:  if a child window is opened, a base path set for the parent window will not be accessible to it.</cmt>
  </macro>
  <macro>
    <name>UI.header.addit.info</name>
    <act>Y</act>
    <stx>@UI.header.addit.info(&quot;DPM.procedure.hook1&quot;,&quot;DPM.procedure.hook2&quot;)</stx>
    <dsc>Adds the additional info/pic icons and vertical separator to header&apos;s left side</dsc>
    <code>%(NPR)Z.UI..header.addit.info(@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;)</code>
    <cmt>Place this call after header text has been sent. This is to allow for any header clearing syntax. All text sent to the header should start 23 pixels from the left. This will place all text 1 pixel from the vertical separator.

The first procedure will be linked to the &quot;more info&quot; icon.
The second procedure will be linked to the &quot;patient picture&quot; icon.</cmt>
  </macro>
  <macro>
    <name>UI.help.procedure.set</name>
    <act>Y</act>
    <stx>@UI.help.procedure.set(&quot;Procedure&quot;)</stx>
    <dsc>sets up help program - for documentation jump points</dsc>
    <code>@1^/(UI)STHLPGM</code>
    <cmt>This macro is used for desktop routines and allows for the ability to re-direct the current help procedure.  It is the programmers responsibility to restore the help procedure when it is no longer appropriate.  For example, if you want separate help procedures to be associated to your function buttons, you may do something like this:

function.btn.click -  a macro that is called when a function button is selected

IF{A=&quot;Home&quot; @UI.help.procedure.set(&quot;Z.desktop.home&quot;),
            @HOME;
    A=&quot;Function 1&quot; @UI.help.procedure.set(&quot;Z.desktop.function1&quot;),
                   @FUNCTION1;
    A=&quot;Function 2&quot; @UI.help.procedure.set(&quot;Z.desktop.function2&quot;),
                   @FUNCTION2};</cmt>
  </macro>
  <macro>
    <name>UI.image.create</name>
    <act>Y</act>
    <stx>@UI.image.create(Parent,Picture,Left,Top[,Height,Width])</stx>
    <dsc>Creates Height/Width sized graphic image in Parent from Picture at Left,Top</dsc>
    <code>%(NPR)UI..m.image(.IC,{@1,@2,@3,@4&quot;_IF{S[5]!S[6] &quot;,@5,@6&quot;}_&quot;})</code>
    <cmt>Returns the handle to the newly created image object.

Parent is the container in which the graphic image should be displayed.

Picture is a mnemonic from the NPR Picture Dictionary.

Left is a fixed position or an attribute command (L, C, or R).

Top is a fixed position or an attribute command (T, M, or B).

Height is an optional height in logical pixels.

Width is an optional width in logical pixels.</cmt>
  </macro>
  <macro>
    <name>UI.image.create.path</name>
    <act>Y</act>
    <stx>@UI.image.create.path(Parent,Path to Picture,Left,Top[,Height,Width])</stx>
    <dsc>Creates Height/Width sized graphic image in Parent from Picture at Left,Top</dsc>
    <code>%(NPR)UI..m.image(.IP,{@1,@2,@3,@4&quot;_IF{S[5]!S[6] &quot;,@5,@6&quot;}_&quot;})</code>
    <cmt>Difference of this macro from UI.image.create is that this macro can have a path to a file passed in.  UI.image.create must use entries from the NPR.PICTURE dictionary.

Returns the handle to the newly created image object.

Parent is the container in which the graphic image should be displayed.
Picture is a mnemonic from the NPR Picture Dictionary.
Left is a fixed position or an attribute command (L, C, or R).
Top is a fixed position or an attribute command (T, M, or B).
Height is an optional height in logical pixels.
Width is an optional width in logical pixels.</cmt>
  </macro>
  <macro>
    <name>UI.initialize</name>
    <act>N</act>
    <stx>@UI.initialize(Title,header.ht,footer,ht,function.wt,multiplier)</stx>
    <dsc>Initialize the UI system including the main window</dsc>
    <code>%(NPR)UI..m.misc(.I,{@1,@2,@3,@4,@5})</code>
    <cmt>header,footer,function bar:
If nill values specified, then standard size will be defaulted in.
If a 0 is passed then that means no region to be defined.
</cmt>
  </macro>
  <macro>
    <name>UI.label.create</name>
    <act>N</act>
    <stx>@UI.label.create(parent,left,top,text)^handle</stx>
    <dsc>Creates a text object with the default attribute.</dsc>
    <code>%(NPR)UI..m.text(.LC,{@1,@2,@3,@4})</code>
    <cmt>Returns the handle of Text object created.</cmt>
  </macro>
  <macro>
    <name>UI.label.create.attr</name>
    <act>N</act>
    <stx>@UI.label.create.attr(parent,left,top,text,attribute)^handle</stx>
    <dsc>Creates a text object with the specified attribute.</dsc>
    <code>%(NPR)UI..m.text(.LCA,{@1,@2,@3,@4,@5})</code>
    <cmt>Returns the handle of Text object created.</cmt>
  </macro>
  <macro>
    <name>UI.label.create.font.attr</name>
    <act>N</act>
    <stx>@UI.label.create.font.attr(parent,left,top,text,font,attribute)^handle</stx>
    <dsc>Creates a text object with the specified font and attribute.</dsc>
    <code>%(NPR)UI..m.text(.LCFA,{@1,@2,@3,@4,@5,@6})</code>
    <cmt>Returns the handle of Text object created.</cmt>
  </macro>
  <macro>
    <name>UI.label.create.font.color</name>
    <act>N</act>
    <stx>@UI.label.create.font.color(parent,left,top,text,font,fgnd.clr,bkg.clr)^handle</stx>
    <dsc>Creates a text object with the specified font and colors.</dsc>
    <code>%(NPR)UI..m.text(.LCFC,{@1,@2,@3,@4,@5,@6,@7})</code>
    <cmt>Returns the handle of Text region created.</cmt>
  </macro>
  <macro>
    <name>UI.line.draw</name>
    <act>N</act>
    <stx>@UI.line.draw(Parent,Left,Top,Right,Bottom,Width,Attr)</stx>
    <dsc>Draws Width line in Parent from Left/Top to Right/Bottom using Attr</dsc>
    <code>%(NPR)UI..m.line(.LD,{@1,@2,@3,@4,@5,@6,@7})</code>
    <cmt>Parent
   Handle to object within which line should be drawn

Width
   Thickness of line, in logical pixels

Attr
   Determines foreground color of line to be drawn</cmt>
  </macro>
  <macro>
    <name>UI.link.file.button</name>
    <act>N</act>
    <stx>@UI.link.file.button(button id)</stx>
    <dsc>Links the F12 key to a Button</dsc>
    <code>%(NPR)UI..m.misc(.LFB,{@1})</code>
    <cmt>Pass in either a button id or button text.  When F12 is hit this button will be activated.</cmt>
  </macro>
  <macro>
    <name>UI.log.event</name>
    <act>Y</act>
    <stx>@UI.log.event(Event,Comments,{Sub.event})</stx>
    <dsc>log a entry in UI event log, if event is flagged to be logged.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..ui(^S)_&quot;</code>
    <cmt>Event should not be in quotes as it is a keyword to the macro.  Comment is to be a value/string.

Sub.event can be &quot;Start&quot; or &quot;End&quot;  (include quotes),  it also can be skipped.  If it is skipped it will become more of a comment and less of a timing event.

Event List:

ApplEvent

The ApplEvent can be added to application code to time code.  The Comment should be used to differenciate the different app events.

Those prefixed by UI are for tool use.  Using them in a application setting will confuse the output of the tool timing.  They are listed to be able to see what events are logged.

UIread
UItext
UIexecute
UItable
UIprocCall
UImisc
UIbtn
UIbtnUpd
</cmt>
  </macro>
  <macro>
    <name>UI.mouse.pointer.default</name>
    <act>Y</act>
    <stx/>
    <dsc>Changes the mouse pointer back to the normal pointer</dsc>
    <code>#my[@(104,0)]</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.mouse.pointer.hourglass</name>
    <act>Y</act>
    <stx/>
    <dsc>Changes the mouse prionter to a hourglass.  All input is paused.</dsc>
    <code>#my[@(104,1)]</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.mpg.page.clear.lf</name>
    <act>Y</act>
    <stx>@UI.mpg.page.clear.lf(page number,sub-body page num)</stx>
    <dsc>Clears the last accessed field info for a given page</dsc>
    <code>%(NPR)Z.UI..mpg.driver.M..util(.LF,{@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;})</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.mpg.page.load</name>
    <act>Y</act>
    <stx>@UI.mpg.page.load(page name or number,sub-body page name or num)</stx>
    <dsc>Brings the user to specified page in a multi-page sequence</dsc>
    <code>%(NPR)Z.UI..mpg.driver.M..util(.PL,{@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;})</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.mpg.page.toggle</name>
    <act>Y</act>
    <stx>@UI.mpg.page.toggle(&quot;&quot;)</stx>
    <dsc>Toggles multi-page buttons based on pre-set toggle flags</dsc>
    <code>%(NPR)Z.UI..mpg.driver.M..util(.TG)</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.panel.bkg.attr</name>
    <act>Y</act>
    <stx>@UI.panel.bkg.attr(handle,color)</stx>
    <dsc>Changes the bkg color of the panel</dsc>
    <code>%(NPR)UI..m.misc(.PB,{@1,@2})</code>
    <cmt>Handle:    panel&apos;s handle.

Color:     color number used for displaying the object.  This value determines the
           background color for the panel.  If nil is specified or the attribute is omitted
           from the macro, white will be used.  A list of valid colors is available in the
           NPR.Z.UI: colors and colors.system data definition segments.</cmt>
  </macro>
  <macro>
    <name>UI.panel.clear</name>
    <act>Y</act>
    <stx>@UI.panel.clear(handle)</stx>
    <dsc>Clears out child handles out of a container object.</dsc>
    <code>%(NPR)UI..m.misc(.PCL,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.panel.create</name>
    <act>Y</act>
    <stx>@UI.panel.create(Parent,left,top,height,width,color,style)</stx>
    <dsc>Creates a panel to hold objects</dsc>
    <code>%(NPR)UI..m.misc(.PC,{@1,@2,@3,@4,@5,@6,@7})</code>
    <cmt>A handle will be generated and returned.

Parent:    the handle of the object&apos;s parent object.  The parent object will usually be a
           panel.

Left:      a fixed horizontal position specified in pixels or an attribute command
           (L, C, or R).  Attribute commands specify Left, Center, or Right horizontal
           Justification.  This position is relative to the parent object.

Top:       a fixed vertical position specified in pixels or an attribute command
           (T, M, or B).  Attribute commands specify Top, Middle, or Bottom vertical
           justification.  This position is relative to the parent object.

Height:    height of the panel specified in pixels.

Width:     width of the panel specified in pixels.

Color:     color number used for displaying the object.  This value determines the
           background color for the panel.  A list of valid colors is available in the
           NPR.Z.UI: colors and colors.system data definition segments.

Style:     the style of the panel to be displayed.  Available options are listed below:

                       Style             Description
                       0                 Square corners, no border
                       1                 Rounded corners, border
                       2                 Square corners, border
                       3                 Transparent
                       4                 Round block (used by screens)
                       5                 Round upper left corner only, border
                       6                 Round lower left corner only, border
                       7                 Round both left corners only, border
                       8                 Round both right corners only, border
                       9                 Round both top corners only, border
                       10                Round both bottom corners only, border
                       11                Round upper right corner only, border
                       12                Round lower right corner only, border
</cmt>
  </macro>
  <macro>
    <name>UI.panel.create.near</name>
    <act>Y</act>
    <stx>@UI.panel.create.near(Parent,Left,Top,Height,Width,Color,Style,NearObj,ObjAppId)</stx>
    <dsc>Creates a panel to hold objects, near another object</dsc>
    <code>%(NPR)UI..m.misc(.PC,{@1,@2,@3,@4,@5,@6,@7,niL,niL,@8,@9,&quot;_D(34)_&quot;Y&quot;_D(34)_&quot;})</code>
    <cmt>A handle will be generated and returned.

Parent:    the handle of the object&apos;s parent object.  The parent object will usually be a
           panel.

Left:      a fixed horizontal position specified in a combination of an attribute command
           and a number of pixels (&quot;L0&quot;,&quot;R5&quot;).  Attribute commands specify to the Left, or
           Right on the horizontal.  This position is relative to the near object.

Top:       a fixed vertical position specified in a combination of an attribute command
           and a number of pixels (&quot;T0&quot;,&quot;B5&quot;).  Attribute commands specify to the Top, or
           Bottom on the vertical.  This position is relative to the near object.

Height:    height of the panel specified in pixels.

Width:     width of the panel specified in pixels.

Color:     color number used for displaying the object.  This value determines the
           background color for the panel.  A list of valid colors is available in the
           NPR.Z.UI: colors and colors.system data definition segments.

Style:     the style of the panel to be displayed.  Available options are listed below:

                       Style             Description
                       0                 Square corners, no border
                       1                 Rounded corners, border
                       2                 Square corners, border
                       3                 Transparent
                       4                 Round block (used by screens)
                       5                 Round upper left corner only, border
                       6                 Round lower left corner only, border
                       7                 Round both left corners only, border
                       8                 Round both right corners only, border
                       9                 Round both top corners only, border
                       10                Round both bottom corners only, border
                       11                Round upper right corner only, border
                       12                Round lower right corner only, border

NearObj:  application id of the object to place the panel near.

ObjAppId: application id for the panel.
</cmt>
  </macro>
  <macro>
    <name>UI.panel.margins</name>
    <act>Y</act>
    <stx>@UI.panel.margins(handle,left,top,bottom,right)</stx>
    <dsc>Sets the width of the margins in logical pixels</dsc>
    <code>%(NPR)UI..m.misc(.PM,{@1,@2,@3,@4,@5})</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.panel.remove</name>
    <act>Y</act>
    <stx>@UI.panel.remove(handle)</stx>
    <dsc>Removes a panel and all of it&apos;s contents from the display</dsc>
    <code>%(NPR)UI..m.misc(.PR,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.perfmon</name>
    <act>N</act>
    <stx>@UI.perfmon(Event,Comments)</stx>
    <dsc>log a entry in performnace monitor log, if event is flagged.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..ui(^S)_&quot;</code>
    <cmt>Event should not be in quotes as it is a keyword to the macro.  Comment is to be a value/string.

Event List:

Those prefixed by UI are for tool use.  Using them in a application setting will confuse the output of the tool timing.  They are listed to be able to see what events are logged.

UImisc
UIdriver
UIexecute
UIread
UIbtn
UIbtnUpd
UIimage
UIscrollbar
UItable
UIprocCall
UIqueue

Below events are for use by applications.

ApplEvent

The ApplEvent can be added to application code to time code.  The Comment should be used to differenciate the different app events.</cmt>
  </macro>
  <macro>
    <name>UI.r.body</name>
    <act>Y</act>
    <stx/>
    <dsc>Constant for body region</dsc>
    <code>3</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.r.footer</name>
    <act>Y</act>
    <stx/>
    <dsc>Constant for footer region</dsc>
    <code>5</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.r.func.bar</name>
    <act>Y</act>
    <stx/>
    <dsc>Constant for Function Bar region</dsc>
    <code>4</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.r.header</name>
    <act>Y</act>
    <stx/>
    <dsc>Constant for header region</dsc>
    <code>1</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.r.icon</name>
    <act>Y</act>
    <stx/>
    <dsc>Constant for icon region</dsc>
    <code>2</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.read.skip</name>
    <act>Y</act>
    <stx>@UI.read.skip([new.lastkey])</stx>
    <dsc>Upon entering the next object a read will not occur, but related logic will run.</dsc>
    <code>{&quot;_D(34)_&quot;Y&quot;_D(34)_&quot;,&quot;_IF{S[1];13}_&quot;}^/(UI)TMPNAV[&quot;_D(34)_&quot;TRS&quot;_D(34)_&quot;]</code>
    <cmt>new.lastkey:    the ascii value of a keyboard key to set as the last key entered.
                If this value is not supplied, the enter key will be set by default.

                This mimics a read being performed and the user hitting that key.

Usage Examples: @UI.read.skip,
                @UI.read.skip(@Z.next.section),


Even though the read is being skipped any related before, after, and/or during logic will be executed as if a read had been performed.

This macro will cause one read to be skipped.  If subsequent reads should be skipped, the macro will need to be invoked again just prior to each read.
</cmt>
  </macro>
  <macro>
    <name>UI.run</name>
    <act>Y</act>
    <stx>@UI.run(`proc.urn,proc.type,proc.macro&apos;,`window open args&apos;,`arg1,...argn&apos;)</stx>
    <dsc>Begins user input for the last window opened.</dsc>
    <code>%(NPR)UI..driver(@1&quot;_IF{S[2] &quot;,@2&quot;_IF{S[3] &quot;,@3&quot;}}_&quot;)</code>
    <cmt>All arguments to this macro are optional.

Argument set A:
proc.urn - this procedure will be called before entering the input loop.
proc.type - this can be nil or &quot;S&quot;.  A setting of &quot;S&quot; will cause the .S logic
             of this procedure to be called.
proc.macro - macro will be used to translate in to a .M.macro type call.

Argument set B:
{window.size}
window.size - a window of this size will be opened before entering the input loop.
override.header - For Medium, Large, XLarge windows put in the header region.  Note: this will shrink the body area.

Argument set C:
This is an argument list to pass to the procedure urn.  &quot;STARTUP&quot; will be passed as
 argument A.  The rest of the list will be passed as arguments B through K.

Example: @UI.run(`NPR.UI.test&apos;,`LARGE&apos;)

The above code would open a LARGE window and call %(NPR)UI..test(&quot;&quot;).  We would then enter the input loop.

Example: @UI.run(&quot;&quot;)

This will cause us to just enter the input loop.
</cmt>
  </macro>
  <macro>
    <name>UI.screen.button.deselect</name>
    <act>Y</act>
    <stx>@UI.screen.button.deselect(field.name,screen or *,button.name or &quot;ALL&quot;)</stx>
    <dsc>Deselects a radio button or checkbox from a group of screen buttons.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..ui(^S)_&quot;</code>
    <cmt>Only used for radio buttons and checkboxes that are created by a screen.

Field Name:     Screen field name as identified when the screen is created (e.g., Z.a.free).

Screen Name:    Screen program name (e.g., &quot;NPR.Z.UI.example.screen.buttons&quot;).  Entering *
                will cause the the current procedure to be used for this argument.

Button Name:    Text string that represents the option to be deselected within the button
                group that corresponds to the field name.  If &quot;ALL&quot; is used, then all of the
                buttons in the group will be deselected.  The &quot;ALL&quot; functionality only
                applies to checkboxes.

This macro will deselect the specified button.  If the button you are requesting is already unselected, no action is taken.</cmt>
  </macro>
  <macro>
    <name>UI.screen.button.disable</name>
    <act>Y</act>
    <stx>@UI.screen.button.disable(field.name,screen or *,button.name)</stx>
    <dsc>Disables a radio button or checkbox from a group of screen buttons.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..ui(^S)_&quot;</code>
    <cmt>Only used for radio buttons and checkboxes that are created by a screen.

Field Name:     Screen field name as identified when the screen is created (e.g., Z.a.free).

Screen Name:    Screen program name (e.g., &quot;NPR.Z.UI.example.screen.buttons&quot;).  Entering *
                will cause the the current procedure to be used for this argument.

Button Name:    Text string that represents the option to be disabled within the button
                group that corresponds to the field name.

By default, all buttons are enabled when the screen is initialized.  IFE&apos;s on a button group will cause the entire group to be enabled/disabled.  This macro will disable the specified button.  If the button you are requesting is already disabled, no action is taken.  Buttons that are disabled via this macro cannot be selected/deselected by the user, but they can be navigated to.</cmt>
  </macro>
  <macro>
    <name>UI.screen.button.enable</name>
    <act>Y</act>
    <stx>@UI.screen.button.enable(field.name,screen or *,button.name)</stx>
    <dsc>Enables a radio button or checkbox from a group of screen buttons.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..ui(^S)_&quot;</code>
    <cmt>Only used for radio buttons and checkboxes that are created by a screen.

Field Name:     Screen field name as identified when the screen is created (e.g., Z.a.free).

Screen Name:    Screen program name (e.g., &quot;NPR.Z.UI.example.screen.buttons&quot;).  Entering *
                will cause the the current procedure to be used for this argument.

Button Name:    Text string that represents the option to be enabled within the button
                group that corresponds to the field name.

By default, all buttons are enabled when the screen is initialized.  IFE&apos;s on a button group will cause the entire group to be enabled/disabled.  This macro will enable the specified button.  You cannot enable a button if it was disabled by IFE code.  If the button you are requesting is already enabled, no action is taken.</cmt>
  </macro>
  <macro>
    <name>UI.screen.button.select</name>
    <act>Y</act>
    <stx>@UI.screen.button.select(field.name,screen or *,button.name or &quot;ALL&quot;)</stx>
    <dsc>Selects a radio button or checkbox from a group of screen buttons.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..ui(^S)_&quot;</code>
    <cmt>Only used for radio buttons and checkboxes that are created by a screen.

Field Name:     Screen field name as identified when the screen is created (e.g., Z.a.free).

Screen Name:    Screen program name (e.g., &quot;NPR.Z.UI.example.screen.buttons&quot;).  Entering *
                will cause the the current procedure to be used for this argument.

Button Name:    Text string that represents the option to be selected within the button
                group that corresponds to the field name.  If &quot;ALL&quot; is used, then all of the
                buttons in the group will be selected.  The &quot;ALL&quot; functionality only applies                 to checkboxes.

For radio buttons, this macro will select the specified button and unselect the radio button that is currently selected.  If the button you are requesting is already selected, no action is taken.

For checkboxes, this macro will select the specified button.  If the button you are requesting is already selected, no action is taken.
</cmt>
  </macro>
  <macro>
    <name>UI.screen.check</name>
    <act>Y</act>
    <stx>@UI.screen.check(screen.urn)</stx>
    <dsc>Check the required logic for given screen</dsc>
    <code>%(NPR)UI..m.text(.SCH,{@1})</code>
    <cmt>This macro is intended for use with the Multi-page driver.  Some applications will attach a procedure to a multi-page button and have that procedure dynamically determine what screen to load.  In this case you should use this macro in conjunction with the required logic hook for this page so that the UI driver will know which screens requirments to check.
</cmt>
  </macro>
  <macro>
    <name>UI.screen.create</name>
    <act>Y</act>
    <stx>@UI.screen.create(screen urn[,top,panel,nav predecessor,nav parent])</stx>
    <dsc>Place the screen into the body panel.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..ui(^S)_&quot;</code>
    <cmt>Screen Urn:      A procedure urn that contains a screen.

Top:             The vertical position of the screen within the body specified in logical
                 pixels.

Panel:           Parent panel to place the screen in.

Nav Predecessor: The handle of the navigation SECTION prior to the screen&apos;s first section

Nav Parent:      The navigation parent object of the screen, the mpg body, or the mpg
                 sub-body

Top, Panel, Nav Predecessor, and Nav Parent are optional arguments.

The screen is placed in the body panel by default.  The screen is centered to its parent panel by default.

If no Nav Predecessor is supplied then navigation will remain within this screen, meaning that upon reaching the end of the screen you&apos;ll loop back to the first available field in the screen.

The Nav Parent establishes a parent/child relationship.  For example, when you reach the last field in a screen and hit Tab/Enter there are three possible events that will occur:

        1) The screen has no Nav Parent, so it loops back up to the first available field in
           the screen.

        2) The screen has a Nav Parent, and this parent has no other children.  In this
           case, you will be brought back to the parent.  For mpg this means the mpg body or            sub-body buttons.

        3) The screen has a Nav Parent, and this parent has other children.  If this screen
           is the last child, then you&apos;ll be brought to the parent.  If there&apos;s a child
           after this screen, then you&apos;ll go to that next child.


Returns the handle of the last section of the screen.  This can be used for setting up the Nav Predecessor for tables and other objects that immediately follow screens.
</cmt>
  </macro>
  <macro>
    <name>UI.screen.populate</name>
    <act>Y</act>
    <stx>@UI.screen.populate(screen urn,force)</stx>
    <dsc>Populate the fields in the screen.</dsc>
    <code>%(NPR)UI..m.text(.SP,{@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;})</code>
    <cmt>Screen Urn: A procedure urn that contains a screen.
B is to force update.  If no B and field is empty then the field is not updated.</cmt>
  </macro>
  <macro>
    <name>UI.screen.remove</name>
    <act>Y</act>
    <stx>@UI.screen.remove(screen urn)</stx>
    <dsc>Removes the screen.</dsc>
    <code>%(NPR)UI..m.text(.SR,{@1})</code>
    <cmt>Screen Urn: A procedure urn that contains a screen.</cmt>
  </macro>
  <macro>
    <name>UI.screen.view</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns &quot;Y&quot; if a view screen is in the body, else nil.</dsc>
    <code>/(UI)VIEW</code>
    <cmt>This macro can tell you if there is a view screen in the body, or if a specific view screen is in the body.

For the general case, use @UI.screen.view.

For the specific case, use @UI.screen.view[&quot;scrn.urn&quot;].</cmt>
  </macro>
  <macro>
    <name>UI.screen.workspace</name>
    <act>Y</act>
    <stx>@UI.screen.workspace(field.name,screen.name or *)</stx>
    <dsc>Returns handle to workspace for [field.name] in [screen.name]</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..screen(^S)_&quot;</code>
    <cmt>Only used for elements that are created by a screen. This will return the handle associated to the screen name and field.name that are supplied.

Field Name:     Screen field name as identified when the screen is created (e.g., Z.a.free).

Screen Name:    Screen program name (e.g., &quot;MIS.MTDD.test&quot;).  Entering * will cause the
                the current procedure to be used for this argument.
</cmt>
  </macro>
  <macro>
    <name>UI.scroll.object.into.view</name>
    <act>Y</act>
    <stx>@UI.scroll.object.into.view(Panel,Object)</stx>
    <dsc>Center Object on Panel, adjust scrollbars accordingly</dsc>
    <code>%(NPR)UI..m.misct(.SO,{@1,@2})</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.scroll.position.set</name>
    <act>Y</act>
    <stx>@UI.scroll.position.set(Panel,Left,Top)</stx>
    <dsc>Set scrolling Panel upper, left-hand corner to physical view position Left/Top</dsc>
    <code>%(NPR)UI..m.misct(.SP,{@1,@2,@3})</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.scrollbar.create</name>
    <act>Y</act>
    <stx>@UI.scrollbar.create(Parent,Left,Top,Ht,Wd,Attr,Type,ViewCt,ItemCt,Prg,Mac,Arg)</stx>
    <dsc>Creates an application-requested scrollbar</dsc>
    <code>%(NPR)UI..m.scrollbar(.SS,{@1,@2,@3,@4,@5,@6,@7,@8,@9,@10,@11,@12})</code>
    <cmt>Returns handle to requested scrollbar

Parent
   Container object on which scrollbar is to be set

Left
   A fixed position or an attribute command (L, C, or R) indicating the horizontal position
   of the left side of the scrollbar within Parent

Top
   A fixed position or an attribute command (T, M, or B) indicating the vertical position of
   the top of the scrollbar within Parent

Ht
   Fixed height. Only used for Vertical scrollbars.

Wd
   Fixed width.  Only used for Horizontal scrollbars.

Attr


Type
   V - vertical scrollbar
   H - horizontal scrollbar

ViewCt
   Number of viewable items

ItemCt
   Total number of scrollable items

Prg
   NPR.proc to call if this scrollbar is clicked

Mac
   Makes NPR.proc into NPR.proc.M.macro

Arg
   Application-supplied argument to program call.  This will typically identify the
   scrollbar from the application&apos;s perspective.</cmt>
  </macro>
  <macro>
    <name>UI.set.current.child.button</name>
    <act>Y</act>
    <stx>@UI.set.current.child.button(BtnAppId)</stx>
    <dsc>Sets up specified button as the navigation current child for a region.</dsc>
    <code>%(NPR)UI..m.button(.BSC,{@1})</code>
    <cmt>BtnAppId
   The application id, NPR.Z.UI.tmp.button.app.id, of the button as specified when the
   button was first created.

Use this macro to specify which button gets highlighted when a user navigates to a region.
If successful, returns the handle of the button. &quot;OK&quot; (for OK/SAVE), &quot;CANCEL&quot; (for CANCEL/CLOSE), and &quot;NEXT&quot; are valid for specifying the special function buttons.

** NOTE **
The specified button must be in the menu region or the footer region or this macro will have no effect.
</cmt>
  </macro>
  <macro>
    <name>UI.set.regions</name>
    <act>N</act>
    <stx>@UI.set.regions(header,footer,function)</stx>
    <dsc>Sets the regions to be shown or not.</dsc>
    <code>%(NPR)UI..m.misc(.SR,{@1,@2,@3})</code>
    <cmt>Regions can be defined by passing a 1 for show and &quot;&quot; for none.</cmt>
  </macro>
  <macro>
    <name>UI.sis.parent.focus.remove</name>
    <act>Y</act>
    <stx>@UI.sis.parent.focus.remove(element,screen.or.*)</stx>
    <dsc>Removes light green background from the SiS parent multiple</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..screen(^S)_&quot;</code>
    <cmt>This macro will change the selected row in the SiS parent back to its unselected color if the value for @NPR.UI.sis.cm.handle is set.  The necessity for this macro was due to some applications coding a screen that gets populated/repopulated using logic instead of making calls to the appropriate .SC program where this type code already exists.</cmt>
  </macro>
  <macro>
    <name>UI.table.cell.scroll.into.view</name>
    <act>Y</act>
    <stx>@UI.table.cell.scroll.into.view(TblAppId,CellSeqUrn)</stx>
    <dsc>Adjusts scroll position of table so that cell is in view</dsc>
    <code>%(NPR)UI..tbl.nav(.SC,{@1,@2})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

CellSeqUrn
     This is the value of NPR.Z.UI.tmp.tcell.seq for the cell being brought into view.</cmt>
  </macro>
  <macro>
    <name>UI.table.cell.set.focus</name>
    <act>Y</act>
    <stx>@UI.table.cell.set.focus(TblAppId,CellSeqUrn)</stx>
    <dsc>Redirects navigation focus to designated table/cell</dsc>
    <code>%(NPR)UI..tbl.nav(.CF,{@1,@2})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

CellSeqUrn
     This is the unique cell sequence number assigned by the application during the original
     definition of table cells (tmp.tcell.seq).

If the table specified in the first argument has been designated as editable (@NPR.Z.UI.tmp.tdef.editable = &quot;Y&quot;), and the cell specified in the second argument contains an edit field, then invoking this macro will put focus directly on that edit field.  Otherwise, focus will be placed on the cell.</cmt>
  </macro>
  <macro>
    <name>UI.table.cell.update</name>
    <act>Y</act>
    <stx>@UI.table.cell.update(TblAppId)</stx>
    <dsc>Updates cell(s) contained in a specific list with new data</dsc>
    <code>%(NPR)UI..tbl.mod(.UC,{@1})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

First, make any desired information changes in the original temp cell list...

@NPR.Z.UI.tmp.table.cells[tmp.tcell.seq] = {Left,Top,Height,Width,etc.}
@NPR.Z.UI.tmp.table.cell.objects[tmp.tcell.obj.seq] = {Type,Text,Left,Top,etc.}

Next, put the tmp.tcell.seq values for any cells that have changed into the update list...

@NPR.Z.UI.tmp.table.cell.updates[TblAppId,tmp.tcell.seq] = 1

Finally, invoke this macro.

The update list will not be deleted by the tool.</cmt>
  </macro>
  <macro>
    <name>UI.table.col.get.focus</name>
    <act>Y</act>
    <stx>@UI.table.col.get.focus(TblAppId)</stx>
    <dsc>Retrieve the current focus column</dsc>
    <code>%(NPR)UI..tbl.nav(.FC,{@1})</code>
    <cmt>This macro is used to get the current focus column sequence for the specified table.

TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

Return Value: Current {Col} focus sequence number.</cmt>
  </macro>
  <macro>
    <name>UI.table.collapse.all</name>
    <act>Y</act>
    <stx>@UI.table.collapse.all(TblAppId)</stx>
    <dsc>Collapses all headers in table referenced by TblAppId</dsc>
    <code>%(NPR)UI..m.table(.TX,{@1,&quot;_D(34)_&quot;C&quot;_D(34)_&quot;})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.</cmt>
  </macro>
  <macro>
    <name>UI.table.create</name>
    <act>Y</act>
    <stx>@UI.table.create(TblAppId[,SortFlag])</stx>
    <dsc>Creates a table from pre-built temps, optionally attempts to sort rows</dsc>
    <code>%(NPR)UI..m.table(.TC,{@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;})</code>
    <cmt>TblAppId
     This is a unique identifier by which this table will be referenced in future
     operations.

SortFlag
     Optional argument indicating that the table renderer should attempt to sort the rows in
     designated sections according to a selected column (@NPR.Z.UI.tmp.tdata.cur.sort.col)
     and direction (@NPR.Z.UI.tmp.tdata.cur.sort) for each of those sections.

     If this argument contains a &quot;1&quot;, the sorting attempt will be made.  If it contains
     anything else or is omitted, the attempt will not be made.

     The structure @NPR.Z.UI.tmp.table.sort.sections can be built containing a list of table
     sections that should be sorted.  If present, only the specified section(s) will be
     sorted.  If not present, the renderer will attempt to sort every section in the table
     structure.

Expects table/cell definition and content to be built already in:

@NPR.Z.UI.tmp.tcell...
@NPR.Z.UI.tmp.table...
@NPR.Z.UI.tmp.tdata...</cmt>
  </macro>
  <macro>
    <name>UI.table.editable</name>
    <act>Y</act>
    <stx>@UI.table.editable(TblAppId[,EditableFlag])</stx>
    <dsc>Hot-switch a table&apos;s &quot;editable&quot; setting</dsc>
    <code>%(NPR)UI..tbl.mod(.TE,{@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

EditableFlag  (optional)
     0 = switch editability OFF
     1 = switch editability ON  (default if not supplied)</cmt>
  </macro>
  <macro>
    <name>UI.table.expand.all</name>
    <act>Y</act>
    <stx>@UI.table.expand.all(TblAppId)</stx>
    <dsc>Expands all expand/collapse headers within table referenced by TblAppId</dsc>
    <code>%(NPR)UI..m.table(.TX,{@1,&quot;_D(34)_&quot;E&quot;_D(34)_&quot;})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

Headers which do not already have either &quot;E&quot; (expanded) or &quot;C&quot; (collapsed) for their @NPR.Z.UI.expand.state will not be affected by this operation.</cmt>
  </macro>
  <macro>
    <name>UI.table.invert.selection</name>
    <act>Y</act>
    <stx>@UI.table.invert.selection(TblAppId)</stx>
    <dsc>For table TblAppId, checks whatever is unchecked, unchecks whatever is checked</dsc>
    <code>%(NPR)UI..tbl.mod(.IS,{@1})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

All selectable rows will be affected by this operation, regardless of whether or not they are currently hidden within a collapsed section.</cmt>
  </macro>
  <macro>
    <name>UI.table.mi2.object.replace</name>
    <act>Y</act>
    <stx>@UI.table.mi2.object.replace(TblAppId,NewObjHandle)</stx>
    <dsc>Records a change to the &quot;more info type 2&quot; detail object handle</dsc>
    <code>%(NPR)UI..tbl.mod(.MI,{@1,@2})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

NewObjHandle
     This is the handle to the new &quot;more info type 2&quot; detail object that has replaced the
     existing object.

This macro is useful if the detail object is itself a table, and moving the row highlight in the parent table causes the more info object to be completely removed and regenerated.</cmt>
  </macro>
  <macro>
    <name>UI.table.mi2.state</name>
    <act>Y</act>
    <stx>@UI.table.mi2.state(TblAppId)</stx>
    <dsc>Returns the state of the &quot;more info type 2&quot; object associated with TblAppId</dsc>
    <code>%(NPR)UI..tbl.utl(.MS,{@1})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

Return:
     The value 1 will be returned if the &quot;more info type 2&quot; table associated with the
     &apos;TblAppId&apos; is visible.</cmt>
  </macro>
  <macro>
    <name>UI.table.off</name>
    <act>Y</act>
    <stx>@UI.table.off(TblAppId)</stx>
    <dsc>Disables clickability of entire table</dsc>
    <code>%(NPR)UI..tbl.mod(.TF,{@1})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

Any clickable images on the table will be rendered unresponsive to mouse clicks.  For each image that has @tmp.tcell.obj.text.dis defined, that picture will be displayed in place of @tmp.tcell.obj.text.</cmt>
  </macro>
  <macro>
    <name>UI.table.on</name>
    <act>Y</act>
    <stx>@UI.table.on(TblAppId)</stx>
    <dsc>Restores clickability of entire table</dsc>
    <code>%(NPR)UI..tbl.mod(.TN,{@1})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

Any cells or images that had their click responsiveness disabled by @UI.table.off will have their clickability restored.  For each image that had its @tmp.tcell.obj.text picture replaced with @tmp.tcell.obj.text.dis, the original picture will also be restored.

Any images or cells whose click responsiveness was explicitly disabled via request by the application (e.g., &quot;Y&quot;^@NPR.Z.UI.tmp.tcell.obj.off, &quot;Y&quot;^@NPR.Z.UI.tmp.tcell.off, or &quot;Y&quot;^@NPR.Z.UI.tmp.tdata.row.dis.sel to disable a row&apos;s checkbox) will remain disabled.</cmt>
  </macro>
  <macro>
    <name>UI.table.orientation</name>
    <act>Y</act>
    <stx>@UI.table.orientation(TblAppId,Orientation)</stx>
    <dsc>Set the orientation (horizontal, vertical) of a table</dsc>
    <code>%(NPR)UI..tbl.mod(.OR,{@1,@2})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

Orientation
     &quot;H&quot; - horizontal - if gray/white striping is enabled, stripes will be horizontal, i.e.
           rows; if highlighting is in effect, current row in focus will be highlighted
     &quot;V&quot; - vertical - if gray/white striping is enabled, stripes will be vertical, i.e.
           columns; if highlighting is in effect, current column in focus will be
           highlighted</cmt>
  </macro>
  <macro>
    <name>UI.table.remove</name>
    <act>Y</act>
    <stx>@UI.table.remove(TblAppId)</stx>
    <dsc>Removes table referenced by TblAppId and all child objects</dsc>
    <code>%(NPR)UI..m.table(.TD,{@1})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

Removes table and child objects from state table, state index, and screen</cmt>
  </macro>
  <macro>
    <name>UI.table.reset.nav</name>
    <act>Y</act>
    <stx>@UI.table.reset.nav(TblAppId,SectionPredecessor)</stx>
    <dsc>Resets table to follow specified object in navigation section loop</dsc>
    <code>%(NPR)UI..tbl.nav(.RN,{@1,@2})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

SectionPredecessor
     This is the UI object ID (handle) of the object from which this table should take
     navigation focus when the F6 key is hit.</cmt>
  </macro>
  <macro>
    <name>UI.table.row.get.focus</name>
    <act>Y</act>
    <stx>@UI.table.row.get.focus(TblAppId)</stx>
    <dsc>Retrieve the current focus table and row</dsc>
    <code>%(NPR)UI..tbl.nav(.RF,{@1})</code>
    <cmt>This macro is used to get the current focus table sequence and row sequence for the specified table.

TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

Return Value: Current {Table,Row} focus sequence numbers.</cmt>
  </macro>
  <macro>
    <name>UI.table.row.remove</name>
    <act>Y</act>
    <stx>@UI.table.row.remove(TblAppId[,&quot;Selection&quot;])</stx>
    <dsc>Removes row(s), supplied in a list, from table</dsc>
    <code>%(NPR)UI..m.table(.RR,{@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

Expects list of rows to be removed in:

@NPR.Z.UI.tmp.table.rows.to.remove[TblAppId,RowAppId] = 1
                                           ,RowAppId] = 1
                                            -
                                            -
                                            -
                                           ,RowAppId] = 1

This operation does not normally delete the list of rows to remove when finished.  However,
if the 2nd argument is the word &quot;Selection&quot;, then this list will automatically become a copy of TblAppId&apos;s current selection, and will be deleted upon completion of the operation.</cmt>
  </macro>
  <macro>
    <name>UI.table.row.scroll.into.view</name>
    <act>Y</act>
    <stx>@UI.table.row.scroll.into.view(TblAppId,RowAppId[,SetFocusFlag])</stx>
    <dsc>Scrolls table if necessary to get specified row into view, optionally set focus</dsc>
    <code>%(NPR)UI..tbl.nav(.SV,{@1,@2&quot;_IF{S[3] &quot;,@3&quot;}_&quot;})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

RowAppId
     This is the @NPR.Z.UI.tmp.tdata.row.app.id (from the original table temp definition) of
     the desired target row.

SetFocusFlag
     0 - if target row is not currently highlighted, do not highlight
     1 - if target row is not currently highlighted, highlight
     2 - unconditionally set lolite focus on the target row.
     If not supplied, &quot;1&quot; is assumed as the default</cmt>
  </macro>
  <macro>
    <name>UI.table.row.select</name>
    <act>Y</act>
    <stx>@UI.table.row.select(TblAppId,RowAppId)</stx>
    <dsc>Select (check) the check box of a single row in a table.</dsc>
    <code>%(NPR)UI..tbl.mod(.SR,{@1,@2})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

RowAppId
     This is the @NPR.Z.UI.tmp.tdata.row.app.id (from the original table temp definition) of
     the desired target row.

*** NOTE ***
If the table containing the row is collapsed, this macro will have no effect.
The row to be selected will not be scrolled to or given focus.</cmt>
  </macro>
  <macro>
    <name>UI.table.row.set.focus</name>
    <act>Y</act>
    <stx>@UI.table.row.set.focus(TblAppId,RowAppId[,ScrollIntoView])</stx>
    <dsc>Moves focus (highlight bar, if enabled) to row on table, optionally scroll to it</dsc>
    <code>%(NPR)UI..tbl.nav(.SF,{@1,@2&quot;_IF{S[3]!S[4] &quot;,@3&quot;}_IF{S[4] &quot;,@4&quot;}_&quot;})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

RowAppId
     This is the @NPR.Z.UI.tmp.tdata.row.app.id (from the original table temp definition) of
     the desired target row.

ScrollIntoView
     0 - if target row is not currently in view, do not scroll it into view
     1 - if target row is not currently in view, scroll it into view
     If not supplied, &quot;1&quot; is assumed as the default

*** NOTE ***
If the table of the row specified doesn&apos;t currently have focus then the background color of the row, if enabled, will be set to the lolite green instead of the highlite green.</cmt>
  </macro>
  <macro>
    <name>UI.table.row.subscripts</name>
    <act>Y</act>
    <stx>@UI.table.row.subscripts(TblAppId,RowAppId)^{tmp.tdata.table,tmp.tdata.row.seq}</stx>
    <dsc>Returns internal section/row subscripts for given table/row app ID</dsc>
    <code>%(NPR)UI..tbl.nav(.RS,{@1,@2})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

RowAppId
     This is the @NPR.Z.UI.tmp.tdata.row.app.id (from the original table temp definition) of
     the desired target row.</cmt>
  </macro>
  <macro>
    <name>UI.table.row.unselect</name>
    <act>Y</act>
    <stx>@UI.table.row.unselect(TblAppId,RowAppId)</stx>
    <dsc>Un-select (un-check) the check box of a single row in a table.</dsc>
    <code>%(NPR)UI..tbl.mod(.UR,{@1,@2})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

RowAppId
     This is the @NPR.Z.UI.tmp.tdata.row.app.id (from the original table temp definition) of
     the desired target row.

*** NOTE ***
If the table containing the row is collapsed, this macro will have no effect.
The row to be un-selected will not be scrolled to or given focus.</cmt>
  </macro>
  <macro>
    <name>UI.table.rows.displayed</name>
    <act>Y</act>
    <stx>@UI.table.rows.displayed(TblAppId)^{First,Last}</stx>
    <dsc>Returns numeric seq. of first/last rows displayed in scroll region, + row list</dsc>
    <code>%(NPR)UI..tbl.nav(.RA,{@1})</code>
    <cmt>03/15/2006 DMendes:
Research has revealed that this macro only has the potential of being accurate if the visible rows in a panel is evenly divisible by 14 (13 pixels + 1 pixel for divider) and the table is rendered in the 1 multiplier.  The reason for this is that the calculation is based on the current scroll position and applied to an index of row height values in the 1 multiplier.

The value returned for the current scroll position is an internal number for use by the DLL and can&apos;t directly be applied to any pre-built index.  The index is meaningless in any other multiplier and to create an index for every possible mutliplier is overkill.  The entries in this index are also padded by 1 to compensate for the row dividers.  In any other multiplier than 1 the cell height is based on the multiplier but the row dividers are absolute values (row 2 is positioned n pixels from row 1).

Based on this review this macro is deemed unsupportable by the current version of the MGUI.dll.
===========================================================================================

TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

First
     This is the sequential number of the topmost WHOLE row currently showing in the
     scrollable region of the table (i.e., below any pinned rows).

Last
     This is the sequential number of the bottommost WHOLE row currently showing in the
     scrollable region of the table.

Note:  with the vertical scroll thumb all the way at the top...if one row is pinned, &quot;First&quot; will contain &quot;2&quot;; if two rows are pinned, &quot;First&quot; will contain &quot;3&quot;, etc.

In addition to First and Last values, a list will be returned in the following format:

     @NPR.Z.UI.tmp.table.rows.displayed[TblAppId,RowNum] = {RowAppId}

For example, in a table called &quot;Results&quot;, with the vertical scroll thumb positioned so that rows 11 through 20 are currently showing, the following list might be returned...

     @NPR.Z.UI.tmp.table.rows.displayed[&quot;Results&quot;,11] = {&quot;20050328 0600&quot;}
                                                 ,12] = {&quot;20050328 1000&quot;}
                                                   -
                                                   -
                                                   -
                                                 ,20] = {&quot;20050329 1300&quot;}</cmt>
  </macro>
  <macro>
    <name>UI.table.save</name>
    <act>Y</act>
    <stx>@UI.table.save(TblAppId)</stx>
    <dsc>Replaces original, application-built temp with current screen representation</dsc>
    <code>%(NPR)UI..tbl.utl(.TS,{@1})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.</cmt>
  </macro>
  <macro>
    <name>UI.table.scroll.position.get</name>
    <act>Y</act>
    <stx>@UI.table.scroll.position.get(TblAppId)</stx>
    <dsc>Returns current {Left,Top} scroll position of table TblAppId</dsc>
    <code>%(NPR)UI..tbl.nav(.SG,{@1})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

This macro is the complement to @UI.table.scroll.position.set.</cmt>
  </macro>
  <macro>
    <name>UI.table.scroll.position.set</name>
    <act>Y</act>
    <stx>@UI.table.scroll.position.set(TblAppId,Left,Top,Override)</stx>
    <dsc>Sets table TblAppId&apos;s current scroll position to Left and Top</dsc>
    <code>%(NPR)UI..tbl.nav(.SS,{@1,@2,@3&quot;_IF{S[4] &quot;,@4&quot;}_&quot;})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

Left
     In a table with a horizontal scrollbar, this is the number of logical pixels to the
     right of far left to which the horizontal scroll position should be set

Top
     In a table with a vertical scrollbar, this is the number of logical pixels down from
     the very top to which the vertical scroll position should be set

Override
     This is a flag to tell the table tool to not let the highlight code scroll the focus
     row into view leaving the scroll position where this macro set it.

This macro is the complement to @UI.table.scroll.position.get.</cmt>
  </macro>
  <macro>
    <name>UI.table.sel.cnt.msg</name>
    <act>Y</act>
    <stx>@UI.table.sel.cnt.msg(TblAppId,Parent,Left,Top,Text[,Font,Color])</stx>
    <dsc>Displays TblAppId&apos;s selection count message Text at Left,Top in Parent</dsc>
    <code>%(NPR)UI..tbl.utl(.SD,{@1,@2,@3,@4,@5&quot;_IF{S[6]!S[7] &quot;,@6,@7&quot;}_&quot;})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

Parent
     The object ID of the region or panel that is to contain the selection count message.
     Most often, this will be the same as @NPR.Z.UI.tmp.tdef.parent.

Left
     The leftmost starting point of the selection count message, relative to the left wall
     of the parent container.

Top
     The topmost starting point of the selection count message, relative to the top wall of
     the parent container.

Text
     The text of the selection count message.  Standard selection count messages are in the
     form &quot;X of Y Selected&quot;, where X represents the number currently selected (checked), and
     Y represents the total selectable items.

Font
     The number of a font to override the default.  (optional)

Color
     color number used for displaying the object.  This value determines the foreground
     color for the text.  If nil is specified or the attribute is omitted from the macro,
     black will be used.  A list of valid colors is available in the NPR.Z.UI: colors and
     colors.system data definition segments.  (optional)

Note:  if either Font or Color is specified, the other must be specified, even if nil is used.

The benefit of using this macro instead of a simple UI.text.create is that UI.table.sel.cnt.msg (a) generates (if necessary), (b) tracks, and (c) destroys (if necessary) the message text object.</cmt>
  </macro>
  <macro>
    <name>UI.table.select.all</name>
    <act>Y</act>
    <stx>@UI.table.select.all(TblAppId)</stx>
    <dsc>Select (check) all selectable rows in table</dsc>
    <code>%(NPR)UI..tbl.mod(.SA,{@1})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

This macro applies to multi-select tables (@NPR.Z.UI.tmp.tdef.multiselect = &quot;Y&quot;).  As a result of this operation, all selectable rows in the table will be selected/checkmarked, regardless of whether or not they are currently hidden within a collapsed section.</cmt>
  </macro>
  <macro>
    <name>UI.table.selected.items</name>
    <act>Y</act>
    <stx>@UI.table.selected.items(TblAppId)</stx>
    <dsc>Number of exposed items in table currently selected (checked)</dsc>
    <code>%(NPR)UI..tbl.utl(.SI,{@1})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

A typical use for this macro would be within a program that displays the current selection totals, e.g.:

(@UI.table.selected.items(&quot;MyTable&quot;),&quot;of&quot;,@UI.table.total.items(&quot;MyTable&quot;),&quot;selected&quot;)^TXT,
@UI.text.create(@UI.r.header,&quot;C&quot;,&quot;M&quot;,TXT)</cmt>
  </macro>
  <macro>
    <name>UI.table.sort.get</name>
    <act>Y</act>
    <stx>@UI.table.sort.get(TblAppId,SectionUrn)^{Column,Direction}</stx>
    <dsc>Returns {Column,Direction} of current sort for the specified table section</dsc>
    <code>%(NPR)UI..tbl.utl(.OG,{@1,@2})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

SectionUrn
     This is the sequence URN (NPR.Z.UI.tmp.tdata.table) of the section for which you wish
     to obtain current sort information.

Column
     This is the sequence URN of the column within the specified section that was last used
     for sorting.

Direction
     This is the direction in which the last sort for the indicated column was done:

     &quot;A&quot; = A-Z goes from top to bottom
     &quot;D&quot; = A-Z goes from bottom to top</cmt>
  </macro>
  <macro>
    <name>UI.table.sort.set</name>
    <act>Y</act>
    <stx>@UI.table.sort.set(TblAppId,SectionUrn,Column[,Direction])</stx>
    <dsc>Sorts table section by data in specified column, with optional direction</dsc>
    <code>%(NPR)UI..m.table(.OS,{@1,@2,@3,&quot;_IF{S[4] &quot;@4&quot;;&quot;nIL&quot;}_&quot;,1})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

SectionUrn
     This is the sequence URN (NPR.Z.UI.tmp.tdata.table) of the section you wish to sort.

Column
     This is the sequence URN of the column within the specified section that contains the
     data by which the sort should be done.

Direction (optional)
     This is the direction in which the sort should be done:

     &quot;A&quot; = A-Z goes from top to bottom
     &quot;D&quot; = A-Z goes from bottom to top

     If this is omitted, then the &quot;sort as if clicked&quot; default will be used.</cmt>
  </macro>
  <macro>
    <name>UI.table.subscripts.row</name>
    <act>Y</act>
    <stx>@UI.table.subscripts.row(TblAppId,Section,Row)^RowAppId</stx>
    <dsc>For table, section URN, and row URN, returns row application ID</dsc>
    <code>%(NPR)UI..tbl.nav(.SR,{@1,@2,@3})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

Section
     This is the subscript indicating the unique table section of interest.

Row
     This is the subscript indicating the unique table row of interest within the specified
     section.

RowAppId
     This is the returned row application ID associated with the designated table, section,
     and row.

Notes:

     If both Section and Row are supplied, a data row is indicated.
     If only the Section is supplied, a header row is indicated.
     If only the Row is supplied, a footer row is indicated.</cmt>
  </macro>
  <macro>
    <name>UI.table.title</name>
    <act>Y</act>
    <stx>@UI.table.title(TblAppId,Title[,Location])</stx>
    <dsc>Adds, removes, changes, relocates a table title</dsc>
    <code>%(NPR)UI..m.table(.TT,{@1,@2&quot;_IF{S[3] &quot;,@3&quot;}_&quot;})</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.table.total.items</name>
    <act>Y</act>
    <stx>@UI.table.total.items(TblAppId)</stx>
    <dsc>Total number of exposed selectable (checkable) items in table</dsc>
    <code>%(NPR)UI..tbl.utl(.TI,{@1})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

A typical use for this macro would be within a program that displays the current selection totals, e.g.:

(@UI.table.selected.items(&quot;MyTable&quot;),&quot;of&quot;,@UI.table.total.items(&quot;MyTable&quot;),&quot;selected&quot;)^TXT,
@UI.text.create(@UI.r.header,&quot;C&quot;,&quot;M&quot;,TXT)</cmt>
  </macro>
  <macro>
    <name>UI.table.unselect.all</name>
    <act>Y</act>
    <stx>@UI.table.unselect.all(TblAppId)</stx>
    <dsc>Un-select (un-check) all selectable rows in table</dsc>
    <code>%(NPR)UI..tbl.mod(.UA,{@1})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

This macro applies to multi-select tables (@NPR.Z.UI.tmp.tdef.multiselect = &quot;Y&quot;).  As a result of this operation, all selectable rows in the table will be unselected/un-checkmarked, regardless of whether or not they are currently hidden within a collapsed section.</cmt>
  </macro>
  <macro>
    <name>UI.table.update</name>
    <act>Y</act>
    <stx>@UI.table.update(TblAppId[,SortFlag])</stx>
    <dsc>Replaces table referenced by TblAppId with new version</dsc>
    <code>%(NPR)UI..m.table(.TU,{@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;})</code>
    <cmt>TblAppId
     This is the unique table identifier supplied by the application with the original
     @UI.table.create.

SortFlag
     Please see the description for this argument in the documentation for macro
     UI.table.create.

Expects table/cell definition and content to be built already in segments:

@NPR.Z.UI.tmp.tcell...
@NPR.Z.UI.tmp.table...
@NPR.Z.UI.tmp.tdata...

Equivalent to doing @UI.table.remove(TblAppId) followed by @UI.table.create(TblAppId).</cmt>
  </macro>
  <macro>
    <name>UI.text.create</name>
    <act>Y</act>
    <stx>@UI.text.create(parent,left,top,text[,font,color,width])^handle</stx>
    <dsc>Places a request to create/draw a text object on the UI queue.</dsc>
    <code>%(NPR)UI..m.text(.TC,{@1,@2,@3,@4&quot;_IF{S[5] &quot;,@5,@6&quot;_IF{S[7] &quot;,@7&quot;}}_&quot;})</code>
    <cmt>A handle will be generated and returned.

Parent:    the handle of the object&apos;s parent object.  The parent object will usually be a
           panel.

Left:      a fixed horizontal position specified in pixels or an attribute command
           (L, C, or R).  Attribute commands specify Left, Center, or Right horizontal
           Justification.  This position is relative to the parent object.

Top:       a fixed vertical position specified in pixels or an attribute command
           (T, M, or B).  Attribute commands specify Top, Middle, or Bottom vertical
           justification.  This position is relative to the parent object.

Text:      text to display for the object.

Font:      font number to use for displaying the object.  If nil is specified or the font is
           omitted from the macro, the small size font will be used.

Color:     color number used for displaying the object.  This value determines the
           foreground color for the text.  If nil is specified or the attribute is omitted
           from the macro, black will be used.  A list of valid colors is available in the
           NPR.Z.UI: colors and colors.system data definition segments.

Width:     width (in pixels) of the text to be displayed. If actual width of text exceeds
           width value, then text displays truncated with an ellipsis [...] at the end.

NOTE: To specify the font and use the default color, enter a font for the fifth argument
      and nil for the sixth.  The opposite is true for specifying a color and using the
      default font.</cmt>
  </macro>
  <macro>
    <name>UI.text.remove</name>
    <act>Y</act>
    <stx>@UI.text.remove(handle)</stx>
    <dsc>Removes a text string from the display</dsc>
    <code>%(NPR)UI..m.text(.TR,{@1})</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.text.upd.width</name>
    <act>Y</act>
    <stx>@UI.text.upd.width(element,screen.or.*,width)</stx>
    <dsc>Erases and redisplays a text field with specified width</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..screen(^S)_&quot;</code>
    <cmt>This macro will update (erase and redisplay) the field specified at the new width.  The code  for this macro will only be added to the appropriate program&apos;s object code if:

     - A width has been specified
     - The field specified is using the FFW (Fixed Font Width) attribute.  See NPR DTS 1215         for more information.

With the code from this macro in place, the update will only occur if the width specified is different than the specified field&apos;s current width.</cmt>
  </macro>
  <macro>
    <name>UI.window.clipboard</name>
    <act>Y</act>
    <stx/>
    <dsc>Sends current window to the clipboard</dsc>
    <code>#my[@(108,0,1)]</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.window.close</name>
    <act>Y</act>
    <stx/>
    <dsc>Closes the current window</dsc>
    <code>%(NPR)UI..m.misc(.WC)</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.window.is.open</name>
    <act>Y</act>
    <stx/>
    <dsc>Return True if a MGUI.DLL window is open.</dsc>
    <code>#zW</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.window.open</name>
    <act>Y</act>
    <stx>@UI.window.open(window.size,NoHdr,NoFtr,NoMenuRgn)</stx>
    <dsc>Opens a new window.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..ui(^S)_&quot;</code>
    <cmt>window.size: Available sizes... SMALL, MEDIUM, CHILD, MAIN

SMALL, MEDIUM have only footer region.

MAIN has header,footer,function

CHILD has footer, function  REGIONS

NoHdr = Create a window with no header
NoFtr = Create a window with no footer
NoMenuRgn = Create a window with no menu region
</cmt>
  </macro>
  <macro>
    <name>UI.window.print</name>
    <act>Y</act>
    <stx/>
    <dsc>Sends current window to default printer.</dsc>
    <code>#my[@(108,0,0)]</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.window.show</name>
    <act>Y</act>
    <stx>@UI.window.show(windowshow)</stx>
    <dsc>Display the UI window according the windowshow</dsc>
    <code>#my[@(105,@1)]</code>
    <cmt>[window show]

 1 = Normal
 2 = Minimize
 3 = Maximize
 4 = Normal but not activated
 6 = Minimize
 7 = Minimize but do not activate
 8 = Show but do not activate
 9 = Restore
</cmt>
  </macro>
  <macro>
    <name>UI.window.title</name>
    <act>Y</act>
    <stx>@UI.window.title(title)</stx>
    <dsc>Changes the title of the top window</dsc>
    <code>%(NPR)Z.UI..display.window.title(.DSK,@1)</code>
    <cmt>Approved User Formats for Window Title:
         Desktop:  Desktop Name - Fac/Site/Dept (system) - User&apos;s name

(system: &quot;In-house&quot; or &quot;Test&quot; )
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Internal Usage:
      Dictionary:  Dictionary Name (system) - User&apos;s name
         Lookups:  Title/Description &quot;Lookup&quot;

The default format is Desktop.

Lookups will be handled internally by the lookup program and will not be using this macro, but will make calls to the procedure.  The word &quot;Lookup&quot; will be appended to the Title/Description if not found in the string.

Screen Translator (%NPRSUIS) will insert a 3rd argument. This will allow the display function to determine if the screen is a dictionary or not.

Multipage driver makes a direct call to the procedure to pass the 3rd arg for dictionary determination.
</cmt>
  </macro>
  <macro>
    <name>UI.window.update</name>
    <act>Y</act>
    <stx/>
    <dsc>Flushes commands in the UI command buffer to the MGUI.DLL</dsc>
    <code>%(NPR)UI..execute(.)</code>
    <cmt>This macro will send the UI commands to the MGUI.DLL.
Child open and closing of windows are handled immediately, so those will not be part of a UI.window.update.   Each time this routine is called will incur a small penalty as the UI DLL is re-drawing the entire window.  The penalty is large when more objects are in the window. Doing this in 3-tier will slow down 3tier as the overhead of pushing the buffer to the client can become too much.  A few updates will not destroy performance, but many updates will affect 3-tier.

Any W.display will be closed when UI.window.update is executed.  (Also if the tools update the window, W.display dialog will be closed)
</cmt>
  </macro>
  <macro>
    <name>UI.workspace.clear</name>
    <act>N</act>
    <stx>@UI.workspace.clear(handle)</stx>
    <dsc>Clears out contents of the Owner Draw Window</dsc>
    <code>%(NPR)UI..m.misc(.WSCL,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.workspace.create</name>
    <act>Y</act>
    <stx>@UI.workspace.create(Parent,left,top,ht,wt)</stx>
    <dsc>Creates an Owner Draw window as a workspace on the parent object</dsc>
    <code>%(NPR)UI..m.misc(.WSC,{@1,@2,@3,@4,@5})</code>
    <cmt>returns handle</cmt>
  </macro>
  <macro>
    <name>UI.workspace.dll.execute</name>
    <act>Y</act>
    <stx>@UI.workspace.dll.execute(Parent,Ordinal,Buffer,New Buffer)</stx>
    <dsc>Executes an FS style DLL ordianal</dsc>
    <code>%(NPR)UI..m.misc(.WSDE,{@1,@2,@3&quot;_IF{S[4] &quot;,@4&quot;}_&quot;})</code>
    <cmt>Parent:      Id of the Workspace that was created.

Ordinal:     Ordinal to Execute.

Buffer:      Buffer number with data for DLL.

New Buffer:  An optional argument that can be 0 or 1.  If the value is 1 a new memory buffer
             will be allocated to execute the ordinal.  This is needed to ensure proper
             functionality with the twaintool dll and the MGUI dll, so other dlls will
             likely not have a need for this argument.</cmt>
  </macro>
  <macro>
    <name>UI.workspace.dll.load</name>
    <act>Y</act>
    <stx>@UI.workspace.dll.load(Parent,name,char)</stx>
    <dsc>Loads an FS style DLL into the workspace indicated by the parent</dsc>
    <code>%(NPR)UI..m.misc(.WSDL,{@1,@2,@3})</code>
    <cmt>Parent:  Id of the Workspace that was created.

Name:    Name of the dll to load including the `.dll&apos;.

Char:    Return character value.</cmt>
  </macro>
  <macro>
    <name>UI.workspace.dll.unload</name>
    <act>Y</act>
    <stx>@UI.workspace.dll.unload(Parent)</stx>
    <dsc>Unloads an FS style DLL from a workspace.</dsc>
    <code>%(NPR)UI..m.misc(.WSDUL,{@1})</code>
    <cmt>Parent:  Id of the Workspace that was created.</cmt>
  </macro>
  <macro>
    <name>UI.workspace.open</name>
    <act>N</act>
    <stx>@UI.workspace.open(Parent,left,top,ht,wt)</stx>
    <dsc>Creates an Owner Draw window as a workspace on the parent object</dsc>
    <code>%(NPR)UI..m.misc(.WSO,{@1,@2,@3,@4,@5})</code>
    <cmt>returns handle</cmt>
  </macro>
  <macro>
    <name>UI.workspace.remove</name>
    <act>Y</act>
    <stx>@UI.workspace.remove(handle)</stx>
    <dsc>Removes Owner Draw window and contents from the display</dsc>
    <code>%(NPR)UI..m.misc(.WSR,@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.workspace.screen.handle</name>
    <act>N</act>
    <stx>@UI.workspace.screen.handle(name,number)</stx>
    <dsc>Returns handle number for the Screen name / Number identified.</dsc>
    <code>/(UI)FLDE[@1,@2]</code>
    <cmt>Only used for elements that are created by a screen. This will return the handle associated to the screen name and field marker that are supplied.

Name:    The screen program name. Eg: &quot;MIS.MTDD.test&quot;

Number:  The screen field marker number as identified when the screen is created. Eg: 10</cmt>
  </macro>
  <macro>
    <name>UI.z.check.buf</name>
    <act>Y</act>
    <stx>@UI.z.check.buf(milliseconds)</stx>
    <dsc>Checks if character exists in the input buffer.</dsc>
    <code>%(NPR)UI..input.buf.chk(&quot;_IF{&quot;@1&quot;;D(34)_D(34)}_&quot;)</code>
    <cmt>The wait in milliseconds enables the application to toggle resource use as the
input buffer read is an intensive operation. Examples of optimizing procedure use:

- Checking for buffer input to do something with input buffer -
  Checks input buffer with each iteration of the loop.
  Useful for cleaning out buffer, not waiting for user interrupt

     DO{@UI.z.check.buf @DO.SOMETHING.WITH.INPUT.BUFFER}

- Checking for keyboard buffer input while compiling data -
  Checks keyboard buffer after every 500 milliseconds thus reducing the resource use if
  compiling data only requires a few milliseconds.
  Also useful if checking for user interrupt.

     DO{@UI.z.check.buf(500)_.=. @COMPILE.SOME.DATA;
        @DO.SOMETHING.WITH.KEYBOARD.INPUT}
</cmt>
  </macro>
  <macro>
    <name>UI.z.dll.loaded</name>
    <act>N</act>
    <stx/>
    <dsc>Return True if the MGUI.DLL is loaded.</dsc>
    <code>#mu</code>
    <cmt>For use by UI Tools.</cmt>
  </macro>
  <macro>
    <name>UI.z.drag.and.drog</name>
    <act>N</act>
    <stx>@UI.z.drag.and.drog(procedure.urn)</stx>
    <dsc>Allows window to work with drag and drop and sets hook</dsc>
    <code>%(NPR)UI..m.drag.drop(@1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.z.drag.and.drop</name>
    <act>Y</act>
    <stx>@UI.z.drag.and.drop(procedure.urn)</stx>
    <dsc>Changes drag and drop state and sets/clears program hook</dsc>
    <code>%(NPR)UI..m.drag.drop(@1)</code>
    <cmt>Passing in a program will set the window to allow drag and drop.
Also program is the hook.

Calling the macro with no program (&quot;&quot;) will turn off drag and drop for the window and clear the hook.

The hook program will be passed

Arg A is the application.data for the cell that the drag started on.
Arg B is the application.data for the cell that the drag ended on.

Application is responsible for dealing with invalid drag and drops.  It is suggested that they be simply ignored.

If arg A or B is nil then no application.data for that cell.</cmt>
  </macro>
  <macro>
    <name>UI.z.execute</name>
    <act>N</act>
    <stx/>
    <dsc>Tells the client to execute the UI commands in the membuffer</dsc>
    <code>#mx[/(UI)ST|4]</code>
    <cmt>Used by UI system tools.</cmt>
  </macro>
  <macro>
    <name>UI.z.exit</name>
    <act>Y</act>
    <stx>@UI.exit</stx>
    <dsc>Exits the UI system</dsc>
    <code>%(NPR)UI..m.misc(.X)</code>
    <cmt>NPR systems macro.</cmt>
  </macro>
  <macro>
    <name>UI.z.file.dialog.open</name>
    <act>Y</act>
    <stx>@UI.z.file.dialog.open(title,path,filename)</stx>
    <dsc>Open a file open dialog</dsc>
    <code>#my[@(1100,&quot;_D(34)_&quot;Open&quot;_D(34)_&quot;,@1,@2,@3,0)],#z|0</code>
    <cmt>Returns filename

title:     Title for dialog box, nil will default Open
path:      Initial search path
filename:  Name to place in edit field of dialog

This macro translates to a command to the MGUI.dll. So the command buffer may need to be cleared by a call to %NPR.UI.execute(&quot;&quot;) before calling this macro or you could have out-of-order execution of MGUI commands.</cmt>
  </macro>
  <macro>
    <name>UI.z.file.dialog.save</name>
    <act>Y</act>
    <stx>@UI.z.file.dialog.save(title,path,filename)</stx>
    <dsc>Opens save as dialog box.</dsc>
    <code>#my[@(1100,&quot;_D(34)_&quot;Save&quot;_D(34)_&quot;,@1,@2,@3,1)],#z|0</code>
    <cmt>Returns filename with path.

title:     Title for dialog box, nil will default Save As
path:      Initial search path
filename:  Name to place in edit field of dialog

This macro translates to a command to the MGUI.dll. So the command buffer may need to be cleared by a call to %NPR.UI.execute(&quot;&quot;) before calling this macro or you could have out-of-order execution of MGUI commands.</cmt>
  </macro>
  <macro>
    <name>UI.z.get.buf</name>
    <act>Y</act>
    <stx>@UI.z.get.buf(milliseconds)</stx>
    <dsc>Checks if character exists in input buffer, and if so, return it</dsc>
    <code>%(NPR)UI..input.buf.get(&quot;_IF{&quot;@1&quot;;D(34)_D(34)}_&quot;)</code>
    <cmt>  It is recommended that applications use this routine (not @UI.z.check.buf)
to avoid race conditions that can appear when checking the input buffer.

  Since the input buffer is associated to the current window, it is possible that
you can get into a state where MGUI reports that there is data in buffer, but
the subsequent read hangs waiting for input. The 1 second timeout mitigates this
problem.

The wait in milliseconds enables the application to toggle resource use as the
input buffer read is an intensive operation. Examples of optimal procedure use:

- Checking for buffer input to do something with input buffer -
  Checks input buffer with each iteration of the loop.
  Useful for cleaning out buffer, not waiting for user interrupt

     DO{@UI.z.get.buf^CHAR}

- Checking for keyboard buffer input while compiling data -
  Checks keyboard buffer after every 500 milliseconds thus reducing the resource use if
  compiling data only requires a few milliseconds.
  Also useful if checking for user interrupt.

     DO{@UI.z.get.buf(500)^CHAR_.=. @DO.PROCESSING;
        CHAR&apos;=@Z.esc}
</cmt>
  </macro>
  <macro>
    <name>UI.z.get.char</name>
    <act>Y</act>
    <stx/>
    <dsc>Single character get</dsc>
    <code>#my[@(510)],#z#1P</code>
    <cmt>Used as a Single Character Read.
Returns Character from input buffer.
</cmt>
  </macro>
  <macro>
    <name>UI.z.get.multiplier</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the multiplier of the MGUI window.</dsc>
    <code>#my[@(10005)],#z|0</code>
    <cmt/>
  </macro>
  <macro>
    <name>UI.z.get.scroll.position</name>
    <act>Y</act>
    <stx>@UI.z.get.scroll.position(Panel)</stx>
    <dsc>Returns the left and top physical pixel position of a scrollable panel.</dsc>
    <code>%(NPR)UI..m.misct(.GP,@1)</code>
    <cmt>Returns queue string format - Q(Left Pixel Pos,Top Pixel Pos).</cmt>
  </macro>
  <macro>
    <name>UI.z.initialize</name>
    <act>Y</act>
    <stx>@UI.z.initialize(multiplier)</stx>
    <dsc>Initialize the UI system</dsc>
    <code>%(NPR)UI..m.misc(.ZI,{@1})</code>
    <cmt>multiplier is used to set the windows logical pixel multiplier value.
&quot;&quot;        use default
number    this will multiply the logical pixels.  anything less then one is not allowed.

This macro is used by the NPR system to setup the UI interface.  Applications will have this done for them by NPR.</cmt>
  </macro>
  <macro>
    <name>UI.z.launch.report</name>
    <act>Y</act>
    <stx>@UI.z.launch.report(Report procedure urn)</stx>
    <dsc>Launches a report as a new session expects @.on.device to have a value</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..ui(^S)_&quot;</code>
    <cmt>Launches a new session to run the report passed in as argument 1.

Z.on.device should have been used to set @.on.device.
Will run the report via menu logic.  If no menu logic then must pass in tranlated program call.</cmt>
  </macro>
  <macro>
    <name>UI.z.set.cursor</name>
    <act>N</act>
    <stx>@UI.z.set.cursor(Pointer)</stx>
    <dsc>Sets the Cursor</dsc>
    <code>#mX[/(.S).UI|3],@(104,@1)^#mW[/(.S).UI|3],#mx[/(.S).UI|3]</code>
    <cmt>Pointer -   0   - Standard Arrow
            1   - Hourglass</cmt>
  </macro>
  <macro>
    <name>UI.z.set.timeout</name>
    <act>Y</act>
    <stx/>
    <dsc>Set screen timeout to a value in seconds</dsc>
    <code>SCRN.TM,#mX[/(.S).UI|3],@(511,SCRN.TM)^#mW[/(.S).UI|3],#mx[/(.S).UI|3]</code>
    <cmt>Sets the screen timeout to the value in seconds.
Assumes that a UI window is open.

Example Syntax:
@.scrn.tm^@UI.z.set.timeout</cmt>
  </macro>
  <macro>
    <name>UI.z.start.session</name>
    <act>Y</act>
    <stx>@UI.z.start.session(procedure.urn)</stx>
    <dsc>Starts a new session with the menu logic of the passed in Procedure</dsc>
    <code>%(NPR)UI..launch(@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;)</code>
    <cmt>This macro will start a new session.

It will not do any checking, it will inherit all slash prefixes/variables, except UI stuff.

The total size of slash variables to be passed to the new process must not exceed 512 KBytes or the session will fail to launch.

This macro will run the menu logic.  If there is no menu logic, then argument A better be a translated procedure call.

Note: this should not be used for bkg jobs that would best be served to be tracked by MIS.PROCESS even if it is going to run on the client.  There is no logging or success tracking by this function.  It is designed to get the new user session up as fast as possible.

Return: IPC Group/name of started job.  To break name back into group and session split string on &quot;/&quot;
</cmt>
  </macro>
  <macro>
    <name>UI.z.string.len</name>
    <act>Y</act>
    <stx>@UI.z.string.len(text,{font})</stx>
    <dsc>Figures out the {wt,ht} of the text based on default or optional font attribute</dsc>
    <code>%(NPR)UI..str.len(@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;)</code>
    <cmt>If no font attribute is passed in, then the current attribute is used to determine length.

return:
{Width in logical Pixels,Height in logical pixels, Width in physical pixels, Height in physical pixels}

So how do we use this extra information.

When specifying how big a cell should be, you would use the logical pixels.  Cell sizes are handed to the MGUI.DLL in logical pixels.  When specifying where text or other objects should go in cells, you should use physical pixels.  The objects are placed inside a cell using near object positioning, with 0,0 being the top left corner of the cell.

Example:

in 1.5 mutliplier (1440x900) screens:

The height of the @small.font.normal is 12 pixels in logical pixels and 18 pixels in physical pixels.  So if you wanted to put 2 rows of text in a cell, then the height of the cell would be defined as being 24 pixels high, two rows.
This will create a cell that is 36 physical pixels high on the screen.  The to place the 2 rows of text, row 1 would be at 0,0.  Row 2 would be at 0,18.
 </cmt>
  </macro>
  <macro>
    <name>UI.z.take.focus</name>
    <act>Y</act>
    <stx>@UI.z.take.focus(takeFocus)</stx>
    <dsc>Enables and disables MGUI taking focus messages sent to the term window</dsc>
    <code>#my[@(109,@1)]</code>
    <cmt>takeFocus

0 - Allow the term window to be given focus.
1 - MGUI will &quot;suck up&quot; focus messages to the term process.</cmt>
  </macro>
  <macro>
    <name>Undef.buf</name>
    <act>Y</act>
    <stx>@Undef.buf(@segment.name)</stx>
    <dsc>Tells translator that future refs to [segment.name] should revert to data def.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.buf(^S)_&quot;</code>
    <cmt>Tells the translator that all future references to the fields on [segment.name] should revert to using the data definition.

See @Def.buf.
</cmt>
  </macro>
  <macro>
    <name>Undef.t.rec</name>
    <act>Y</act>
    <stx>@Undef.t.rec(X)</stx>
    <dsc>Tells translator that future refs to [segment.name] should revert to data def.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..est.t.rec(^S)_&quot;</code>
    <cmt>Tells the translator that all future references to the fields which were using the temporary prefix /(.TX) should revert to using the prefix from the data definition.</cmt>
  </macro>
  <macro>
    <name>Unlock</name>
    <act>Y</act>
    <stx>@Unlock(node)</stx>
    <dsc>Unlocks a lock on [node] established by @Lock.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..locks(^S)_&quot;</code>
    <cmt>This will no longer unlock locks not created by the same job.
It will log a event in MIS.ERROR if a lock is missing or a lock does not belong to a process.
</cmt>
  </macro>
  <macro>
    <name>User.credentials</name>
    <act>Y</act>
    <stx>@User.credentials(server,port,type,name{,optional domains})</stx>
    <dsc>Set the user credentials for a system</dsc>
    <code>#UC[@1,@2,@3,@4&quot;_IF{S[5] &quot;,@5&quot;}_&quot;]</code>
    <cmt>server - NT server running MLogon service
port   - TCP port of MLogon service
type 0 - Use the default credentials.
type 1 - Use the default credentials and if those fail then prompt for username, password,            and domain. It is importnat ot recognize that the name and domain passed in are not          being authenticated. They just fill in the dialog box if it is needed.
type 2 - Always push dialog to prompt for username, password and domain.

returns 1 or nil on failure

Note: A nil response can have multiple causes:
        1. Logon is denied with given credentials.
        2. Cannot open a socket to MLogon - not running, wrong server, wrong port
        3. User exits out of credentials dialog.</cmt>
  </macro>
  <macro>
    <name>VSS.addcomponent</name>
    <act>Y</act>
    <stx/>
    <dsc/>
    <code>@Va</code>
    <cmt/>
  </macro>
  <macro>
    <name>VSS.backupsuccess</name>
    <act>Y</act>
    <stx/>
    <dsc/>
    <code>@Vg</code>
    <cmt/>
  </macro>
  <macro>
    <name>VSS.done.event</name>
    <act>Y</act>
    <stx/>
    <dsc/>
    <code>@Vde</code>
    <cmt/>
  </macro>
  <macro>
    <name>VSS.done.id</name>
    <act>Y</act>
    <stx/>
    <dsc/>
    <code>@Vdi</code>
    <cmt/>
  </macro>
  <macro>
    <name>VSS.load</name>
    <act>Y</act>
    <stx/>
    <dsc/>
    <code>@Vl</code>
    <cmt/>
  </macro>
  <macro>
    <name>VSS.snapid</name>
    <act>Y</act>
    <stx/>
    <dsc/>
    <code>@Vs</code>
    <cmt/>
  </macro>
  <macro>
    <name>VSS.threadexit</name>
    <act>Y</act>
    <stx/>
    <dsc/>
    <code>@Vx</code>
    <cmt/>
  </macro>
  <macro>
    <name>VSS.threadinit</name>
    <act>Y</act>
    <stx/>
    <dsc/>
    <code>@Vi</code>
    <cmt/>
  </macro>
  <macro>
    <name>VSS.unload</name>
    <act>Y</act>
    <stx/>
    <dsc/>
    <code>@Vu</code>
    <cmt/>
  </macro>
  <macro>
    <name>VSS.wait.event</name>
    <act>Y</act>
    <stx/>
    <dsc/>
    <code>@Vwe</code>
    <cmt/>
  </macro>
  <macro>
    <name>VSS.wait.id</name>
    <act>Y</act>
    <stx/>
    <dsc/>
    <code>@Vwi</code>
    <cmt/>
  </macro>
  <macro>
    <name>Video.button</name>
    <act>Y</act>
    <stx>@Video.button(objectHandle,row,column,flags,hotkey)</stx>
    <dsc>Makes a standard button from the [objectHandle].</dsc>
    <code>#vC[11,@2,@3,@4,@5,@1]</code>
    <cmt>Any number of buttons can be made from any given picture, limited by the rules for button creation.  [objectHandle] is returned by the @Video.capture.pict... macros, and by the @Video.pict.handle macro.

[flags] are the same flags as in @Button.make:  1 = Initially disabled.

[hotKey] is likewise the same as in @Button.make:  Pressing &lt;ALT&gt;hotKey will press the button both visually and logically; #L will be informed that the button was pushed.  Buttons created with this function are NOT deleted by the @Video.reset function, but instead are deleted either by closing the window or by the @Button.delete function.
</cmt>
  </macro>
  <macro>
    <name>Video.capture.close</name>
    <act>Y</act>
    <stx/>
    <dsc>Closes the capture window.</dsc>
    <code>#vC[2]</code>
    <cmt>It does not delete VideoObjects.</cmt>
  </macro>
  <macro>
    <name>Video.capture.enable</name>
    <act>Y</act>
    <stx>@Video.capture.enable(row,column,height,width)</stx>
    <dsc>Opens a capture window at the specified position and size.</dsc>
    <code>#vC[0,@1,@2,@3,@4]</code>
    <cmt>Starts displaying live pictures if there is a capture card and camera attached.</cmt>
  </macro>
  <macro>
    <name>Video.capture.pict.24</name>
    <act>Y</act>
    <stx/>
    <dsc>Captures a still picture in 24-bit `real&apos; color.  Returns VideoObject handle.</dsc>
    <code>#vC[1,0]</code>
    <cmt>VideoObjects are window-based; when a MagicCS window is closed, the VideoObjects created in it are deleted.  The current maximum number of VideoObjects is 16.</cmt>
  </macro>
  <macro>
    <name>Video.capture.pict.hi</name>
    <act>Y</act>
    <stx/>
    <dsc>Captures a still picture using the optimum palette containing 220 colors.</dsc>
    <code>#vC[1,220]</code>
    <cmt>Returns a VideoObject handle.

VideoObjects are window-based; when a MagicCS window is closed the VideoObjects created in it are deleted.  The current maximum number of VideoObjects is 16.</cmt>
  </macro>
  <macro>
    <name>Video.capture.pict.lo</name>
    <act>Y</act>
    <stx/>
    <dsc>Captures a still picture using the optimum palette containing 30 colors.</dsc>
    <code>#vC[1,30]</code>
    <cmt>This function returns a VideoObject handle.

VideoObjects are window-based; when a MagicCS window is closed the VideoObjects created in it are deleted.  The current maximum number of VideoObjects is 16.
</cmt>
  </macro>
  <macro>
    <name>Video.convert.to.lite</name>
    <act>Y</act>
    <stx>@Video.convert.to.lite(pictureHandle,memoryHandle)</stx>
    <dsc>Converts a VideoObject to EMR format in the specified buffer.</dsc>
    <code>#vC[10,@1,@2]</code>
    <cmt>Previous contents of the memory buffer are overwritten and the memory cursor is placed at the end.  This function returns the number of bytes in the buffer at completion.  This function supports conversion from a 24-bit captured image to 30-color HUB format.  This means it is no longer necessary to capture a special video image in 30 colors just for HUB conversion.
</cmt>
  </macro>
  <macro>
    <name>Video.dialog</name>
    <act>Y</act>
    <stx/>
    <dsc>Brings up a dialog box which allows the user to alter the image in the window.</dsc>
    <code>#vC[5]</code>
    <cmt>Brings up a dialog box which allows the user to alter the image in the capture window by changing contrast, brightness, etc.</cmt>
  </macro>
  <macro>
    <name>Video.display.pict</name>
    <act>Y</act>
    <stx>@Video.display.pict(objectHandle,row,column,height,width)</stx>
    <dsc>Displays a VideoObject in the specified region.</dsc>
    <code>#vC[6,@2,@3,@4,@5,@1]</code>
    <cmt>If the picture is smaller than the region, it is centered; if it is larger, than the region it is cropped.</cmt>
  </macro>
  <macro>
    <name>Video.pict.handle</name>
    <act>Y</act>
    <stx>@Video.picture.handle(UNCName)</stx>
    <dsc>Creates a VideoObject from the specified file.</dsc>
    <code>#vC[9,@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Video.preview.start</name>
    <act>Y</act>
    <stx/>
    <dsc>Un-freezes the picture.</dsc>
    <code>#vC[4]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Video.preview.stop</name>
    <act>Y</act>
    <stx/>
    <dsc>Freezes the picture. It does not capture the picture nor create a VideoObject.</dsc>
    <code>#vC[3]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Video.reset</name>
    <act>Y</act>
    <stx/>
    <dsc>Deletes all VideoObjects in the current window.</dsc>
    <code>#vC[8]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Video.save.pict</name>
    <act>Y</act>
    <stx>@Video.save.pict(objectHandle,compressionFactor,UNCName)</stx>
    <dsc>Saves the VideoObject to the specified file.</dsc>
    <code>#vC[7,@1,@2&quot;_IF{S[3] &quot;,@3&quot;}_&quot;]</code>
    <cmt>The file can be used by any of the picture functions (eg @Picture.make, @Button.make, ...).
[compressionFactor] allows saving of video images as JPG files, and compressing them for space savings.
</cmt>
  </macro>
  <macro>
    <name>W.ask.exit</name>
    <act>Y</act>
    <stx>@W.ask.exit(string)</stx>
    <dsc>Displays a dialog box with [string] and Yes and No buttons; the &apos;Yes&apos; has focus.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>Similar to @W.yes.no except that if the Skip Exit Prompts parameter in MIS is set to Y, the @W.ask.exit macro will skip asking the question and automatically return a value as if the question was asked and the user answered Y.</cmt>
  </macro>
  <macro>
    <name>W.ask.ok</name>
    <act>Y</act>
    <stx>@W.ask.ok(string)</stx>
    <dsc>Displays a dialog box with [string] and Yes and No buttons; the &apos;Yes&apos; has focus.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>Similar to @W.yes.no except that if the Skip File Prompts parameter in MIS is set to Y, the @W.ask.file macro will skip asking the question and automatically return a value as if the question was asked and the user answered Y.</cmt>
  </macro>
  <macro>
    <name>W.cancel.ok</name>
    <act>Y</act>
    <stx>@W.cancel.ok(string)</stx>
    <dsc>Displays a dialog box with [string] and Cancel and OK buttons.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>The Cancel button has the focus.  The dialog box title is &quot;Confirmation&quot; and the icon displayed is &quot;?&quot;. </cmt>
  </macro>
  <macro>
    <name>W.choice</name>
    <act>Y</act>
    <stx>@W.choice(choice.string,button.queue,text1,text2,...,text.n)</stx>
    <dsc>Displays a dialog box with text1,text2,...,text.n and button.queue buttons.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>[button.queue] is a queued list of button labels with hot letters preceded by &amp;. The first  button has the focus. The dialog box title is &quot;Choice&quot; and the icon displayed is &quot;?&quot;.  The appropriate letter from choice.string is returned.  The code produced is:

          (text1,text2,...,text.n)^@Z.win.text
          button.queue^@Z.win.msg.buttons,
          choice.string^@Z.win.choices,
          %(Z)w.macro(1,0,5)

Example:  @W.choice(&quot;OTHF&quot;,{&quot;&amp;One&quot;,&quot;&amp;Two&quot;,&quot;T&amp;hree&quot;,&quot;&amp;Four&quot;},&quot;This is the&quot;,&quot;question?&quot;)

          (&quot;This is the&quot;,&quot;question?&quot;)^/.WO,
          {&quot;&amp;One&quot;,&quot;&amp;Two&quot;,&quot;T&amp;hree&quot;,&quot;&amp;Four&quot;}^/.WO.BTN,
          &quot;OTHF&quot;^/.WC,
          %(Z)w.macro(1,0,5)
</cmt>
  </macro>
  <macro>
    <name>W.display</name>
    <act>Y</act>
    <stx>@W.display(arg1[,...,argn])</stx>
    <dsc>Displays a status message arg1[,...,argn].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>If a value exists in @Z.win.displayed (/.W), the message is displayed in the current dialog box; else a new one is opened and a value placed in @Z.win.displayed.
The dialog box title is &quot;Message&quot; and the icon displayed is &quot;i&quot;.

For details on the handling of arg1[,...,argn] refer to the procedure Z.w.macro.

</cmt>
  </macro>
  <macro>
    <name>W.display.cancel</name>
    <act>Y</act>
    <stx>@W.display.cancel(arg1[,...,argn])</stx>
    <dsc>Displays a status message arg1[,...,argn] with Cancel button.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>If a value exists in @Z.win.displayed (/.W), the message is displayed in the current dialog box; else a new one is opened and a value placed in @Z.win.displayed.
The dialog box title is &quot;Message&quot; and the icon displayed is &quot;i&quot;.

Will return 1 upon updating message if Cancel/X is clicked or if Enter/File/Escape key is pressed.

For details on the handling of arg1[,...,argn] refer to the procedure NPR.Z.UI.w.macro.
</cmt>
  </macro>
  <macro>
    <name>W.display.pos</name>
    <act>Y</act>
    <stx>@W.display.pos(row,column,arg3[,...,argn])</stx>
    <dsc>Displays a status message arg3[,...,argn].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>If a value exists in @Z.win.displayed (/.W), the message is displayed in the current dialog box; else a new one is opened at [row] and [column] and a value placed in @Z.win.displayed.
The dialog box title is &quot;Status&quot; and the icon displayed is &quot;i&quot;.

For details on the handling of arg1[,...,argn] refer to the procedure Z.w.macro.

</cmt>
  </macro>
  <macro>
    <name>W.err</name>
    <act>Y</act>
    <stx>@W.err(string)</stx>
    <dsc>Displays an error dialog box with [string] and a Close button.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>The dialog box title is &quot;Warning&quot; and the icon displayed is the &quot;X&quot; for error. The &quot;bell&quot; is also sounded.</cmt>
  </macro>
  <macro>
    <name>W.err.fld</name>
    <act>Y</act>
    <stx>@W.err.fld(string)</stx>
    <dsc>Displays a dialog box with [string] and an OK button and highlights input field.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>The current input field is highlighted and the dialog box is opened below it.  The dialog box title is &quot;Warning&quot; and the icon displayed is the &quot;!&quot; for error.  The &quot;bell&quot; is also sounded.
</cmt>
  </macro>
  <macro>
    <name>W.no.yes</name>
    <act>Y</act>
    <stx>@W.no.yes(string)</stx>
    <dsc>Displays a dialog box with [string] and Yes and No buttons; the &apos;No&apos; has focus.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>The dialog box title is &quot;Confirmation&quot; and the icon displayed is &quot;?&quot;.
</cmt>
  </macro>
  <macro>
    <name>W.no.yes.fld</name>
    <act>Y</act>
    <stx>@W.no.yes.fld(string)</stx>
    <dsc>Displays a dialog box with string and Yes and No buttons and highlight input fld</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>The current input field is highlighted and the dialog box is opened below it.  The No button has the focus.  The dialog box title is &quot;Confirmation&quot; and the icon displayed is &quot;?&quot;.
</cmt>
  </macro>
  <macro>
    <name>W.ok.cancel</name>
    <act>Y</act>
    <stx>@W.ok.cancel(string)</stx>
    <dsc>Displays a dialog box with [string] and OK and Cancel buttons.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>The OK button has the focus.  The dialog box title is &quot;Confirmation&quot; and the icon displayed is &quot;?&quot;. </cmt>
  </macro>
  <macro>
    <name>W.progress</name>
    <act>Y</act>
    <stx>@W.progress(text,total#,current#)</stx>
    <dsc>Displays a dialog box below the current window with [tex]t over a progress bar.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>[current#] indicates the current progress out of [total#] possible.
The dialog box title is &quot;Message&quot; and the icon displayed is &quot;i&quot;.

If a value exists in @Z.win.displayed (/.W), the information is displayed in the current dialog box; else a new one is opened and a value placed in @Z.win.displayed.
</cmt>
  </macro>
  <macro>
    <name>W.progress.cancel</name>
    <act>Y</act>
    <stx>@W.progress.cancel(text,total#,current#)</stx>
    <dsc>Displays a dialog box with [text] over a progress bar and Cancel button.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>[current#] indicates the current progress out of [total#] possible.
The dialog box title is &quot;Message&quot; and the icon displayed is &quot;i&quot;.

Will return 1 upon updating message if Cancel/X is clicked or if Enter/File/Escape key is pressed.

If a value exists in @Z.win.displayed (/.W), the information is displayed in the current dialog box; else a new one is opened and a value placed in @Z.win.displayed.

For details on the handling of arg1[,...,argn] refer to the procedure NPR.Z.UI.w.macro.</cmt>
  </macro>
  <macro>
    <name>W.return</name>
    <act>Y</act>
    <stx>@W.return(arg1[,...,argn])</stx>
    <dsc>Displays a message arg1[,...,argn] in a dialog box with an OK button.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>The dialog box title is &quot;Message&quot; and the icon displayed is the &quot;i&quot; for informational.</cmt>
  </macro>
  <macro>
    <name>W.warning</name>
    <act>Y</act>
    <stx>@W.warning(string)</stx>
    <dsc>Displays a warning dialog box with [string] and a Close button.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>The dialog box title is &quot;Warning&quot; and the icon displayed is the &quot;!&quot; for warning.
The &quot;bell&quot; is also sounded.</cmt>
  </macro>
  <macro>
    <name>W.warning.no.yes</name>
    <act>Y</act>
    <stx>@W.warning.no.yes(string)</stx>
    <dsc>Displays a warning dialog box with [string] and Yes/No buttons; &apos;No&apos; has focus.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>The dialog box title is &quot;Warning&quot; and the icon displayed is the &quot;!&quot; for warning.
The &quot;bell&quot; is also sounded.</cmt>
  </macro>
  <macro>
    <name>W.warning.yes.no</name>
    <act>Y</act>
    <stx>@W.warning.yes.no(string)</stx>
    <dsc>Displays a warning dialog box with [string] and Yes/No buttons; &apos;Yes&apos; has focus.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>The dialog box title is &quot;Warning&quot; and the icon displayed is the &quot;!&quot; for warning.
The &quot;bell&quot; is also sounded.
</cmt>
  </macro>
  <macro>
    <name>W.yes.no</name>
    <act>Y</act>
    <stx>@W.yes.no(string)</stx>
    <dsc>Displays a dialog box with [string] and Yes and No buttons; the &apos;Yes&apos; has focus.</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>The dialog box title is &quot;Confirmation&quot; and the icon displayed is &quot;?&quot;.
</cmt>
  </macro>
  <macro>
    <name>W.yes.no.fld</name>
    <act>Y</act>
    <stx/>
    <dsc>Displays a dialog box with string and Yes and No buttons and highlight input fld</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..messages(^S)_&quot;</code>
    <cmt>The current input field is highlighted and the dialog box is opened below it.  The Yes button has the focus.  The dialog box title is &quot;Confirmation&quot; and the icon displayed is &quot;?&quot;.
</cmt>
  </macro>
  <macro>
    <name>Web.link</name>
    <act>Y</act>
    <stx>@Web.link(target.page,source.page)</stx>
    <dsc>Return relative link to [target.page] from [source.page]</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..web(^S)_&quot;</code>
    <cmt/>
  </macro>
  <macro>
    <name>Web.path</name>
    <act>Y</act>
    <stx>@Web.path(web.page)</stx>
    <dsc>Macro to return path to NPR.WEB.[web.page]</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..web(^S)_&quot;</code>
    <cmt/>
  </macro>
  <macro>
    <name>Width</name>
    <act>Y</act>
    <stx>@Width(element,screen.or.*)</stx>
    <dsc>Returns the width of [element] in the specified [screen].</dsc>
    <code>&quot;_%(NPR)MACRO..translate.M..screen(^S)_&quot;</code>
    <cmt>For [screen] associated with the current procedure, use (*).

Similar to @Column.
</cmt>
  </macro>
  <macro>
    <name>Window</name>
    <act>Y</act>
    <stx>@Window(row,column,height,width,window.type,title)^#</stx>
    <dsc>Opens window of [window.type] at [row],[column] of [height],[width] and [title]</dsc>
    <code>D(23,2,@1,@2,@3,@4,@5)_{&quot;_IF{S[6];D(34)_&quot;UNTITLED&quot;_D(34)}_&quot;}</code>
    <cmt>This is a &quot;child&quot; type window.  It is displayed over any underlying windows.

[window.type] is defined in the Z data definition as follows:
   @Z.window.primary  = 0
   @Z.window.fragment  = 3
   @Z.window.menu  = 4
   @Z.window.message = 8
   @Z.window.lookup  = 13
</cmt>
  </macro>
  <macro>
    <name>Window.below</name>
    <act>Y</act>
    <stx>@Window.below(height,width,window.type,title)^#</stx>
    <dsc>Opens window of [window.type] of [height],[width] and [title] below current win.</dsc>
    <code>D(23,3,@1,@2,@3)_{&quot;_IF{S[4];D(34)_&quot;UNTITLED&quot;_D(34)}_&quot;}</code>
    <cmt>This is a &quot;child&quot; type window.  It is displayed over any underlying windows.

[window.type] is defined in the Z data definition as follows:
  @Z.window.primary  = 0
  @Z.window.fragment  = 3
  @Z.window.menu  = 4
  @Z.window.message = 8
  @Z.window.lookup  = 13
</cmt>
  </macro>
  <macro>
    <name>Window.blank</name>
    <act>Y</act>
    <stx>@Window.blank^#</stx>
    <dsc>Blanks windows</dsc>
    <code>D(23,8)</code>
    <cmt>Blanks windows by creating a 1x1 pixel window.

Use Window.unblank or Window.close to remove.
</cmt>
  </macro>
  <macro>
    <name>Window.centered</name>
    <act>Y</act>
    <stx>@Window.centered(height,width,window.type,title)^#</stx>
    <dsc>Opens window of [window.type] of [height],[width] and [title] centered over win.</dsc>
    <code>D(23,6,@1,@2,@3)_{&quot;_IF{S[4];D(34)_&quot;UNTITLED&quot;_D(34)}_&quot;}</code>
    <cmt>This is a &quot;child&quot; type window.  It is displayed over any underlying windows.

[window.type] is defined in the Z data definition as follows:
  @Z.window.primary  = 0
  @Z.window.fragment  = 3
  @Z.window.menu  = 4
  @Z.window.message = 8
  @Z.window.lookup  = 13 </cmt>
  </macro>
  <macro>
    <name>Window.child</name>
    <act>Y</act>
    <stx>@Window.child(row,column,height,width,window.type,title)^#</stx>
    <dsc>Opens window of [window.type] at [row],[column] of [height],[width] and [title]</dsc>
    <code>D(23,2,@1,@2,@3,@4,@5)_{&quot;_IF{S[6];D(34)_&quot;UNTITLED&quot;_D(34)}_&quot;}</code>
    <cmt>Identical to @Window.

This is a &quot;child&quot; type window.  It is displayed over any underlying windows.

[window.type] is defined in the Z data definition as follows:
  @Z.window.primary  = 0
  @Z.window.fragment  = 3
  @Z.window.menu  = 4
  @Z.window.message = 8
  @Z.window.lookup  = 13 </cmt>
  </macro>
  <macro>
    <name>Window.close</name>
    <act>Y</act>
    <stx>@Window.close(&quot;&quot;)^#</stx>
    <dsc>Closes the current window.</dsc>
    <code>D(23,0)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Window.field</name>
    <act>Y</act>
    <stx>@Window.field(height,width,window.type,title)^#</stx>
    <dsc>Opens window of [window.type] of [height],[width] and [title] near current field</dsc>
    <code>D(23,7,@1,@2,@3)_{&quot;_IF{S[4];D(34)_&quot;UNTITLED&quot;_D(34)}_&quot;}</code>
    <cmt>This is a &quot;child&quot; type window.  It is displayed over any underlying windows.

[window.type] is defined in the Z data definition as follows:
  @Z.window.primary  = 0
  @Z.window.fragment  = 3
  @Z.window.menu  = 4
  @Z.window.message = 8
  @Z.window.lookup  = 13 </cmt>
  </macro>
  <macro>
    <name>Window.handle</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the handle of the frame window (hWnd) for @Message.send</dsc>
    <code>#W</code>
    <cmt>This handle never changes for the duration of a Magic session.</cmt>
  </macro>
  <macro>
    <name>Window.horiz.line</name>
    <act>Y</act>
    <stx>@Window.horiz.line(row)^#</stx>
    <dsc>Draws a horizontal line from window border to border at [row].</dsc>
    <code>D(16,@1,0,4,0)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Window.horiz.line.cur.pos</name>
    <act>Y</act>
    <stx>@Window.horiz.line.cur.pos(&quot;&quot;)^#</stx>
    <dsc>Draws a horizontal line from window border to border at current cursor row.</dsc>
    <code>D(4,0)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Window.lock.for.update</name>
    <act>Y</act>
    <stx/>
    <dsc>Tells Windows not to update the window with any changes.</dsc>
    <code>#W[1]</code>
    <cmt>All changes to the window display are &quot;remembered&quot; but not executed by Windows.  Once &quot;unlocked&quot; (see @Window.unlock.for.update), all appear to the user to be done simultaneously.
</cmt>
  </macro>
  <macro>
    <name>Window.parent</name>
    <act>Y</act>
    <stx>@Window.parent(height,width,window.type,title)^#</stx>
    <dsc>Opens window of [window.type] of [height],[width] and [title]</dsc>
    <code>D(23,4,@1,@2,@3)_{&quot;_IF{S[4];D(34)_&quot;UNTITLED&quot;_D(34)}_&quot;}</code>
    <cmt>This is a &quot;parent&quot; type window.  Any underlying windows except for the MagicCS window are blanked and will not be visible.  This type of window is used primarily by the screen translator and the menu driver program.

[window.type] is defined in the Z data definition as follows:
  @Z.window.primary  = 0
  @Z.window.fragment  = 3
  @Z.window.menu  = 4
  @Z.window.message = 8
  @Z.window.lookup  = 13
</cmt>
  </macro>
  <macro>
    <name>Window.relative</name>
    <act>Y</act>
    <stx>@Window.relative(row,column,height,width,window.type,title)^#</stx>
    <dsc>Opens window of [window.type] at [row],[column] relative to current window</dsc>
    <code>D(23,5,@1,@2,@3,@4,@5)_{&quot;_IF{S[6];D(34)_&quot;UNTITLED&quot;_D(34)}_&quot;}</code>
    <cmt>Opens a window of [window.type] whose top lefthand corner is at [row] and [column] relative to the current window of [height] and [width] with window [title].

This is a &quot;child&quot; type window.  It is displayed over any underlying windows.

[window.type] is defined in the Z data definition as follows:
  @Z.window.primary  = 0
  @Z.window.fragment  = 3
  @Z.window.menu  = 4
  @Z.window.message = 8
  @Z.window.lookup  = 13 </cmt>
  </macro>
  <macro>
    <name>Window.reset</name>
    <act>Y</act>
    <stx>@Window.reset(&quot;&quot;)^#</stx>
    <dsc>Close all open windows except the MagicCS window and reinitializes all values.</dsc>
    <code>D(23,1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Window.show</name>
    <act>Y</act>
    <stx>@Window.show(windowShow)</stx>
    <dsc>Display the MagicCS window according to [windowShow].</dsc>
    <code>#w[@1]</code>
    <cmt>[windowShow]
The value of this argument is passed directly to Windows as the the ShowWindow state:

  1=Normal
  2=Minimize
  3=Maximize
  4=Normal but not active
  5=(don&apos;t use)
  6=Minimize
  7=Minimize but do not activate
  8=Show but do not activate
  9=Restore
</cmt>
  </macro>
  <macro>
    <name>Window.unblank</name>
    <act>Y</act>
    <stx>@Window.unblank^#</stx>
    <dsc>Unblanks windows</dsc>
    <code>D(23,0)</code>
    <cmt>&quot;Unblanks&quot; windows by closing the 1x1 pixel window created by @Window.blank.  This function is the same as @Window.close.
</cmt>
  </macro>
  <macro>
    <name>Window.unlock.for.update</name>
    <act>Y</act>
    <stx/>
    <dsc>Tells Windows to update window w/all changes made since @Window.lock.for.update.</dsc>
    <code>#W[0]</code>
    <cmt>All changes to the window display which have been &quot;remembered&quot; are executed by Windows.  Once &quot;unlocked&quot;, all appear to the user to be done simultaneously.</cmt>
  </macro>
  <macro>
    <name>Window.vert.line</name>
    <act>Y</act>
    <stx>@Window.vert.line(column)^#</stx>
    <dsc>Draws a vertical line from window border to border at [column].</dsc>
    <code>D(16,0,@1,4,1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Window.vert.line.cur.pos</name>
    <act>Y</act>
    <stx>@Window.vert.line.cur.pos(&quot;&quot;)^#</stx>
    <dsc>Draws a vertical line from window border to border at current cursor column.</dsc>
    <code>D(4,1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>Windows.directory</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the Windows directory, generally, C:\WINDOWS.</dsc>
    <code>@DW</code>
    <cmt/>
  </macro>
  <macro>
    <name>Windows.printers</name>
    <act>Y</act>
    <stx>@Windows.printers(memoryHandle)</stx>
    <dsc>Returns count of the printers installed under Windows.</dsc>
    <code>#PE[@1&quot;_IF{S[2] &quot;,@2&quot;}_&quot;]</code>
    <cmt>Provides information for all printers set up using Settings/Printers/Add Printers for this client.  Fills memory buffer with pairs as follows: printer.name &lt;CRLF&gt; port &lt;CRLF&gt; printer.name &lt;CRLF&gt; port &lt;CRLF&gt;

For example, AMOS &lt;CRLF&gt; \\EXODUS\AMOS &lt;CRLF&gt; MYHPLASER &lt;CRLF&gt; LPT1: &lt;CRLF&gt;.
</cmt>
  </macro>
  <macro>
    <name>Windows.program.files</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the path to the Windows Program Files folder</dsc>
    <code>#D[4]</code>
    <cmt>Returns the path to the Windows Program Files folder (e.g. &quot;C:\Program Files&quot;).</cmt>
  </macro>
  <macro>
    <name>Windows.temp</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns the designated Windows TEMP directory.</dsc>
    <code>@DT</code>
    <cmt>NOTE:  The path returned will end in a \ character, while other functions @System.directory and @Windows.directory do not.</cmt>
  </macro>
  <macro>
    <name>Windows.version</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns &quot;95&quot;, &quot;98&quot; or &quot;NT&quot;, indicating the currently running operating system.</dsc>
    <code>#VW&quot;_IF{S[1] &quot;[1]&quot;}_&quot;</code>
    <cmt>@Windows.version(1) - #VW[1]

Will return a queued string consisting of:
platform,major version,minor version,build,additional information

The additional information may include the service pack that is running.</cmt>
  </macro>
  <macro>
    <name>Word.ole.add.template</name>
    <act>Y</act>
    <stx>@Word.ole.add.template(template)</stx>
    <dsc>Execute Word Basic&apos;s AddAddIn statement which loads the [template] specified.</dsc>
    <code>#OW[4,@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Word.ole.clear.global.atom</name>
    <act>Y</act>
    <stx/>
    <dsc>If global atom is not set, returns 0; otherwise clears global atom &amp; returns 1.</dsc>
    <code>#OW[8]</code>
    <cmt>VMAGIC.DLL uses a &quot;global atom&quot; to be sure that only one job is using the DLL.  If the global atom is not set, this function returns 0.  If it is set, this function clears it and returns a 1.</cmt>
  </macro>
  <macro>
    <name>Word.ole.delete.job</name>
    <act>Y</act>
    <stx/>
    <dsc>Deletes the current MSWord job and clears the global atom</dsc>
    <code>#OW[11]</code>
    <cmt>Deletes the current MSWord job and clears the global atom (DLL lock) without doing a graceful release, request, warning, or message to WINWORD.EXE.  Useful if MSWord is unresponsive.
</cmt>
  </macro>
  <macro>
    <name>Word.ole.hide</name>
    <act>Y</act>
    <stx>@Word.ole.hide(applicationName)</stx>
    <dsc>Hide application.</dsc>
    <code>#OW[3,@1]</code>
    <cmt>[applicationName] may be nil to indicate Winword.</cmt>
  </macro>
  <macro>
    <name>Word.ole.load</name>
    <act>Y</act>
    <stx/>
    <dsc>Load Meditech OLE DLL (VMAGIC.DLL) and start MS Word if necessary.</dsc>
    <code>#OW[0]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Word.ole.lock</name>
    <act>Y</act>
    <stx>@Word.ole.lock(&quot;&quot;)</stx>
    <dsc>Checks for the existence of an MSWord Lock (global atom).</dsc>
    <code>#OW[10]</code>
    <cmt>Returns:  bit flag where

    0 - MSWord/MagicCS interface is not running

Else

    Bit 1 - interface is in use
    Bit 2 - MagicCS is sleeping and waiting for MSWord
    Bit 4 - MSWord is sleeping and waiting for MagicCS

Typically, we just check for &apos;=0 case.
</cmt>
  </macro>
  <macro>
    <name>Word.ole.poke</name>
    <act>Y</act>
    <stx>@Word.ole.poke(memoryHandle)</stx>
    <dsc>Poke data to Word.  The data must be in the [memoryHandle].</dsc>
    <code>#OW[7,@1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Word.ole.release</name>
    <act>Y</act>
    <stx/>
    <dsc>Release Meditech OLE DLL and terminate MSWord.</dsc>
    <code>#OW[1]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Word.ole.run.macro</name>
    <act>Y</act>
    <stx>@Word.ole.run.macro(macroName)</stx>
    <dsc>Execute MSWord macro [macroName].</dsc>
    <code>#OW[5,@1]</code>
    <cmt>Execute Word Basic&apos;s OnTime statement.  The time is hard-coded as &quot;00:00:00&quot; and the tolerance is set to &quot;&quot;, so that the Word macro [macroName] will be always executed as soon as Word is free to do so.  MagicCS will be active as soon as the #OW[] completes; it doesn&apos;t wait for [macroName] to finish.</cmt>
  </macro>
  <macro>
    <name>Word.ole.show</name>
    <act>Y</act>
    <stx>@Word.ole.show(applicationName)</stx>
    <dsc>Show application [applicationName].</dsc>
    <code>#OW[2,@1]</code>
    <cmt>If nil, indicates Winword.</cmt>
  </macro>
  <macro>
    <name>Word.ole.version</name>
    <act>Y</act>
    <stx/>
    <dsc>Returns MS Word version number.</dsc>
    <code>#OW[9,2]</code>
    <cmt/>
  </macro>
  <macro>
    <name>Word.ole.wait</name>
    <act>Y</act>
    <stx>@Word.ole.wait(memoryHandle)</stx>
    <dsc>Makes MagicCS wait for a response from MS Word.</dsc>
    <code>#OW[6,@1]</code>
    <cmt>The &quot;topic&quot; will be returned to MagicCS by the command, and the &quot;data&quot; for that topic will be in the memory buffer specified by [memoryHandle].

Example:
DO{#OW[6,MEM]^TOPIC IF{TOPIC=&quot;XYZ&quot; @READ.DATA.FROM.MEMORY.BUFFER.MEM,
                                   @WRITE.RESPONSE.TO.MEMORY.BUFFER.MEM;

Re-entering the #OW[6,...] will return the contents of the memory buffer to Word and wake it up if it is waiting.

Functionality added in DTS NPR #351:

1)  If the first byte of the buffer passed in is &gt; D(127), assume that that byte MOD 127 is      the number of minutes, after which we time-out.  So, if the first byte is D(129), the        time out is 2 minutes.

2)  If the first byte is &gt; D(127), do not pass it to Word, but pass everything else in the       buffer to Word as we usually do.  If the first byte in the buffer is &lt; D(128), then pass     it and everything else in the buffer to Word.

3)  If this function times out, return the string TIMED OUT as the &quot;topic&quot; (not in the           buffer): IF{@Word.ole.wait(memoryHandle)=&quot;TIMED OUT&quot; ....}

</cmt>
  </macro>
  <macro>
    <name>Workspace.close</name>
    <act>Y</act>
    <stx/>
    <dsc>Close a owner draw window</dsc>
    <code>#wC</code>
    <cmt>Closes owner draw window opened by Workspace.open.
</cmt>
  </macro>
  <macro>
    <name>Workspace.open</name>
    <act>Y</act>
    <stx>@Workspace.open(row,col,height,width)</stx>
    <dsc>Creates a owner draw window and returns window handle</dsc>
    <code>#wO[@1,@2,@3,@4]</code>
    <cmt>Creates an owner draw window space on the client area, a window with no visible border.  Returns a window handle.</cmt>
  </macro>
  <macro>
    <name>Write.page</name>
    <act>Y</act>
    <stx>@Write.page(&quot;&quot;)^#</stx>
    <dsc>Writes the current page of a multi-page screen to memory.</dsc>
    <code>D(22,1)</code>
    <cmt>See also @Init.page and @Read.page.</cmt>
  </macro>
  <macro>
    <name>ZMove</name>
    <act>Y</act>
    <stx>@ZMove(source,target)</stx>
    <dsc>Performs @Move function using %Z.move utility.</dsc>
    <code>%(Z)move(^@1,^@2,1)</code>
    <cmt/>
  </macro>
  <macro>
    <name>ZReplace</name>
    <act>Y</act>
    <stx>@ZReplace(source,target)</stx>
    <dsc>Performs @Replace function using %Z.move utility.</dsc>
    <code>%(Z)move(^@1,^@2,2)</code>
    <cmt/>
  </macro>
  <macro>
    <name>_</name>
    <act>Y</act>
    <stx/>
    <dsc>Here only so @_ can appear in code if necessary.</dsc>
    <code>@_</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @ML function.</dsc>
    <code>@ML</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.AS</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @AS function.</dsc>
    <code>@AS</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.AT</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @AT function.</dsc>
    <code>@AT</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.BD</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @BD Function</dsc>
    <code>@BD</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.Bs</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic Lite @Bs function</dsc>
    <code>@Bs</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.CL</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Command.line</dsc>
    <code>@CL</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.CX</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @CX function.</dsc>
    <code>@CX</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.DL</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @DL function.</dsc>
    <code>@DL</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.FS</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @FS function.</dsc>
    <code>@FS</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.FT</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @FT function.</dsc>
    <code>@FT</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.GA</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Global.alloc</dsc>
    <code>@GA</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.GD</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @GD function.</dsc>
    <code>@GD</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.GF</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Global.free</dsc>
    <code>@GF</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.Gr</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Global.alloc.read.raw.</dsc>
    <code>@Gr</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.Gw</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Global.alloc.write.raw.</dsc>
    <code>@Gw</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.IL</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @IL function.</dsc>
    <code>@IL</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.Il</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @Il function.</dsc>
    <code>@Il</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.It</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @It function.</dsc>
    <code>@It</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.NF</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Net.from.</dsc>
    <code>@NF</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.NN</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @.machine.int</dsc>
    <code>@NN</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.NT</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Net.to.</dsc>
    <code>@NT</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.Na</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Net.accept.tcp.</dsc>
    <code>@Na</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.Nc</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Net.close.tcp.</dsc>
    <code>@Nc</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.Ni</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @.machine.ip.</dsc>
    <code>@Ni</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.Nl</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Net.get.listen.socket.</dsc>
    <code>@Nl</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.No</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Net.open.tcp.</dsc>
    <code>@No</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.Nr</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Net.read.tcp.</dsc>
    <code>@Nr</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.Nt</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Net.handle.tcp.</dsc>
    <code>@Nt</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.Nw</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Net.write.tcp.</dsc>
    <code>@Nw</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.Nx</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Net.synch.tcp.</dsc>
    <code>@Nx</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.OX</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @OX function.</dsc>
    <code>@OX</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.PH</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @PH function.</dsc>
    <code>@PH</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.RT</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @RT function.</dsc>
    <code>@RT</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.SA</name>
    <act>Y</act>
    <stx/>
    <dsc>Same as @Server.allocate.</dsc>
    <code>@SA</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.UT</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @UT function.</dsc>
    <code>@UT</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.WC</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @WC function.</dsc>
    <code>@WC</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.XV</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @XV function.</dsc>
    <code>@XV</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.XZ</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @XZ function.</dsc>
    <code>@XZ</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.YT</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @YT function.</dsc>
    <code>@YT</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.Zd</name>
    <act>Y</act>
    <stx/>
    <dsc>Magic-Lite @Zd function.</dsc>
    <code>@Zd</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.pM</name>
    <act>Y</act>
    <stx/>
    <dsc>Direct access to #pM (@Picture.make)</dsc>
    <code>#pM</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.pP</name>
    <act>Y</act>
    <stx/>
    <dsc>Direct access to #pP (@Picture.make.palette)</dsc>
    <code>#pP</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.pS</name>
    <act>Y</act>
    <stx/>
    <dsc>Direct access to #pS (@Picture.select)</dsc>
    <code>#pS</code>
    <cmt/>
  </macro>
  <macro>
    <name>ml.pX</name>
    <act>Y</act>
    <stx/>
    <dsc>Direct access to #pX (@Picture.delete)</dsc>
    <code>#pX</code>
    <cmt/>
  </macro>
</macrodb>
