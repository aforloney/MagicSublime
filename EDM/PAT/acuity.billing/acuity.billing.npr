;// $Header: https://vcfs01.meditech.com/svn/CS-NPR/5.6.6/Source/EDM/PAT/acuity.billing/acuity.billing.npr 2633 2013-04-20 21:35:53Z acontardo $
;//:Doc Features Affected
;//     Integrations {Billing}
;//:Doc Purpose
;//     This program calculates a patients acuity and then enters the appropriate Care
;//     Level charge.
;//:Doc Arguments
;//     A  - urn (aa)
;//:Doc Local Variables
;//     ACU - acuity for each documentation of an intervention
;//     CRU - Credit user
;//     REV - revenue site
;//     SDT - service date
;//     STM - service time
;//     TTL - patient's total acuity
;
@INIT,
IF{@TRANSFER.PATIENT;
   @CALCULATE.PATIENT.ACUITY,
   @NO.CHANGE.IN.ACUITY;
   @BEFORE.IMAGE.FOR.REPOSITORY,
   @FILE.ACUITY.AND.CARE.LEVEL.CHARGE,
   1^@edit.x,
   @AFTER.IMAGE.FOR.REPOSITORY},
END;

INIT
A^urn,""^A

TRANSFER.PATIENT
"Y"=@xfer.patient

CALCULATE.PATIENT.ACUITY
0.0^TTL,
DO{@Next(@ta.intervention) @EDM.ASSESSMENT.acuity^ACU,
                           ; ignore any interventions that do not have an acuity defined.
                           ; the initial acuity can be zero, as it is required in order to
                           ; define additional acuity. (see also, macro ONLY.COUNT.ONE.DOC)
                           IF{ACU @ADD.ACUITY.FOR.A.SINGLE.INTERVENTION}}

ADD.ACUITY.FOR.A.SINGLE.INTERVENTION
; ignore all documentations which ended up being undone
@Est.t.rec(HE,@edm.data.intervention),
@EDM.ASSESSMENT.acuity.max^MAX,
0.0^I.TTL,
DO{@Next(@ta.ctr) IF{@DOC.WAS.UNDONE;
                     ; we now look back at the last edit to get query acuity
                     @Prev(ta.ctr)^ta.ctr,
                     @ADD.TO.ACUITY,
                     @CHECK.FOR.QUERY.ACUITY,
                     @ONLY.COUNT.ONE.DOC @EXIT.SINGLE.INTERVENTION.LOOP};
   @Next(@ta.time);
   @Next(@ta.date)},
@Clr.t.rec(HE)

DOC.WAS.UNDONE
(@ta.ctr#0.)_.99^@ta.ctr,
;
; notice that the ctr is changed above regardless of whether or not an undo
; node exists. this way, the loop will not have to go through subsequent edits or undos.
; The check for the node below will determine if the documentation was undone.
;
@edm.data.intervention.doc

;-------------------------------------------------------------------------------------------

CHECK.FOR.QUERY.ACUITY
@Kill(MULT),
@FILE.TIME.QTY.BASED.BILL.TXNS,
@FILE.QUERY.BASED.BILL.TXNS,
(@ta.ctr#0.)_.99^@ta.ctr

#FILE.TIME.QTY.BASED.BILL.TXNS
; Elapsed Time/Quantity queries must be scalar
@Def.buf(TC,@EDM.ASSESSMENT.billing.timed.charges),
DO{@Next.get(@EDM.ASSESSMENT.bl.tc.q,TC) @EDM.ASSESSMENT.bl.tc.query^MIS.QUERY.mnemonic,
                                         IF{@EDM.ASSESSMENT.bl.tc.qty.or.et#0="E" @GET.ELAPSED.TIMES;
                                            @GET.QUANTITIES},
                                         @CHARGE.FOR.EACH.RESPONSE},
@Clr.buf(TC)^MIS.QUERY.mnemonic;

GET.ELAPSED.TIMES
; Elapsed Time is HHMM - convert to minutes
@GET.ALL.QUERY.RESPONSES,
DO{+(MULT[INDX],V)^INDX V$2*60+(V%1)^MULT[INDX]}

GET.QUANTITIES
@GET.ALL.QUERY.RESPONSES

#GET.ALL.QUERY.RESPONSES
; This assumes the query mnemonic (ggv) exists
""^ta.sub.assmnt,
DO{@Next(ta.sub.assmnt) ""^ta.repeat.ctr,
                        DO{@Next(ta.repeat.ctr) @VALUE}},
""^INDX^V;

#VALUE
IF{@ta.rep.value^V V^MULT[INDX+1^INDX]};

CHARGE.FOR.EACH.RESPONSE
DO{+(MULT[INDX],V)^INDX @INITIAL.BLOCK,
                        @ADDITIONAL.BLOCKS},
K(MULT)

INITIAL.BLOCK
IF{@Not(V);
   V'>0;
   @Not(@EDM.ASSESSMENT.bl.tc.iblk);
   V-@EDM.ASSESSMENT.bl.tc.iblk^V,
   @EDM.ASSESSMENT.bl.tc.iblk.acuity^ACU,
   ACU @ADD.TO.ACUITY}

ADDITIONAL.BLOCKS
IF{@Not(V);
   V'>0;
   @Not(@EDM.ASSESSMENT.bl.tc.ablk);
   V^@ADDL.BLOCK,
   ""^QTY,DO{@Add(1,QTY),V-@EDM.ASSESSMENT.bl.tc.ablk^V>0},""^V,
   @EDM.ASSESSMENT.bl.tc.ablk.acuity^ACU,
   ACU QTY*ACU^ACU,
       @ADD.TO.ACUITY}

ADDL.BLOCK
AB

#FILE.QUERY.BASED.BILL.TXNS
""^EDM.ASSESSMENT.bl.rbc.query,
IF{@First(@EDM.ASSESSMENT.bl.rbc.query) @GET.KEYS.FOR.THIS.ASSMNT},
""^EDM.ASSESSMENT.bl.rbc.query,
DO{@Next(@EDM.ASSESSMENT.bl.rbc.query) @CHECK.QUERY.RESPONSES},
@CLEANUP.KEYS;

GET.KEYS.FOR.THIS.ASSMNT
; We first need to know which queries on the assessment are keyed queries.
@Kill(/KEYED.QUERY),
@EDM.ASSESSMENT.mis.assmnt^MIS.ASSMNT.code,
IF{"Y"=@MIS.ASSMNT.group MIS.ASSMNT.code^ASSMNT.SV,""^MIS.ASSMNT.group.assessment.q,
                         DO{@Next(@MIS.ASSMNT.group.assessment.q) @MIS.ASSMNT.group.assessment^MIS.ASSMNT.code,
                                                                  @GET.KEYS,
                                                                  ASSMNT.SV^MIS.ASSMNT.code},
                         ""^ASSMNT.SV;
   @GET.KEYS}

GET.KEYS
@Est.t.rec(MS,@Root(@MIS.ASSMNT.labels)),
""^MIS.ASSMNT.query.code^MIS.ASSMNT.label.q,
DO{@Next(@MIS.ASSMNT.query.q) IF{@MIS.ASSMNT.query.code^MIS.QUERY.mnemonic,
                                 "Y"'=@MIS.ASSMNT.query.repeatable.key;
                                 1^/KEYED.QUERY[MIS.ASSMNT.code,MIS.ASSMNT.label.q,MIS.QUERY.mnemonic]};
   @Next(@MIS.ASSMNT.label.q)},
@Clr.t.rec(MS)

CHECK.QUERY.RESPONSES
""^ta.sub.assmnt,
DO{@Next(ta.sub.assmnt) ""^ta.repeat.ctr,
                        DO{@Next(@ta.repeat.ctr) IF{@NON.KEY.QUERY.RESPONSES_.=.;
                                                    @QUERY.VALUE}}}

#NON.KEY.QUERY.RESPONSES
; If the only query responses for this label are keyed queries that pulled forward from a
; previous documentation we will not file charges. If no other responses exist but this is
; a new occurrence of the repeatable label, file it.
EDM.ASSESSMENT.bl.rbc.query^SV.QRY,
""^ta.rep.query^QRY.RESP,
DO{@Next(@ta.rep.query)&@Not(QRY.RESP) IF{/KEYED.QUERY[ta.sub.assmnt,ta.repeat.ctr#0.,ta.rep.query]_.=.;
                                          ta.repeat.ctr#0.^rpt.ins.lab,ta.repeat.ctr#1.^rpt.ins.occ,
                                          @edm.data.ins.rpt.keys;
                                          @First(rpt.ins.resp)}^QRY.RESP},
SV.QRY^EDM.ASSESSMENT.bl.rbc.query,""^SV.QRY,
QRY.RESP;

#QUERY.VALUE
IF{@ta.rep.value^VAL @MAYBE.FILE.RESPONSE.ACUITY;
   DO{@Next(ta.rep.res.no) IF{@ta.rep.value.mult^VAL @MAYBE.FILE.RESPONSE.ACUITY}}};

MAYBE.FILE.RESPONSE.ACUITY
IF{@EDM.ASSESSMENT.bl.rbc.acuity[VAL]^ACU @ADD.TO.ACUITY}

#ADD.TO.ACUITY
IF{MAX IF{I.TTL+0=(MAX+0) ALREADY.AT.MAX.FOR.INTERVENTION;
          I.TTL+ACU>MAX ONLY.ADD.DIFFERENCE.BETWEEN.MAX.AND.PRIOR.INTERVENTION.TOTAL,
                        TTL+(MAX-I.TTL)^TTL,
                        MAX^I.TTL;
          ACU+I.TTL^I.TTL,
          ACU+TTL^TTL};
   ACU+TTL^TTL};

CLEANUP.KEYS
@Kill(/KEYED.QUERY)

;-------------------------------------------------------------------------------------------

ONLY.COUNT.ONE.DOC
; if it exists, use the additional doc acuity the rest of the way for this int,
; if it does not exist or = 0, then return true and skip out of loop.
0.00>(@EDM.ASSESSMENT.acuity.addl.doc^ACU)

EXIT.SINGLE.INTERVENTION.LOOP
99999999^ta.date^ta.time^ta.ctr

NO.CHANGE.IN.ACUITY
TTL_.=(@acuity_.)

FILE.ACUITY.AND.CARE.LEVEL.CHARGE
%Z.date.add(@.today,"-1")^@ACTIVITY.DATE,
TTL^@acuity,
@FIND.HIGHEST.LEVEL.ALLOWED,
@EXISTING.CARE.LEVEL^ECL,
IF{ECL=bill.txn.care.level;
   IF{ECL @CREDIT.EXISTING.CARE.LEVEL},
   ; bill.txn.care.level may have been nilled out if the existing care care level
   ; could not be credited properly. (or it may have never been setup if there was not
   ; a level defined for the patient's acuity)
   IF{bill.txn.care.level @FILE.CARE.LEVEL.CHARGE}},
""^ECL

FIND.HIGHEST.LEVEL.ALLOWED
; (add .01 so that we will not previous past a care level if the acuity
;  matches exactly (acuity is calulated to one decimal)
.01+TTL^EDM.CARE.LEVEL.minimum.acuity,
@Prev(EDM.CARE.LEVEL.minimum.acuity,@EDM.CARE.LEVEL.acuity.x),
@EDM.CARE.LEVEL.acuity.x^bill.txn.care.level

EXISTING.CARE.LEVEL
; this could only be the case if we are working off the late documentation index
; and even then there may not be an original charge.
IF{@acuity @acuity.bill.date^acuity.bill.date,@acuity.bill.q^acuity.bill.q,
           @bill.txn.care.level}

CREDIT.EXISTING.CARE.LEVEL
IF{@ALREADY.CREDITED @DONT.CREATE.TXNS;
   @CREDIT.TXN}

ALREADY.CREDITED
@bill.txn.credit.user^CRU

DONT.CREATE.TXNS
; If the original acuity charge was manually credited, EDM will NOT re-credit it OR
; generate a new charge txn because it is assumed the person who credited the original txn
; probably also entered the new charge txn.
""^bill.txn.care.level,
@ALERT.USER.WHO.CREDITED.TXN.IF.POSSIBLE

ALERT.USER.WHO.CREDITED.TXN.IF.POSSIBLE
; ED will notify the user who credited the original txn via email.
IF{@Pgm.trans("%MIS.OA.MSG.auto") 1^/USER[CRU],
                                  "ED Acuity Charge NOT Sent to Billing"^SUBJECT,
                                  @CREATE.MSG,
                                  %MIS.OA.MSG.auto("",Q(^/MSG,"",SUBJECT,"","",^/USER)),
                                  K(/MSG,/USER)}

CREATE.MSG
"ED acuity charge has been revised for "_@ADM.PAT.number.and.name_"."_@CR.LF^/MSG[1],
"The original charge, however, was manually credited on "_%Z.date.out(@bill.txn.credit.date)_"."_@CR.LF^/MSG[2],
"A new charge will NOT be automatically generated."_@CR.LF^/MSG[3],
"Please review this activity."^/MSG[4]

CR.LF
@Z.cr.lf

CREDIT.TXN
; give all txns a billing date of yesterday so that they will be
; immediately processed by the same midnite run which called this program.
;
@Lock(@Root(@edm.data.bill.txns)),
; ** create a new "credit" type txn
@GET.NEWQ,
@edm.data.bill.txns^@edm.data.bill.txns[*,@ACTIVITY.DATE,NEWQ],
"C"^@bill.txn.type[@ACTIVITY.DATE,NEWQ],
1^@bill.patient.x[@ACTIVITY.DATE,urn],
; ** add credit information to the original
@ACTIVITY.DATE^@bill.txn.credit.date,@.user^@bill.txn.credit.user,
; ** maybe add the ignore flag to both
;    if we know we are sending offseting txns, just don't bother sending either.
IF{@ORIG.TXN.MAY.HAVE.GONE.TO.BAR;
   "Y"^@bill.txn.ignore^@bill.txn.ignore[@ACTIVITY.DATE,NEWQ]},
""^NEWQ,
@Unlock(@Root(@edm.data.bill.txns))

GET.NEWQ
-@edm.data.bill.txns[urn,@ACTIVITY.DATE,""]+1^NEWQ

ORIG.TXN.MAY.HAVE.GONE.TO.BAR
@MIS.BAR.BCH.build.started[@.db,@bill.txn.date]

FILE.CARE.LEVEL.CHARGE
; give all txns a billing date of yesterday so that they will be
; immediately processed by the same midnite run which called this program.
;
@Lock(@Root(@edm.data.bill.txns)),
@ACTIVITY.DATE^@bill.txn.date^@acuity.bill.date,
@Last(bill.txn.q)+1^bill.txn.q^@acuity.bill.q,
IF{@ADM.PAT.service.date;@ADM.PAT.arrival.date;@bill.txn.date}^SDT,
IF{@ADM.PAT.service.time;@ADM.PAT.arrival.time}^STM,%Z.time.in(STM)^STM,
@EDM.LOC.mis.revenue.site[@current.location]^REV,
{"D",@EDM.CARE.LEVEL.mnemonic,@EDM.CARE.LEVEL.charge,@.user,"","",@EDM.CARE.LEVEL.billing.procedure,1,SDT,"C","S","","","",REV,STM}^@edm.data.bill.txns,
1^@bill.patient.x,""^SDT^STM^REV,
@Unlock(@Root(@edm.data.bill.txns))

BEFORE.IMAGE.FOR.REPOSITORY
%Z.dr.image(0,urn,@Pgm.name(""),"EDM")

AFTER.IMAGE.FOR.REPOSITORY
%Z.dr.image(1,urn,@Pgm.name(""),"EDM")

ACTIVITY.DATE
ADT
